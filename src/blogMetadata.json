[
  {
    "id": 1,
    "title": "2024字节前端面经汇总",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "面经",
    "tags": [
      "2024字节"
    ],
    "date": "2024-08-14",
    "abstract": "字节面经汇总题",
    "fileName": "2024字节前端面经汇总.md",
    "filePath": "/2024/08/2024字节前端面经汇总.md",
    "mdContent": "\n## 解释HTML5中的Canvas和SVG的区别。\n\n- Canvas: 是HTML5中的一种基于像素的图形技术，通过JavaScript动态绘制图形。每次绘制时，Canvas不会保留之前的状态，主要用于高频率的图形更新，例如游戏、动画等。\n- SVG (Scalable Vector Graphics): 是基于XML的矢量图形格式，具有可缩放性，适用于图形不频繁变化的场景。SVG图形可以被单独选中和修改，且有更好的性能处理静态图形。\n\n## CSS选择器的优先级是如何确定的？\n\n- 优先级规则：\n    \n    1. 内联样式（例如，style=\"...\"）具有最高优先级。\n    2. ID选择器（#id）的优先级高于类选择器（.class）和伪类。\n    3. 类选择器、属性选择器和伪类选择器的优先级相同。\n    4. 元素选择器和伪元素选择器的优先级最低。\n    5. 通配符选择器（*）、后代选择器和相邻兄弟选择器具有最低的优先级。\n\n- 优先级值可以用四位数的格式来计算，例如 0, 1, 0, 0 表示 ID 选择器。\n\n## 描述Flexbox布局中的工作原理及其常用属性。\n\n- Flexbox: 是一种一维布局模型，用于在容器中分配空间并对齐其子元素。它主要有以下属性：\n    - display: flex: 将容器设为弹性容器。\n    - flex-direction: 决定主轴的方向，row（横向）或 column（纵向）。\n    - justify-content: 决定沿主轴的对齐方式。\n    - align-items: 决定沿交叉轴的对齐方式。\n    - flex-wrap: 决定子元素是否换行。\n\n## CSS的伪类实现响应式设计的关键是什么？\n\n- 伪类如 `:hover`, `:focus`, `:active` 等可以用来响应用户操作，但真正的响应式设计更多依赖于媒体查询（Media Queries）。\n- 媒体查询：可以根据设备的屏幕宽度、分辨率等条件应用不同的CSS规则，从而实现不同设备下的响应式设计。例如：\n\n```css\n@media (max-width: 600px) {\n  body {\n    background-color: lightblue;\n  }\n}\n```\n\n## JavaScript中的原型链是如何工作的？\n\n原型链是JavaScript实现继承的一种机制。每个对象都有一个 `__proto__` 属性，指向其构造函数的原型对象，而该原型对象本身又有一个 `__proto__`，这样层层相连直到 `null` 结束，这样的结构就称为原型链。当访问一个对象的属性时，`JavaScript`会沿着原型链向上查找直到找到该属性或到达 `null`\n\n## 简要定义Ajax？请给出一个实际应用的例子。\n\n- Ajax (Asynchronous JavaScript and XML): 是一种使用JavaScript实现与服务器进行异步通信的技术。它允许在不重新加载整个网页的情况下从服务器获取数据并更新页面内容。\n- 例子: 通过Ajax获取天气信息：\n\n```js\nconst xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://api.weatherapi.com/v1/current.json?key=YOUR_API_KEY&q=London', true);\nxhr.onload = function() {\n  if (xhr.status === 200) {\n    const data = JSON.parse(xhr.responseText);\n    console.log(data);\n  }\n};\nxhr.send();\n```\n\n## 事件冒泡和事件捕获有什么区别？\n\n- 事件冒泡: 事件首先从目标元素开始，然后逐层向上冒泡到根元素，即文档对象 (document)。\n- 事件捕获: 事件从最顶层的元素开始，然后逐层向下到达目标元素。\n- 默认情况下，事件会先经过捕获阶段，然后在目标元素触发，再进入冒泡阶段。如果在冒泡或捕获阶段调用 event.stopPropagation()，则事件不会再继续传播。\n\n## 如何实现深拷贝和浅拷贝？\n\n- 浅拷贝: 只拷贝对象的第一层属性，如果属性是对象，仍然引用原对象。常用方法有 Object.assign() 或者展开运算符（...）。\n- 深拷贝: 拷贝对象的每一层属性，包括嵌套对象。可以使用 JSON.parse(JSON.stringify(obj)) 实现简单对象的深拷贝，或者用递归遍历每个属性手动实现。\n\n1. 递归实现深度拷贝：\n\n```js\nfunction deepClone(obj) {\n    // 判断是否为对象或数组\n    if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }\n\n    // 判断是否为数组\n    const clone = Array.isArray(obj) ? [] : {};\n\n    // 递归复制每个属性\n    for (let key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            clone[key] = deepClone(obj[key]);\n        }\n    }\n    return clone;\n}\n\nconst original = { a: 1, b: { c: 2 } };\nconst deepCopy = deepClone(original);\n\ndeepCopy.b.c = 10;\nconsole.log(original.b.c); // 输出：2\nconsole.log(deepCopy.b.c); // 输出：10\n```\n    \n2. 使用JSON.parse()和JSON.stringify()（仅适用于没有函数、undefined、Symbol等特殊数据类型的对象）：\n\n```js\nconst original = { a: 1, b: { c: 2 } };\nconst deepCopy = JSON.parse(JSON.stringify(original));\n\ndeepCopy.b.c = 10;\nconsole.log(original.b.c); // 输出：2\nconsole.log(deepCopy.b.c); // 输出：10\n\n```\n\n## 什么是Promise？如何手动实现一个Promise？\n\n- Promise: 是用于处理异步操作的对象。它代表了一个异步操作的最终完成（或失败）及其结果值。\n- Promise 有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。\n- 实现一个简单的Promise：\n\n```js\nclass MyPromise {\n  constructor(executor) {\n    this.state = 'pending';\n    this.value = null;\n    this.callbacks = [];\n\n    const resolve = value => {\n      if (this.state === 'pending') {\n        this.state = 'fulfilled';\n        this.value = value;\n        this.callbacks.forEach(callback => callback());\n      }\n    };\n\n    const reject = reason => {\n      if (this.state === 'pending') {\n        this.state = 'rejected';\n        this.value = reason;\n        this.callbacks.forEach(callback => callback());\n      }\n    };\n\n    try {\n      executor(resolve, reject);\n    } catch (error) {\n      reject(error);\n    }\n  }\n\n  then(onFulfilled, onRejected) {\n    return new MyPromise((resolve, reject) => {\n      if (this.state === 'fulfilled') {\n        resolve(onFulfilled ? onFulfilled(this.value) : this.value);\n      } else if (this.state === 'rejected') {\n        reject(onRejected ? onRejected(this.value) : this.value);\n      } else {\n        this.callbacks.push(() => {\n          if (this.state === 'fulfilled') {\n            resolve(onFulfilled ? onFulfilled(this.value) : this.value);\n          } else if (this.state === 'rejected') {\n            reject(onRejected ? onRejected(this.value) : this.value);\n          }\n        });\n      }\n    });\n  }\n}\n\n```\n\n## 解释async/await的工作原理，它是如何使异步代码更易懂的？\n\nasync/await 是基于Promise的语法糖，用于编写异步代码。async 函数会自动将返回值封装成一个Promise，await 用于暂停异步操作的执行，直到Promise解析完成，从而使异步代码看起来像同步代码。这种结构使得代码更易于理解和维护，减少了回调地狱的现象。例如：\n\n```js\nasync function fetchData() {\n  try {\n    const response = await fetch('https://api.example.com/data');\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error('Error:', error);\n  }\n}\n```\n\n在这个例子中，await 使得 fetch() 和 response.json() 的执行顺序像同步代码一样，从而提高了代码的可读性。\n\n## 介绍一下Event Loop的机制。\n\n- Event Loop 是JavaScript中的一个机制，用于处理异步任务。JavaScript 是单线程的，Event Loop 负责协调异步任务的执行。在事件循环中，所有的同步任务都在主线程上执行，形成一个执行栈；而异步任务则进入任务队列，当执行栈为空时，Event Loop 会将任务队列中的任务推入执行栈中执行。\n- 过程：\n    - 执行所有同步任务。\n    - 执行栈为空后，检查微任务队列（如 Promise.then() 的回调）。\n    - 执行所有微任务。\n    - 然后开始下一个事件循环，处理宏任务队列中的任务（如 setTimeout 的回调）。\n- Event Loop 的机制确保了异步代码能够在适当的时机执行，而不会阻塞主线程。\n\n## 如何实现函数去重？\n\n- 数组去重：可以使用 Set 或者 filter 来实现数组去重。例如：\n\n```js\nconst arr = [1, 2, 3, 4, 4, 5, 2, 1];\nconst uniqueArr = [...new Set(arr)]; // 使用 Set 去重\nconsole.log(uniqueArr); // [1, 2, 3, 4, 5]\n```\n\n```js\nconst uniqueArr = arr.filter((value, index, self) => self.indexOf(value) === index);\nconsole.log(uniqueArr); // [1, 2, 3, 4, 5]\n```\n\n- 对象数组去重：如果需要对数组中的对象去重，可以通过某个属性值来去重：\n\n```js\nconst arr = [{ id: 1 }, { id: 2 }, { id: 1 }];\nconst uniqueArr = arr.filter((item, index, self) => self.findIndex(t => t.id === item.id) === index);\nconsole.log(uniqueArr); // [{ id: 1 }, { id: 2 }]\n```\n\n## 介绍模块化开发，比如CommonJS、AMD和ES6 Modules。\n\n- CommonJS: 是Node.js采用的模块化规范。每个文件都是一个模块，模块通过 module.exports 导出，使用 require() 导入。例如：\n\n```js\n// 导出\nmodule.exports = function add(a, b) {\n  return a + b;\n};\n// 导入\nconst add = require('./add');\nconsole.log(add(2, 3)); // 5\n```\n\n- AMD (Asynchronous Module Definition): 是一种浏览器端的模块化规范，允许异步加载模块。使用 define() 定义模块，使用 require() 引入模块。例如：\n\n```js\ndefine(['module1', 'module2'], function(m1, m2) {\n  return function() {\n    // 模块逻辑\n  };\n});\n```\n\n- ES6 Modules: 是ES6引入的模块化方案，使用 import 和 export 语法进行模块的导入和导出。模块是默认严格模式，且在编译时解析。它支持静态分析，有利于优化。例如：\n\n```js\n// 导出\nexport function add(a, b) {\n  return a + b;\n}\n// 导入\nimport { add } from './add.js';\nconsole.log(add(2, 3)); // 5\n```\n\n## Web Workers是什么，它是如何提高页面性能的？\n\nWeb Workers: 是一种在后台线程运行脚本的机制，使得任务能够在不阻塞主线程的情况下运行，从而提高页面性能。Web Workers 允许在一个独立的线程中执行复杂的计算或处理大量数据，不影响UI的流畅性。\n使用: 创建一个新的Worker，主线程与Worker之间可以通过 postMessage 和 onmessage 进行通信。\n\n```js\n// main.js\nconst worker = new Worker('worker.js');\nworker.postMessage('Hello');\nworker.onmessage = function(event) {\n  console.log('Message from Worker:', event.data);\n};\n\n// worker.js\nonmessage = function(event) {\n  postMessage('Hello from Worker');\n};\n```\nWeb Workers的引入显著改善了需要进行大量计算或后台处理任务的网页应用的性能。\n\n## 解释Service Workers，并举例说明它在PWA中的应用。\n\nService Workers: 是运行在浏览器后台的脚本，主要用于控制页面的缓存和网络请求，提供离线访问、消息推送和后台同步等功能。Service Workers 是Progressive Web Apps (PWA) 的核心技术之一。\n\n应用: 例如，实现离线访问和缓存策略：\n\n\n```js\n// 注册Service Worker\nif ('serviceWorker' in navigator) {\n  navigator.serviceWorker.register('/service-worker.js').then(function(registration) {\n    console.log('Service Worker registered with scope:', registration.scope);\n  });\n}\n\n// service-worker.js\nself.addEventListener('install', function(event) {\n  event.waitUntil(\n    caches.open('my-cache').then(function(cache) {\n      return cache.addAll([\n        '/',\n        '/index.html',\n        '/styles.css',\n        '/script.js'\n      ]);\n    })\n  );\n});\n\nself.addEventListener('fetch', function(event) {\n  event.respondWith(\n    caches.match(event.request).then(function(response) {\n      return response || fetch(event.request);\n    })\n  );\n});\n```\n\n## 如何优化网站的加载速度？\n\n网站加载速度优化：\n- 减少HTTP请求：合并CSS和JS文件，使用CSS Sprite减少图片请求。\n- 延迟加载资源：使用 defer 或 async 属性延迟加载JavaScript脚本，或者懒加载图片。\n- 使用缓存：配置HTTP缓存头，使用Service Worker缓存资源，或者通过CDN分发静态资源。\n- 压缩文件：使用Gzip压缩CSS、JS和HTML文件，使用WebP格式压缩图片。\n- 优化图片：选择合适的图片格式（如WebP），并进行图片压缩。\n- 代码分割：对于大型应用，使用Webpack等工具进行代码分割，按需加载模块。\n- 减少重排和重绘：优化DOM操作，使用CSS3硬件加速。\n\n## 如何实现前端的安全，比如防止XSS和CSRF攻击？\n\n- XSS（跨站脚本攻击）：\n    - 输入过滤：对用户输入进行严格的过滤和校验，防止恶意代码注入。\n    - 输出编码：在输出到页面前对动态内容进行HTML编码，避免HTML标签被执行。\n    - Content Security Policy (CSP)：通过设置CSP头，限制哪些资源可以被加载，从而降低XSS攻击的风险。\n    - 避免直接在页面中插入用户输入：使用安全的API（如 textContent 而不是 innerHTML）来插入用户输入。\n\n- CSRF（跨站请求伪造）：\n\n    - 使用CSRF Token：服务器为每个会话生成一个唯一的Token，所有修改数据的请求都必须带上该Token，服务器验证Token以确保请求的合法性。\n    - 验证请求来源：通过Referer或Origin头部验证请求是否来自可信的来源。\n    - SameSite Cookie属性：设置Cookie的SameSite属性为 Strict 或 Lax，限制第三方网站发起跨站请求时携带Cookie。\n    \n通过这些措施，可以有效提高前端应用的安全性，防止常见的攻击。\n\n## 介绍HTTP2.0相比HTTP1.1有哪些改进？\n\n- 多路复用：HTTP/1.1中的每个请求都需要建立一个TCP连接，而HTTP/2.0允许在一个TCP连接中同时发送多个请求和响应，减少了延迟。\n\n- 头部压缩：HTTP/2.0使用HPACK算法对HTTP头部进行压缩，从而减少传输的数据量，提升传输效率。\n\n- 服务器推送：HTTP/2.0允许服务器主动向客户端推送资源，而不是等待客户端请求，这样可以提前加载资源，减少页面加载时间。\n\n- 二进制格式：HTTP/2.0使用二进制格式传输数据，而HTTP/1.1使用纯文本格式。二进制格式更易解析和处理，效率更高。\n\n- 这些改进使得HTTP/2.0在网络性能和资源利用方面相比HTTP/1.1有显著提升。\n\n## 什么是跨域？你有遇到如何解决跨域问题？\n\n- 跨域：由于同源策略的限制，浏览器禁止来自不同源（协议、域名、端口）的请求访问其他域名的资源，这就是跨域问题。\n\n- 解决跨域问题的方法：\n    - JSONP：通过动态创建`<script>`标签来实现跨域。缺点是只能用于GET请求。\n    - CORS（跨域资源共享）：服务器通过设置HTTP头部 Access-Control-Allow-Origin 来允许跨域请求，这是目前最常用的解决方案。\n    - 代理服务器：通过在前端和目标服务器之间建立一个代理服务器，由代理服务器转发请求，前端只与代理服务器交互，避免跨域问题。\n    - PostMessage：页面间通过postMessage方法进行数据通信，适用于iframe或窗口间的跨域通信。\n\n \n## Web缓存存储有哪些机制？\n\n- HTTP缓存：通过设置HTTP头部字段（如 Cache-Control、Expires、ETag 和 Last-Modified）来控制浏览器缓存资源。\n\n- Service Worker缓存：通过Service Worker进行更灵活的缓存控制，可以实现离线访问和更高级的缓存策略。\n\n- 浏览器缓存（LocalStorage, SessionStorage, IndexedDB, Cookie）：\n\n    - LocalStorage：持久存储，除非手动删除，否则数据不会过期。\n    - SessionStorage：会话存储，数据在浏览器关闭后被清除。\n    - IndexedDB：用于存储大量结构化数据，支持事务操作。\n    - Cookie：一般用于保存用户会话信息，且会自动随请求发送到服务器。\n    - 每种缓存机制有不同的应用场景，结合使用可以大幅度提升网页性能和用户体验。\n \n ## Vue和React有什么不同？\n \n- 框架 vs 库：Vue是一个渐进式框架，提供了更多开箱即用的功能，如指令系统、组件系统、双向数据绑定等。而React是一个库，专注于UI构建，需要结合其他工具（如Redux、Router等）来构建完整的应用。\n- 数据绑定：Vue采用的是双向数据绑定（v-model），而React是单向数据流，通过props和state管理数据。\n- 模板 vs JSX：Vue使用模板语法，结合指令和事件处理，代码更加简洁。React使用JSX，允许在JavaScript中编写类似HTML的代码，更加灵活。\n- 生态系统：Vue的生态系统围绕核心框架，提供了一整套官方工具，如Vue Router、Vuex等。React的生态系统更加多样化，社区贡献了大量第三方库和工具。\n\n## React的生命周期方法有哪些？\n\nReact 的生命周期方法主要分为三类：挂载（Mounting）、更新（Updating）、卸载（Unmounting）。\n\n- 挂载阶段：\n\n    - constructor(): 初始化state和绑定事件处理程序。\n    - static getDerivedStateFromProps(): 在组件实例化时调用，允许在render前更新state\n    - render(): 返回React元素，是唯一必须的方法。\n    - componentDidMount(): 在组件挂载后调用，常用于执行异步请求或操作DOM。\n\n- 更新阶段：\n\n    - static getDerivedStateFromProps(): 同挂载阶段。\n    - shouldComponentUpdate(): 控制组件是否需要重新渲染，优化性能。\n    - render(): 同挂载阶段。\n    - getSnapshotBeforeUpdate(): 在DOM更新前调用，获取更新前的DOM状态。\n    - componentDidUpdate(): 在组件更新后调用，常用于DOM操作或处理数据更新后的逻辑。\n\n- 卸载阶段：\n\n    - componentWillUnmount(): 在组件卸载前调用，清理资源（如定时器、事件监听等）。\n\n## 解释Vue的响应式原理。\n\nVue的响应式系统基于Object.defineProperty()（Vue 2）或Proxy（Vue 3）来实现的。当你向Vue实例添加一个数据属性时，Vue会将这个属性转化为响应式的，这意味着Vue能够追踪这个属性的读取和写入操作，以便在属性发生变化时通知依赖这个属性的组件更新。\n\n- Vue 2：Object.defineProperty()\n\n数据劫持：Vue在初始化时，会遍历数据对象的所有属性，并使用Object.defineProperty()将每个属性设置为getter和setter。\n依赖收集：在getter中，Vue会将当前依赖该属性的组件收集起来，形成依赖关系。\n派发更新：在setter中，Vue会检测到数据的变化，并通知所有依赖这个属性的组件重新渲染。\n\n- Vue 3：Proxy\n\nVue 3 使用 Proxy 代理整个对象，不需要遍历所有属性，可以更高效地创建响应式数据。\nProxy 还可以动态监听属性的增加或删除，这解决了Vue 2中对新添加属性无法响应的问题。\n这种响应式机制使得Vue能够高效地追踪数据变化，并更新DOM，从而使开发者可以专注于数据层逻辑而不必手动管理DOM更新。\n\n## 解释Vue中的虚拟DOM？\n\n虚拟DOM（Virtual DOM）是Vue中的一个核心概念，它是对实际DOM的一层抽象。\n\n- 虚拟DOM的工作原理：\n\n创建虚拟DOM：每次组件的状态或数据发生变化时，Vue会重新渲染组件，生成一个新的虚拟DOM树。\n对比虚拟DOM树（Diff算法）：Vue使用一种高效的Diff算法对新旧虚拟DOM树进行对比，找出实际DOM中需要更新的部分。\n更新实际DOM：Vue将上一步中找出的差异应用到实际的DOM中，完成视图的更新。\n\n- 虚拟DOM的优点：\n\n性能优化：直接操作DOM非常消耗性能，而虚拟DOM可以通过批量更新来减少不必要的DOM操作。\n跨平台：虚拟DOM是平台无关的，Vue可以通过不同的渲染器将虚拟DOM渲染到不同的平台（如浏览器、移动端、服务端等）。\n虚拟DOM是Vue性能优化的关键之一，它使得Vue在处理大量数据更新时能够保持良好的性能。\n\n## React中的虚拟DOM是什么？\n\nReact中的虚拟DOM（Virtual DOM）与Vue中的虚拟DOM概念相似，是对实际DOM的一种抽象层。\n\n- 虚拟DOM在React中的工作流程：\n\n    - 创建虚拟DOM：在每次组件更新时，React会生成新的虚拟DOM树。\n    - Diff算法：React使用一种高效的Diff算法（Reconciliation）来比较新旧虚拟DOM，确定需要更新的地方。\n    - 实际DOM更新：React根据Diff算法的结果，最小化地对实际DOM进行更新操作。\n\n- 优势：\n\n    - 减少重绘和回流：直接操作实际DOM可能会导致频繁的重绘和回流，影响性能。虚拟DOM通过批量更新避免了这些问题。\n    - 跨平台支持：React的虚拟DOM并不依赖于具体的浏览器环境，可以通过React Native等实现跨平台的渲染。\n\n## Redux是如何工作的？\n\nRedux是一个用于JavaScript应用的状态管理库，常用于React应用中。\n\n- 核心概念：\n\n    - 单一数据源（Single Source of Truth）：整个应用的状态存储在一个单一的、不可变的对象树（state）中，任何组件都可以访问这个对象树中的状态。\n    - 状态是只读的：唯一能改变状态的方法是触发一个action，action是一个描述状态变化的普通JavaScript对象。\n    - 使用纯函数来执行修改（Reducers）：Reducers是纯函数，它接收当前的state和action，并返回一个新的state。\n\n- 工作流程：\n\n    - 触发Action：当用户与应用交互时，触发一个action，这个action会描述发生了什么变化。\n    - Reducer更新状态：Redux调用对应的reducer，并传入当前状态和action，reducer会根据action的类型来更新状态并返回一个新的状态。\n    - 更新视图：Redux store会将新的状态发送给React组件，React组件根据新的状态重新渲染视图。\n\n- Redux中常用的工具：\n\n    - Middleware：Redux中间件是可以在dispatch action和到达reducer之间添加的额外功能，如处理异步操作。\n    - Store Enhancers：Store Enhancers是用于增强store的能力，如加入时间旅行调试等功能。\n\nRedux通过这种严格的状态管理方式，使得复杂应用的状态管理更加可控和可预测，同时配合中间件和增强器等功能，可以扩展其能力来适应各种应用需求。"
  },
  {
    "id": 2,
    "title": "WeakMap和Map的区别",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "前端",
    "tags": [
      "记录",
      "浏览器"
    ],
    "date": "2024-08-12",
    "abstract": "WeakMap 和 Map 的区别，WeakMap 原理，为什么能被 GC？",
    "fileName": "WeakMap和Map的区别.md",
    "filePath": "/2024/08/WeakMap和Map的区别.md",
    "mdContent": "\r\n### 垃圾回收机制\r\n\r\n我们知道，程序运行中会有一些垃圾数据不再使用，需要及时释放出去，如果我们没有及时释放，这就是内存泄露\r\n\r\nJS 中的垃圾数据都是由垃圾回收（Garbage Collection，缩写为 GC）器自动回收的，不需要手动释放，它是如何做的喃？\r\n\r\n很简单，JS 引擎中有一个后台进程称为垃圾回收器，它监视所有对象，观察对象是否可被访问，然后按照固定的时间间隔周期性的删除掉那些不可访问的对象即可\r\n\r\n现在各大浏览器通常用采用的垃圾回收有两种方法：\r\n\r\n- 引用计数\r\n- 标记清除\r\n\r\n#### 引用计数\r\n\r\n最早最简单的垃圾回收机制，就是给一个占用物理空间的对象附加一个引用计数器，当有其它对象引用这个对象时，这个对象的引用计数加一，反之解除时就减一，当该对象引用计数为 0 时就会被回收。\r\n\r\n 该方式很简单，但会引起内存泄漏：\r\n\r\n```js\r\n// 循环引用的问题\r\nfunction temp(){\r\n    var a={};\r\n    var b={};\r\n    a.o = b;\r\n    b.o = a;\r\n}\r\n```\r\n\r\n这种情况下每次调用 `temp` 函数，`a` 和 `b` 的引用计数都是 `2` ，会使这部分内存永远不会被释放，即内存泄漏。现在已经很少使用了，只有低版本的 IE 使用这种方式。\r\n\r\n#### 标记清除\r\n\r\nV8 中主垃圾回收器就采用标记清除法进行垃圾回收。主要流程如下：\r\n\r\n- 标记：遍历调用栈，看老生代区域堆中的对象是否被引用，被引用的对象标记为活动对象，没有被引用的对象（待清理）标记为垃圾数据。\r\n- 垃圾清理：将所有垃圾数据清理掉\r\n\r\n![](http://resource.muyiy.cn/image/20210407230204.gif)\r\n\r\n（图片来源：How JavaScript works: memory management + how to handle 4 common memory leaks）\r\n\r\n在我们的开发过程中，如果我们想要让垃圾回收器回收某一对象，就将对象的引用直接设置为 `null` \r\n\r\n```js\r\nvar a = {}; // {} 可访问，a 是其引用\r\n\r\na = null; // 引用设置为 null\r\n// {} 将会被从内存里清理出去\r\n```\r\n\r\n但如果一个对象被多次引用时，例如作为另一对象的键、值或子元素时，将该对象引用设置为 `null` 时，该对象是不会被回收的，依然存在\r\n\r\n```js\r\nvar a = {}; \r\nvar arr = [a];\r\n\r\na = null; \r\nconsole.log(arr)\r\n// [{}]\r\n```\r\n\r\n如果作为 `Map` 的键喃？\r\n\r\n```js\r\nvar a = {}; \r\nvar map = new Map();\r\nmap.set(a, '三分钟学前端')\r\n\r\na = null; \r\nconsole.log(map.keys()) // MapIterator {{}}\r\nconsole.log(map.values()) // MapIterator {\"三分钟学前端\"}\r\n```\r\n\r\n如果想让 a 置为 `null` 时，该对象被回收，该怎么做喃？\r\n\r\n### WeakMap vs Map\r\n\r\nES6 考虑到了这一点，推出了： `WeakMap` 。它对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个\"Weak\"，表示这是弱引用（对对象的弱引用是指当该对象应该被GC回收时不会阻止GC的回收行为）。\r\n\r\n `Map` 相对于 `WeakMap` ：\r\n\r\n- `Map` 的键可以是任意类型，`WeakMap` 只接受对象作为键（null除外），不接受其他类型的值作为键\r\n- `Map` 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键； `WeakMap` 的键是弱引用，键所指向的对象可以被垃圾回收，此时键是无效的\r\n- `Map` 可以被遍历， `WeakMap` 不能被遍历\r\n\r\n下面以 `WeakMap` 为例，看看它是怎么上面问题的：\r\n\r\n```js\r\nvar a = {}; \r\nvar map = new WeakMap();\r\nmap.set(a, '三分钟学前端')\r\nmap.get(a)\r\n\r\na = null; \r\n```\r\n\r\n上例并不能看出什么？我们通过 `process.memoryUsage` 测试一下：\r\n\r\n```js\r\n//map.js\r\nglobal.gc(); // 0 每次查询内存都先执行gc()再memoryUsage()，是为了确保垃圾回收，保证获取的内存使用状态准确\r\n\r\nfunction usedSize() {\r\n    const used = process.memoryUsage().heapUsed;\r\n    return Math.round((used / 1024 / 1024) * 100) / 100 + \"M\";\r\n}\r\n\r\nconsole.log(usedSize()); // 1 初始状态，执行gc()和memoryUsage()以后，heapUsed 值为 1.64M\r\n\r\nvar map = new Map();\r\nvar b = new Array(5 * 1024 * 1024);\r\n\r\nmap.set(b, 1);\r\n\r\nglobal.gc();\r\nconsole.log(usedSize()); // 2 在 Map 中加入元素b，为一个 5*1024*1024 的数组后，heapUsed为41.82M左右\r\n\r\nb = null;\r\nglobal.gc();\r\n\r\nconsole.log(usedSize()); // 3 将b置为空以后，heapUsed 仍为41.82M，说明Map中的那个长度为5*1024*1024的数组依然存在\r\n```\r\n\r\n执行 `node --expose-gc map.js` 命令：\r\n\r\n![](http://resource.muyiy.cn/image/20210407235322.png)\r\n\r\n其中，`--expose-gc` 参数表示允许手动执行垃圾回收机制\r\n\r\n```js\r\n// weakmap.js\r\nfunction usedSize() {\r\n    const used = process.memoryUsage().heapUsed;\r\n    return Math.round((used / 1024 / 1024) * 100) / 100 + \"M\";\r\n}\r\n\r\nglobal.gc(); // 0 每次查询内存都先执行gc()再memoryUsage()，是为了确保垃圾回收，保证获取的内存使用状态准确\r\nconsole.log(usedSize()); // 1 初始状态，执行gc()和 memoryUsage()以后，heapUsed 值为 1.64M\r\nvar map = new WeakMap();\r\nvar b = new Array(5 * 1024 * 1024);\r\n\r\nmap.set(b, 1);\r\n\r\nglobal.gc();\r\nconsole.log(usedSize()); // 2 在 Map 中加入元素b，为一个 5*1024*1024 的数组后，heapUsed为41.82M左右\r\n\r\nb = null;\r\nglobal.gc();\r\n\r\nconsole.log(usedSize()); // 3 将b置为空以后，heapUsed 变成了1.82M左右，说明WeakMap中的那个长度为5*1024*1024的数组被销毁了\r\n```\r\n\r\n执行 `node --expose-gc weakmap.js` 命令：\r\n\r\n![](http://resource.muyiy.cn/image/20210407235841.png)\r\n\r\n上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了它的帮助，解决内存泄漏就会简单很多。\r\n\r\n最后看一下 `WeakMap` \r\n\r\n#### WeakMap \r\n\r\nWeakMap 对象是一组键值对的集合，其中的**键是弱引用对象，而值可以是任意**。\r\n\r\n**注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。**\r\n\r\nWeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的key则变成无效的），所以，WeakMap 的 key 是不可枚举的。\r\n\r\n属性：\r\n\r\n- constructor：构造函数\r\n\r\n方法：\r\n\r\n- has(key)：判断是否有 key 关联对象\r\n- get(key)：返回key关联对象（没有则则返回 undefined）\r\n- set(key)：设置一组key关联对象\r\n- delete(key)：移除 key 的关联对象\r\n\r\n```js\r\nlet myElement = document.getElementById('logo');\r\nlet myWeakmap = new WeakMap();\r\n\r\nmyWeakmap.set(myElement, {timesClicked: 0});\r\n\r\nmyElement.addEventListener('click', function() {\r\n  let logoData = myWeakmap.get(myElement);\r\n  logoData.timesClicked++;\r\n}, false);\r\n```\r\n\r\n除了 `WeakMap` 还有 `WeakSet` 都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏\r\n\r\n另外还有 ES12 的 `WeakRef` ，感兴趣的可以了解下，今晚太晚了，之后更新\r\n\r\n##### 参考\r\n\r\n[你不知道的 WeakMap](https://www.cnblogs.com/xiaonian8/p/13700201.html)"
  },
  {
    "id": 3,
    "title": "es6 及 es6+ 的能力集",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "前端",
    "tags": [
      "记录",
      "ES6"
    ],
    "date": "2024-08-12",
    "abstract": "ES6 的特性是使用最多的，包括类、模块化、箭头函数、函数参数默认值、模板字符串、解构赋值、延展操作符、Promise、let 与 const等等",
    "fileName": "es6 及 es6+ 的能力集.md",
    "filePath": "/2024/08/es6 及 es6+ 的能力集.md",
    "mdContent": "\r\n## 我最常用的\r\n\r\nES6 的特性是使用最多的，包括类、模块化、箭头函数、函数参数默认值、模板字符串、解构赋值、延展操作符、Promise、let 与 const等等，这部分已经是开发必备了，没什么好说的\r\n\r\n另外还有：\r\n\r\n- ES7 的 `Array.prototype.includes()` \r\n- ES8 的 async/await 、String padding: `padStart()`和`padEnd()` 、 `Object.values()`\r\n- ES9 的 Rest/Spread 属性、for await of、 `Promise.finally()`\r\n- ES10 的 `Array.prototype.flat()` 、 `Array.prototype.flatMap()` 、String的 `trimStart()` `trimEnd()` \r\n- ES11 的 `Promise.allSettled` 、空值处理及可选链\r\n- ES12 的逻辑赋值操作符、数字分隔符、 `Promise.any()`\r\n\r\n## 最有用的 \r\n\r\nES6 的特性都很有用，ES7-ES11中，我比较感兴趣的是：\r\n\r\n- ES8 的 async/await\r\n- ES9 的 for await of\r\n- ES11 的 `Promise.allSettled` 、ES9 的 `Promise.finally()` 、ES12 的 `Promise.any()`\r\n- 还有常用的逻辑操作：逻辑赋值操作符、数字分隔符、空值处理及可选链等都很大的简洁优化了我们的代码\r\n\r\n其中，async/await 异步终极解决方案，`for await of` 异步串行，`Promise.allSettled` 解决了 `Promise.all` 的只要一个请求失败了就会抛出错误的问题，当我们一次发起多个请求时，所有结果都能返回，无论成功或失败，等等等，不了解的可以往下查找\r\n\r\n下面列一下所有的特性，查漏补缺\r\n\r\n## ES6（ES2015）\r\n\r\n- 类\r\n- 模块化\r\n- 箭头函数\r\n- 函数参数默认值\r\n- 模板字符串\r\n- 解构赋值\r\n- 扩展操作符\r\n- 对象属性简写\r\n- Promise\r\n- let 与 const\r\n\r\n具体不再冗余介绍，这个属于前端基础\r\n\r\n## ES7（ES2016）\r\n\r\n- Array.prototype.includes()\r\n\r\n- 指数操作符\r\n\r\n### Array.prototype.includes()\r\n\r\n```js\r\n[1, 2].includes(1) // true\r\n```\r\n\r\n### 指数操作符\r\n\r\n```js\r\n2**5 // 32\r\n```\r\n\r\n## ES8（ES2017）\r\n\r\n- async/await\r\n- Object.values()\r\n- Object.entries()\r\n- String padding: `padStart()`和`padEnd()`，填充字符串达到当前长度\r\n- Object.getOwnPropertyDescriptors()\r\n- 函数参数列表结尾允许逗号\r\n- SharedArrayBuffer对象\r\n- Atomics对象\r\n\r\n### async/await\r\n\r\n异步终极解决方案\r\n\r\n```js\r\nasync getInfo(){\r\n    const res = await api.getData()\r\n    // ... \r\n}\r\n```\r\n\r\n### Object.values()\r\n\r\n```js\r\nObject.values({a: 1, b: 2, c: 3}) \r\n// [1, 2, 3]\r\n```\r\n\r\n\r\n\r\n### Object.entries()\r\n\r\n```js\r\nObject.values({a: 1, b: 2, c: 3}) \r\n// [[\"a\", 1], [\"b\", 2], [\"c\", 3]]\r\n```\r\n\r\n\r\n\r\n### String padding: `padStart()`和`padEnd()`\r\n\r\n**padStart()** 方法用另一个字符串填充当前字符串(如果需要的话，会重复多次)，以便产生的字符串达到给定的长度。从当前字符串的左侧开始填充\r\n\r\n```js\r\n// padStart\r\n'sister'.padStart(7, '0') // \"0sister\"\r\n// padEnd\r\n'sister'.padEnd(7, '0') // \"sister0\"\r\n```\r\n\r\n### Object.getOwnPropertyDescriptors()\r\n\r\n`Object.getOwnPropertyDescriptors()` 函数用来获取一个对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象\r\n\r\n### 函数参数列表结尾允许逗号\r\n\r\n这是一个不痛不痒的更新，主要作用是方便使用git进行多人协作开发时修改同一个函数减少不必要的行变更\r\n\r\n## ES9（ES2018）\r\n\r\n- 异步迭代（for await of）\r\n- Promise.finally()\r\n- Rest/Spread 属性\r\n- 新的正则表达式特性\r\n  - 正则表达式反向断言（lookbehind）\r\n  - 正则表达式dotAll模式\r\n  - 正则表达式命名捕获组（Regular Expression Named Capture Groups）\r\n  - 正则表达式 Unicode 转义\r\n  - 非转义序列的模板字符串\r\n\r\n\r\n\r\n### 异步迭代（for await of）\r\n\r\n`await` 可以和 `for…of` 循环一起使用，以串行的方式运行异步操作\r\n\r\n```js\r\nasync function getInfos(arr) {\r\n  for await (let i of arr) {\r\n    getData(i)\r\n  }\r\n}\r\n```\r\n\r\n### Promise.finally()\r\n\r\n无论 `Promise` 运行成功还是失败，都会运行 `finally`\r\n\r\n```js\r\nfunction getInfos() {\r\n  getData1()\r\n  .then(getData2)\r\n  .catch(err => {\r\n    console.log(err);\r\n  })\r\n  .finally(() => {\r\n    // ...\r\n  });\r\n}\r\n```\r\n\r\n\r\n\r\n### Rest/Spread 属性\r\n\r\n```js\r\nconst values = [1, 2, 3]\r\nconsole.log( Math.min(...values) ) // 1\r\n```\r\n\r\n\r\n\r\n### 新的正则表达式特性\r\n\r\n#### 正则表达式命名捕获组（Regular Expression Named Capture Groups）\r\n\r\n在一些正则表达式模式中，使用数字进行匹配可能会令人混淆。例如，使用正则表达式 `/(\\d{4})-(\\d{2})-(\\d{2})/` 来匹配日期。因为美式英语中的日期表示法和英式英语中的日期表示法不同，所以很难区分哪一组表示日期，哪一组表示月份\r\n\r\n```js\r\nconst re = /(\\d{4})-(\\d{2})-(\\d{2})/;\r\nconst match= re.exec('2019-01-01');\r\nconsole.log(match[0]);    // → 2019-01-01\r\nconsole.log(match[1]);    // → 2019\r\nconsole.log(match[2]);    // → 01\r\nconsole.log(match[3]);    // → 01\r\n```\r\n\r\nES9引入了命名捕获组，允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。\r\n\r\n```js\r\nconst re = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/;\r\nconst match = re.exec('2019-01-01');\r\nconsole.log(match.groups);          // → {year: \"2019\", month: \"01\", day: \"01\"}\r\nconsole.log(match.groups.year);     // → 2019\r\nconsole.log(match.groups.month);    // → 01\r\nconsole.log(match.groups.day);      // → 01\r\n```\r\n\r\n#### 正则表达式反向断言（lookbehind）\r\n\r\n```js\r\nlet test = 'hello sisteran'\r\nconsole.log(test.match(/(?<=sisteran\\s)hello/))\r\n// [\"hello\", index: 6, input: \"sisteran hello\", groups: undefined]\r\n```\r\n\r\n\r\n\r\n#### 正则表达式dotAll模式\r\n\r\n正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符,如换行符(\\n)或回车符(\\r),这个可以通过ES9的s(dotAll)flag，在原正则表达式基础上添加s表示:\r\n\r\n```js\r\nconsole.log(/foo.bar/.test('foo\\nbar')) // false\r\nconsole.log(/foo.bar/s.test('foo\\nbar')) // true\r\n```\r\n\r\n那如何判断当前正则是否使用了 dotAll 模式呢？\r\n\r\n```Js\r\nconst re = /foo.bar/s // Or, `const re = new RegExp('foo.bar', 's');`.\r\nconsole.log(re.test('foo\\nbar')) // true\r\nconsole.log(re.dotAll) // true\r\nconsole.log(re.flags) // 's' \r\n```\r\n\r\n#### 正则表达式 Unicode 转义\r\n\r\n引入了一种新的类的写法\\p{...}和\\P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符\r\n\r\n#### 非转义序列的模板字符串\r\n\r\n之前，`\\u`开始一个 unicode 转义，`\\x`开始一个十六进制转义，`\\`后跟一个数字开始一个八进制转义。这使得创建特定的字符串变得不可能，例如Windows文件路径 `C:\\uuu\\xxx\\111`。\r\n\r\n更多细节参考[模板字符串](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings)。\r\n\r\n## ES10（ES2019）\r\n\r\n- 新增了Array的 `flat()` 方法和 `flatMap()` 方法\r\n- 新增了String的 `trimStart()` 方法和 `trimEnd()` 方法\r\n- `Object.fromEntries()`\r\n- `Symbol.prototype.description()`\r\n- `Function.prototype.toString()` 现在返回精确字符，包括空格和注释\r\n- 简化 `try {} catch {}` ，修改 `catch` 绑定\r\n\r\n\r\n\r\n### 新增了Array的 `flat()` 方法和 `flatMap()` 方法\r\n\r\n`flat()` 和 `flatMap()` 本质上就是是归纳（reduce） 与 合并（concat）的操作\r\n\r\n```js\r\n[1, 2, [3, 4]].flat(Infinity); // [1, 2, 3, 4]\r\n\r\n[1, 2, 3, 4].flatMap(a => [a**2]); // [1, 4, 9, 16]\r\n```\r\n\r\n### 新增了String的 `trimStart()` 方法和 `trimEnd()` 方法\r\n\r\n分别去除字符串首尾空白字符\r\n\r\n### `Object.fromEntries()`\r\n\r\n> 返回一个给定对象自身可枚举属性的键值对数组\r\n\r\nObject.fromEntries() 是 Object.entries() 的反转\r\n\r\n- 通过 Object.fromEntries， 可以将 Map 转化为 Object:\r\n\r\n```js\r\nconst map = new Map([ ['foo', 'bar'], ['baz', 42] ]);\r\nconst obj = Object.fromEntries(map);\r\nconsole.log(obj); // { foo: \"bar\", baz: 42 }\r\n```\r\n\r\n- 通过 Object.fromEntries， 可以将 Array 转化为 Object:\r\n\r\n```js\r\nconst arr = [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ];\r\nconst obj = Object.fromEntries(arr);\r\nconsole.log(obj); // { 0: \"a\", 1: \"b\", 2: \"c\" }\r\n```\r\n\r\n### `Symbol.prototype.description()`\r\n\r\n> 只读属性，回 Symbol 对象的可选描述的字符串。\r\n\r\n```js\r\nSymbol('description').description; // 'description'\r\n```\r\n\r\n### `Function.prototype.toString()` 现在返回精确字符，包括空格和注释\r\n\r\n```js\r\nfunction /* comment */ foo /* another comment */() {}\r\n\r\n// 之前不会打印注释部分\r\nconsole.log(foo.toString()); // function foo(){}\r\n\r\n// ES2019 会把注释一同打印\r\nconsole.log(foo.toString()); // function /* comment */ foo /* another comment */ (){}\r\n\r\n// 箭头函数\r\nconst bar /* comment */ = /* another comment */ () => {};\r\n\r\nconsole.log(bar.toString()); // () => {}\r\n```\r\n\r\n### 简化 `try {} catch {}` ,修改 `catch` 绑定\r\n\r\n```js\r\ntry {} catch(e) {}\r\n```\r\n\r\n现在是\r\n\r\n```js\r\ntry {} catch {}\r\n```\r\n\r\n \r\n\r\n## ES11（ES2020）\r\n\r\n-  `Promise.allSettled()`\r\n- 可选链（Optional chaining）\r\n- 空值合并运算符（Nullish coalescing Operator）\r\n-  `import()` \r\n-  `globalThis` \r\n-   `BigInt`\r\n-  `String.prototype.matchAll`\r\n\r\n### Promise.allSettled\r\n\r\n与 `Promise.all` 不同的是，它会返回所有的 promise 结果\r\n\r\n```js\r\nconst promise1 = Promise.resolve('hello')\r\nconst promise2 = new Promise((resolve, reject) => setTimeout(reject, 200, 'problem'))\r\n\r\nPromise.allSettled([promise1, promise2])\r\n    .then((values) => {\r\n        console.log(values)\r\n    })\r\n```\r\n\r\n![](http://resource.muyiy.cn/image/20210422073838.png)\r\n\r\n### 可选链（Optional chaining）\r\n\r\n`可选链` 可让我们在查询具有多层级的对象时，不再需要进行冗余的各种前置校验。\r\n\r\n```js\r\nvar name = user && user.info && user.info.name;\r\n```\r\n\r\n又或是这种\r\n\r\n```js\r\nvar age = user && user.info && user.info.getAge && user.info.getAge();\r\n```\r\n\r\n很容易命中 `Uncaught TypeError: Cannot read property...` \r\n\r\n用了 Optional Chaining ，上面代码会变成\r\n\r\n```js\r\nvar name = user?.info?.name;\r\n```\r\n\r\n```js\r\nvar age = user?.info?.getAge?.();\r\n```\r\n\r\n### 空值合并运算符（Nullish coalescing Operator）\r\n\r\n设置一个默认的值\r\n\r\n```Js\r\nvar level =  user.data.level || '暂无等级';\r\n```\r\n\r\n来看看用空值合并运算符如何处理\r\n\r\n```js\r\n// {\r\n//   \"level\": 0   \r\n// }\r\nvar level = user.level ?? '暂无等级'; // level -> 0\r\n\r\n\r\n// {\r\n//   \"an_other_field\": 0   \r\n// }\r\nvar level = user.level ?? '暂无等级'; // level -> '暂无等级'\r\n\r\n```\r\n\r\n### import()\r\n\r\n按需加载\r\n\r\n### globalThis\r\n\r\nglobalThis 目的就是提供一种标准化方式访问全局对象，有了 globalThis 后，你可以在任意上下文，任意时刻都能获取到全局对象\r\n\r\n### BigInt\r\n\r\n**BigInt** 是一种内置对象，它提供了一种方法来表示大于 `253 - 1` 的整数。这原本是 Javascript中可以用 [`Number`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number) 表示的最大数字。**BigInt** 可以表示任意大的整数\r\n\r\n### String.prototype.matchAll()\r\n\r\n`matchAll()` 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器\r\n\r\n## ES12（ES2021）\r\n\r\n- String.prototype.replaceAll()\r\n-  Promise.any()\r\n-  WeakRef\r\n- 逻辑赋值操作符（Logical Assignment Operators）\r\n- 数字分隔符（Numeric separators）\r\n\r\n### String.prototype.replaceAll()\r\n\r\n> 返回一个全新的字符串，所有符合匹配规则的字符都将被替换掉\r\n\r\n```js\r\nconst str = 'sisteran';\r\nstr.replaceAll('s', 'q'); // 'qiqteran'\r\n```\r\n\r\n###  Promise.any()\r\n\r\nPromise.any() 接收一个Promise可迭代对象（例如数组），\r\n\r\n- 只要其中的一个 promise 成功，就返回那个已经成功的 promise \r\n- 如果可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise\r\n\r\n### WeakRef\r\n\r\n使用WeakRefs的Class类创建对对象的弱引用(对对象的弱引用是指当该对象应该被GC回收时不会阻止GC的回收行为)\r\n\r\n### 逻辑赋值操作符（Logical Assignment Operators）\r\n\r\n```js\r\na ||= b\r\n//等价于\r\na = a || (a = b)\r\n\r\na &&= b\r\n//等价于\r\na = a && (a = b)\r\n\r\na ??= b\r\n//等价于\r\na = a ?? (a = b)\r\n```\r\n\r\n\r\n\r\n### 数字分隔符（Numeric separators）\r\n\r\n```js\r\nconst money = 1_000_000_000 // 1000000000\r\n```\r\n\r\n\r\n\r\n参考：\r\n\r\n- [种草 ES2020 新特性](https://juejin.cn/post/6844904034780839944)\r\n- [ES6、ES7、ES8、ES9、ES10新特性一览](https://juejin.cn/post/6844903811622912014)\r\n- [盘点ES7、ES8、ES9、ES10新特性](https://juejin.cn/post/6844904018834096142#heading-14)\""
  },
  {
    "id": 4,
    "title": "在 GitHub Pages 上部署 React 应用的路由问题解决方案",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "前端",
    "tags": [
      "Github",
      "部署",
      "React",
      "路由"
    ],
    "date": "2024-08-06",
    "abstract": "这是因为在 GitHub Pages 上部署 React 应用时，由于 GitHub Pages 是静态网站托管服务，不支持像服务器那样处理路由",
    "fileName": "githubspage路由问题.md",
    "filePath": "/2024/08/githubspage路由问题.md",
    "mdContent": "\n# 为什么会出问题？\n\n我只想吐槽，github pages服务部署真的是一堆的问题，这个路由问题发生是部署pages后，部署后能正常访问首页，但是一点路由跳转就不行了\n\n初步判断原因是browserrouter的问题，这是因为在 GitHub Pages 上部署 React 应用时，由于 GitHub Pages 是静态网站托管服务，不支持像服务器那样处理路由，所以在刷新或直接访问非根路径（例如 `/home`, `/demo` 等）时会出现 404 错误。\n\n反正网络上一堆解决方法，无非是两点，改为哈希路由，要么配置一个 `404.html` 来处理客户端路由。\n\n后者的处理是粗暴的，也就是直接会进到404里面，无法解决上述问题。\n\n哈希路由是我非常不想要的，因为有个`#`，显得非常不专业，但是除了换到自己的服务器上之外，我好像别无选择了。\n\n所以被迫的是，我使用了 `HashRouter` 。\n\n\n# 为什么 `HashRouter` 可以解决问题\n\n`HashRouter` 使用 URL 的哈希部分（#）来保持 UI 的状态，这样可以避免在服务器端处理路由：\n\n- **哈希部分由浏览器处理**：浏览器在处理 URL 时，哈希部分（#后面的内容）不会被发送到服务器。因此，使用哈希路由可以确保所有请求都被发送到同一个静态文件（通常是 `index.html`），浏览器可以在客户端处理路由。\n  \n-  **页面加载**：当用户导航到一个新的路由时，例如 `http://example.com/#/home`，浏览器只会请求 `http://example.com/`，然后客户端 JavaScript 代码会根据哈希部分的内容渲染正确的组件。\n\n废话少说，直接看怎么做的吧\n\n# 实现方法\n\n使用 `HashRouter`，主要是修改`router.js` 文件就行。\n\n- 修改 `router.js` 文件：\n\n```tsx\nimport { createHashRouter, Navigate } from 'react-router-dom';\nimport Home from '../views/home';\n\n\nconst router = [\n  {\n    path: '/',\n    element: <Navigate to='/home' />\n  },\n  ...// 你的路由\n];\n\nexport default createHashRouter(router);\n\n```\n\n\n完了吗？\n\n没完，因为我在某个网页中使用了锚点，锚点这个东西跟路由一样，锚点会被识别成路由页面，这样子的话就喜提404了\n\n所以还要针对锚点进行处理，这里我使用`HashLink`\n\n- 首先需要安装`HashLink`\n\n```shell\nyarn add react-router-hash-link\n```\n\n- 然后在需要引用锚点的地方使用\n- \n```tsx\nimport { HashLink as Link } from 'react-router-hash-link';\n\n<Link to={`#id`}>跳转</Link>\n\n```\n \n这样子就能愉快使用啦\n\n总结：HashRouter：通过使用 URL 的哈希部分来处理客户端路由，避免了对服务器端路由的需求。"
  },
  {
    "id": 5,
    "title": "二分查找算法的总结",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "Js",
      "二分"
    ],
    "date": "2024-08-11",
    "abstract": "二分查找",
    "fileName": "二分查找算法.md",
    "filePath": "/2024/08/二分查找算法.md",
    "mdContent": "\n# 查找算法\n\n## 二分查找 (Binary Search)\n\n- 二分查找就像是在一本已经排序好的字典中查找某个单词。你从中间开始，检查一下目标是否在中间。如果目标在左边，那就丢弃右半部分；如果在右边，就丢弃左半部分。这样每次都能将查找范围缩小一半，直到找到目标。\n\n\n```js\nfunction binarySearch(arr, target) {\n    let left = 0;\n    let right = arr.length - 1;\n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n        if (arr[mid] === target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n\nconsole.log(binarySearch([11, 12, 22, 25, 34, 64, 90], 22));\n```"
  },
  {
    "id": 6,
    "title": "什么变量是存储在堆/栈？",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "前端",
    "tags": [
      "记录",
      "算法"
    ],
    "date": "2024-08-12",
    "abstract": "",
    "fileName": "什么变量是存储在堆和栈？.md",
    "filePath": "/2024/08/什么变量是存储在堆和栈？.md",
    "mdContent": "\r\n什么变量保存在堆/栈中？\r\n\r\n看到这个问题，第一反应表示很简单，基本类型保存在栈中，引用类型保存到堆中✌️✌️✌️，但仅仅就如此简单吗？我们接下来详细看一看\r\n\r\n### JS 数据类型\r\n\r\n我们知道 JS 就是动态语言，因为在声明变量之前并不需要确认其数据类型，所以 **JS 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据** 。\r\n\r\nJS 值有 8 种数据类型：\r\n\r\n- Boolean：有 `true` 和 `false`\r\n- Undefined：没有被赋值的变量或变量被提升时的，都会有个默认值 `undefined` \r\n- Null：只有一个值 `null`\r\n- Number：数字类型\r\n- BigInt（ES10）：表示大于 `253 - 1` 的整数\r\n- String：字符类型\r\n- Symbol（ES6）\r\n- Object：对象类型\r\n\r\n其中前 7 种数据类型称为基本类型，把最后一个对象类型称为引用类型\r\n\r\n### JS中的变量存储机制\r\n\r\nJS 内存空间分为栈(stack)空间、堆(heap)空间、代码空间。其中代码空间用于存放可执行代码。\r\n\r\n#### 栈空间\r\n\r\n栈是内存中一块用于存储局部变量和函数参数的线性结构，遵循着先进后出 (LIFO / Last In First Out) 的原则。栈由内存中占据一片连续的存储空间，出栈与入栈仅仅是指针在内存中的上下移动而已。\r\n\r\nJS 的栈空间就是我们所说的调用栈，是用来存储执行上下文的，包含变量空间与词法环境，var、function保存在变量环境，let、const 声明的变量保存在词法环境中。\r\n\r\n\r\n\r\n```js\r\nvar a = 1\r\nfunction add(a) {\r\n  var b = 2\r\n  let c = 3\r\n  return a + b + c\r\n}\r\n\r\n// 函数调用\r\nadd(a)\r\n```\r\n\r\n这段代码很简单，就是创建了一个 `add` 函数，然后调用了它。\r\n\r\n下面我们就一步步的介绍整个函数调用执行的过程。\r\n\r\n在执行这段代码之前，JavaScript 引擎会先创建一个全局执行上下文，包含所有已声明的函数与变量：\r\n\r\n![](http://resource.muyiy.cn/image/20210413063924.png)\r\n\r\n从图中可以看出，代码中的全局变量 `a` 及函数 `add` 保存在变量环境中。\r\n\r\n执行上下文准备好后，开始执行全局代码，首先执行 `a = 1`  的赋值操作，\r\n\r\n![](http://resource.muyiy.cn/image/20210413063937.png)\r\n\r\n赋值完成后 a 的值由 undefined 变为 1，然后执行 `add` 函数，JavaScript 判断出这是一个函数调用，然后执行以下操作：\r\n\r\n- 首先，从全局执行上下文中，取出 add 函数代码\r\n- 其次，对 add 函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码，并将执行上下文压入栈中\r\n\r\n![](http://resource.muyiy.cn/image/20210413063955.png)\r\n\r\n- 然后，执行代码，返回结果，并将 add 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。\r\n\r\n![](http://resource.muyiy.cn/image/20210413064006.png)\r\n\r\n至此，整个函数调用执行结束了。\r\n\r\n上面需要注意的是：函数（add）中存放在栈区的数据，在函数调用结束后，就已经自动的出栈，换句话说：栈中的变量在函数调用结束后，就会自动回收。\r\n\r\n所以，通常栈空间都不会设置太大，而基本类型在内存中占有固定大小的空间，所以它们的值保存在栈空间，我们通过 **按值访问** 。它们也不需要手动管理，函数调时创建，调用结束则消失。\r\n\r\n#### 堆\r\n\r\n堆数据结构是一种树状结构。它的存取数据的方式与书架和书非常相似。我们只需要知道书的名字就可以直接取出书了，并不需要把上面的书取出来。\r\n\r\n在栈中存储不了的数据比如对象就会被存储在堆中，在栈中只是保留了对象在堆中的地址，也就是对象的**引用** ，对于这种，我们把它叫做 **按引用访问** 。\r\n\r\n举个例子帮助理解一下：\r\n\r\n```js\r\nvar a = 1\r\nfunction foo() {\r\n  var b = 2\r\n  var c = { name: 'an' } // 引用类型\r\n}\r\n\r\n// 函数调用\r\nfoo()\r\n```\r\n\r\n![](http://resource.muyiy.cn/image/20210413064747.png)\r\n\r\n\r\n\r\n所以，堆空间通常很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间\r\n\r\n### JS中的变量存储机制与闭包\r\n\r\n对以上总结一下，JS 内存空间分为栈(stack)空间、堆(heap)空间、代码空间。其中代码空间用于存放可执行代码\r\n\r\n- 基本类型：保存在栈内存中，因为这些类型在存中分别占有固定大小的空间，通过按值来访问。\r\n- 引用类型：保存在堆内存中，因为这种值的大小不固定，因此不能把它们保存到栈内存中，但内存地址大小的固定的，因此保存在堆内存中，在栈内存中存放的只是该对象的访问地址。当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问。\r\n\r\n#### 闭包\r\n\r\n那么闭包喃？既然基本类型变量存储在栈中，栈中数据在函数执行完成后就会被自动销毁，那执行函数之后为什么闭包还能引用到函数内的变量？\r\n\r\n```js\r\nfunction foo() {\r\n  let num = 1 // 创建局部变量 num 和局部函数 bar\r\n  function bar() { // bar()是函数内部方法，是一个闭包\r\n      num++\r\n      console.log(num) // 使用了外部函数声明的变量，内部函数可以访问外部函数的变量\r\n  }\r\n  return bar // bar 被外部函数作为返回值返回了,返回的是一个闭包\r\n}\r\n\r\n// 测试\r\nlet test = foo()\r\ntest() // 2\r\ntest() // 3\r\n```\r\n\r\n在执行完函数 `foo` 后，`foo` 中的变量 `num` 应该被弹出销毁，为什么还能继续使用喃？\r\n\r\n这说明闭包中的变量没有保存在栈中，而是保存到了堆中：\r\n\r\n```js\r\nconsole.dir(test)\r\n```\r\n\r\n![](http://resource.muyiy.cn/image/20210412230925.png)\r\n\r\n所以 JS 引擎判断当前是一个闭包时，就会在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JS 是无法访问的），用来保存 num 变量\r\n\r\n注意，即使不返回函数（闭包没有被返回）：\r\n\r\n```js\r\nfunction foo() {\r\n  let num = 1 // 创建局部变量 num 和局部函数 bar\r\n  function bar() { // bar()是函数内部方法，是一个闭包\r\n      num++ \r\n      console.log(num) // 使用了外部函数声明的变量，内部函数可以访问外部函数的变量\r\n  }\r\n  bar() // 2\r\n  bar() // 3\r\n  console.dir(bar)\r\n}\r\n\r\nfoo()\r\n```\r\n\r\n![](http://resource.muyiy.cn/image/20210412234334.png)\r\n\r\n### 总结\r\n\r\n JS 就是动态语言，因为在声明变量之前并不需要确认其数据类型，所以 JS 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据， JS 值有 8 种数据类型，它们可以分为两大类——基本类型和引用类型。其中，基本类型的数据是存放在栈中，引用类型的数据是存放在堆中的。堆中的数据是通过引用和变量关联起来的。\r\n\r\n闭包除外，JS 闭包中的变量值并不保存中栈内存中，而是保存在堆内存中。"
  },
  {
    "id": 7,
    "title": "从Chrome V8源码看JavaScript数组",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "前端",
    "tags": [
      "记录",
      "算法"
    ],
    "date": "2024-08-12",
    "abstract": "",
    "fileName": "从Chrome V8源码看JavaScript数组.md",
    "filePath": "/2024/08/从Chrome V8源码看JavaScript数组.md",
    "mdContent": "\r\n\r\n### 简介\r\n\r\n数组、链表、栈、队列都是线性表，它表示的结构都是一段线性的结构，与之对应的就是非线性表，例如树、图、堆等，它表示的结构都非线性。\r\n\r\n我们知道在 JavaScript 中，可以在数组中保存不同类型值，并且数组可以动态增长，不像其它语言，例如 C，创建的时候要决定数组的大小，如果数组满了，就要重新申请内存空间。这是为什么喃？\r\n\r\n本节从 Chrome v8 源码角度回答这个问题，分为四个方面：\r\n\r\n- 数组基础入门\r\n- JavaScript 中，数组为什么可以保存不同类型？\r\n- JavaScript 中，数组是如何存储的喃？\r\n- JavaScript 中，数组的动态扩容与减容（ `FastElements` ）\r\n\r\n下面进入正题吧！（文末有惊喜）😊\r\n\r\n想要更多更快的学习本系列，可以关注公众号「前端瓶子君」和我的「[Github（点击查看）](https://github.com/sisterAn/JavaScript-Algorithms)」\r\n\r\n### 一、数组（基础）\r\n\r\n一种最基础的数据结构，每种编程语言都有，它编号从 0 开始，代表一组连续的储存结构，用来储存同一种类型的数据。\r\n\r\n```js\r\nlet arr = [1, 2, 3]\r\n```\r\n\r\n它的这种特定的存储结构（连续存储空间存储同一类型数据）决定了：\r\n\r\n**优点**\r\n\r\n- 随机访问：可以通过下标随机访问数组中的任意位置上的数据\r\n\r\n**缺点**\r\n\r\n- 对数据的删除和插入不是很友好\r\n\r\n**查找：** 根据下标随机访问的时间复杂度为 O(1)；\r\n\r\n**插入或删除：** 时间复杂度为 O(n)；\r\n\r\n在 JavaScript 中的数组几乎是万能的，它不光可以作为一个普通的数组使用，可以作为栈或队列使用。\r\n\r\n数组：\r\n\r\n```js\r\nlet array = [1, 2, 3]\r\n```\r\n\r\n栈：\r\n\r\n```js\r\nlet stack = [1, 2, 3]\r\n// 进栈\r\nstack.push(4)\r\n// 出栈\r\nstcak.pop()\r\n```\r\n\r\n队列：\r\n\r\n```js\r\nlet queue = [1, 2, 3]\r\n// 进队\r\nqueue.push(4)\r\n// 出队\r\nqueue.shift()\r\n```\r\n\r\n\r\n\r\n### 二、JavaScript 中，数组可以保存不同类型值\r\n\r\n看一下 Chrome v8 源码：\r\n\r\n```js\r\n// The JSArray describes JavaScript Arrays\r\n//  Such an array can be in one of two modes:\r\n//    - fast, backing storage is a FixedArray and length <= elements.length();\r\n//       Please note: push and pop can be used to grow and shrink the array.\r\n//    - slow, backing storage is a HashTable with numbers as keys.\r\nclass JSArray: public JSObject {\r\n public:\r\n  // [length]: The length property.\r\n  DECL_ACCESSORS(length, Object)\r\n    \r\n  // ...\r\n   \r\n  // Number of element slots to pre-allocate for an empty array.\r\n  static const int kPreallocatedArrayElements = 4;\r\n};\r\n```\r\n\r\n我们可以看到 `JSArray` 是继承自 `JSObject` 的，所以在 JavaScript 中，数组可以是一个特殊的对象，内部也是以 key-value 形式存储数据，所以 JavaScript 中的数组可以存放不同类型的值。\r\n\r\n\r\n\r\n### 三、JavaScript 中，数组的存储\r\n\r\n```js\r\n// The JSArray describes JavaScript Arrays\r\n//  Such an array can be in one of two modes:\r\n//    - fast, backing storage is a FixedArray and length <= elements.length();\r\n//       Please note: push and pop can be used to grow and shrink the array.\r\n//    - slow, backing storage is a HashTable with numbers as keys.\r\nclass JSArray: public JSObject {\r\n public:\r\n  // [length]: The length property.\r\n  DECL_ACCESSORS(length, Object)\r\n    \r\n  // ...\r\n   \r\n  // Number of element slots to pre-allocate for an empty array.\r\n  static const int kPreallocatedArrayElements = 4;\r\n};\r\n```\r\n `JSArray` 继承于 `JSObject` ，从注释上看，它有两种存储方式：\r\n\r\n- fast：存储结构是 `FixedArray` ，并且数组长度 `<= elements.length()` ，`push` 或 `pop` 时可能会伴随着动态扩容或减容\r\n- slow：存储结构是 `HashTable`（哈希表），并且数组下标作为 `key` \r\n\r\n`fast` 模式下数组在源码里面叫 `FastElements` ，而 `slow` 模式下的叫做 `SlowElements` 。\r\n\r\n#### 1. 快数组（FastElements）\r\n\r\n`FixedArray` 是 V8 实现的一个类似于数组的类，它表示一段连续的内存，可以使用索引直接定位。新创建的空数组默认就是快数组。当数组满（数组的长度达到数组在内存中申请的内存容量最大值）的时候，继续 `push` 时， `JSArray` 会进行动态的扩容，以存储更多的元素。\r\n\r\n#### 2. 慢数组（SlowElements）\r\n\r\n慢数组以哈希表的形式存储在内存空间里，它不需要开辟连续的存储空间，但需要额外维护一个哈希表，与快数组相比，性能相对较差。\r\n\r\n```js\r\n// src/objects/dictionary.h\r\nclass EXPORT_TEMPLATE_DECLARE(V8_EXPORT_PRIVATE) Dictionary\r\n    : public HashTable<Derived, Shape> {\r\n  using DerivedHashTable = HashTable<Derived, Shape>;\r\n\r\n public:\r\n  using Key = typename Shape::Key;\r\n  // Returns the value at entry.\r\n  inline Object ValueAt(InternalIndex entry);\r\n  inline Object ValueAt(const Isolate* isolate, InternalIndex entry);\r\n  \r\n  // ...\r\n};\r\n```\r\n\r\n从源码中可以看出，它的内部就是一个 HashTable。\r\n\r\n#### 3. 什么时候会从 fast 转变为 slow 喃？\r\n\r\n从 Chrome V8 源码上看，\r\n\r\n```js\r\n// src/objects/js-objects.h\r\nstatic const uint32_t kMaxGap = 1024;\r\n\r\n// src/objects/dictionary.h\r\n// JSObjects prefer dictionary elements if the dictionary saves this much\r\n// memory compared to a fast elements backing store.\r\nstatic const uint32_t kPreferFastElementsSizeFactor = 3;\r\n\r\n// src/objects/js-objects-inl.h\r\n// If the fast-case backing storage takes up much more memory than a dictionary\r\n// backing storage would, the object should have slow elements.\r\n// static\r\nstatic inline bool ShouldConvertToSlowElements(uint32_t used_elements,\r\n                                               uint32_t new_capacity) {\r\n  uint32_t size_threshold = NumberDictionary::kPreferFastElementsSizeFactor *\r\n                            NumberDictionary::ComputeCapacity(used_elements) *\r\n                            NumberDictionary::kEntrySize;\r\n  // 快数组新容量是扩容后的容量3倍之多时，也会被转成慢数组\r\n  return size_threshold <= new_capacity;\r\n}\r\n\r\nstatic inline bool ShouldConvertToSlowElements(JSObject object,\r\n                                               uint32_t capacity,\r\n                                               uint32_t index,\r\n                                               uint32_t* new_capacity) {\r\n  STATIC_ASSERT(JSObject::kMaxUncheckedOldFastElementsLength <=\r\n                JSObject::kMaxUncheckedFastElementsLength);\r\n  if (index < capacity) {\r\n    *new_capacity = capacity;\r\n    return false;\r\n  }\r\n  // 当加入的索引值（例如例3中的2000）比当前容量capacity 大于等于 1024时，\r\n  // 返回true，转为慢数组\r\n  if (index - capacity >= JSObject::kMaxGap) return true;\r\n  *new_capacity = JSObject::NewElementsCapacity(index + 1);\r\n  DCHECK_LT(index, *new_capacity);\r\n  // TODO(ulan): Check if it works with young large objects.\r\n  if (*new_capacity <= JSObject::kMaxUncheckedOldFastElementsLength ||\r\n      (*new_capacity <= JSObject::kMaxUncheckedFastElementsLength &&\r\n       ObjectInYoungGeneration(object))) {\r\n    return false;\r\n  }\r\n  return ShouldConvertToSlowElements(object.GetFastElementsUsage(),\r\n                                     *new_capacity);\r\n}\r\n```\r\n\r\n所以，当处于以下情况时，快数组会被转变为慢数组：\r\n\r\n- 当加入的索引值 index 比当前容量 capacity 差值大于等于 1024 时（index - capacity >= 1024）\r\n- 快数组新容量是扩容后的容量 3 倍之多时\r\n\r\n例如：向快数组里增加一个大索引同类型值\r\n\r\n```js\r\nvar arr = [1, 2, 3]\r\narr[2000] = 10;\r\n```\r\n\r\n当往 `arr` 增加一个 `2000` 的索引时，`arr` 被转成慢数组。节省了大量的内存空间（从索引为 2 到索引为 2000）。\r\n\r\n#### 4. 什么时候会从 slow 转变为 fast 喃？\r\n\r\n我们已经知道在什么时候会出现由快变慢，那由慢变快就很简单了\r\n\r\n```js\r\nstatic bool ShouldConvertToFastElements(JSObject object,\r\n                                        NumberDictionary dictionary,\r\n                                        uint32_t index,\r\n                                        uint32_t* new_capacity) {\r\n  // If properties with non-standard attributes or accessors were added, we\r\n  // cannot go back to fast elements.\r\n  if (dictionary.requires_slow_elements()) return false;\r\n  // Adding a property with this index will require slow elements.\r\n  if (index >= static_cast<uint32_t>(Smi::kMaxValue)) return false;\r\n  if (object.IsJSArray()) {\r\n    Object length = JSArray::cast(object).length();\r\n    if (!length.IsSmi()) return false;\r\n    *new_capacity = static_cast<uint32_t>(Smi::ToInt(length));\r\n  } else if (object.IsJSArgumentsObject()) {\r\n    return false;\r\n  } else {\r\n    *new_capacity = dictionary.max_number_key() + 1;\r\n  }\r\n  *new_capacity = Max(index + 1, *new_capacity);\r\n  uint32_t dictionary_size = static_cast<uint32_t>(dictionary.Capacity()) *\r\n                             NumberDictionary::kEntrySize;\r\n  // Turn fast if the dictionary only saves 50% space.\r\n  return 2 * dictionary_size >= *new_capacity;\r\n}\r\n```\r\n\r\n当慢数组的元素可存放在快数组中且长度在 smi 之间且仅节省了50%的空间，则会转变为快数组\r\n\r\n### 四、JavaScript 中，数组的动态扩容与减容（FastElements）\r\n\r\n默认空数组初始化大小为 `4` :\r\n\r\n```js\r\n// Number of element slots to pre-allocate for an empty array.\r\nstatic const int kPreallocatedArrayElements = 4;\r\n```\r\n\r\n在 JavaScript 中，当数组执行 `push` 操作时，一旦发现数组内存不足，将进行扩容。\r\n\r\n在 Chrome 源码中， `push` 的操作是用汇编实现的，在 c++ 里嵌入的汇编，以提高执行效率，并且在汇编的基础上用 c++ 封装了一层，在编译执行的时候，会将这些 c++ 代码转成汇编代码。\r\n\r\n计算新容量的函数：\r\n\r\n```js\r\n// js-objects.h\r\nstatic const uint32_t kMinAddedElementsCapacity = 16;\r\n\r\n// code-stub-assembler.cc\r\nNode* CodeStubAssembler::CalculateNewElementsCapacity(Node* old_capacity,\r\n                                                      ParameterMode mode) {\r\n  CSA_SLOW_ASSERT(this, MatchesParameterMode(old_capacity, mode));\r\n  Node* half_old_capacity = WordOrSmiShr(old_capacity, 1, mode);\r\n  Node* new_capacity = IntPtrOrSmiAdd(half_old_capacity, old_capacity, mode);\r\n  Node* padding =\r\n      IntPtrOrSmiConstant(JSObject::kMinAddedElementsCapacity, mode);\r\n  return IntPtrOrSmiAdd(new_capacity, padding, mode);\r\n}\r\n```\r\n\r\n所以扩容后新容量计公式为：\r\n\r\n> new_capacity = old_capacity /2 + old_capacity + 16\r\n\r\n即老的容量的 1.5 倍加上 16 。初始化为 4 个，当 `push` 第 5 个的时候，容量将会变成：\r\n\r\n> new_capacity = 4 / 2 + 4 + 16 = 22\r\n\r\n接着申请一块这么大的内存，把老的数据拷过去，把新元素放在当前 length 位置，然后将数组的 length + 1，并返回 length。\r\n\r\n所以，扩容可以分为以下几步：\r\n\r\n- `push` 操作时，发现数组内存不足\r\n- 申请 new_capacity = old_capacity /2 + old_capacity + 16 那么长度的内存空间\r\n- 将数组拷贝到新内存中\r\n- 把新元素放在当前 length 位置\r\n- 数组的 length + 1\r\n- 返回 length\r\n\r\n整个过程，用户是无感知的，不像 C，需用用户手动申请内存空间。\r\n\r\n当数组执行 `pop` 操作时，会判断 `pop` 后数组的容量，是否需要进行减容。\r\n\r\n不同于数组的 `push` 使用汇编实现的， `pop` 使用 c++ 实现的。\r\n\r\n判断是否进行减容：\r\n\r\n```js\r\nif (2 * length <= capacity) {\r\n  // If more than half the elements won't be used, trim the array.\r\n  isolate->heap()->RightTrimFixedArray(*backing_store, capacity - length);\r\n} else {\r\n  // Otherwise, fill the unused tail with holes.\r\n  BackingStore::cast(*backing_store)->FillWithHoles(length, old_length);\r\n}\r\n```\r\n\r\n所以，当数组 `pop` 后，如果数组容量大于等于 length 的 2 倍，则进行容量调整，使用 `RightTrimFixedArray` 函数，计算出需要释放的空间大小，做好标记，等待 GC 回收；如果数组容量小于 length 的 2 倍，则用 holes 对象填充。\r\n\r\n所以，减容可以分为以下几步：\r\n\r\n- `pop` 操作时，获取数组 `length`\r\n- 获取 `length - 1` 上的元素（要删除的元素）\r\n- 数组 `length - 1`\r\n- 判断数组的总容量是否大于等于 length - 1 的 2 倍\r\n- 是的话，使用 `RightTrimFixedArray` 函数，计算出需要释放的空间大小，并做好标记，等待 `GC` 回收\r\n- 不是的话，用 `holes` 对象填充\r\n- 返回要删除的元素\r\n\r\n\r\n\r\n### 五、解答开篇问题\r\n\r\nJavaScript 中， `JSArray` 继承自 `JSObject` ，或者说它就是一个特殊的对象，内部是以 key-value 形式存储数据，所以 JavaScript 中的数组可以存放不同类型的值。它有两种存储方式，快数组与慢数组，初始化空数组时，使用快数组，快数组使用连续的内存空间，当数组长度达到最大时，`JSArray` 会进行动态的扩容，以存储更多的元素，相对慢数组，性能要好得多。当数组中 `hole` 太多时，会转变成慢数组，即以哈希表的方式（ key-value 的形式）存储数据，以节省内存空间。\r\n\r\n\r\n\r\n### 六、最后附赠一道前端面试题（腾讯）：数组扁平化、去重、排序\r\n\r\n关于 `Array` 的属性、方法这里不再做介绍，详看 [MDN Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array) 。\r\n\r\n面试题：\r\n\r\n\r\n\r\n>  已知如下数组：var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];\r\n>\r\n>  编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组\r\n\r\n\r\n\r\n答案：\r\n\r\n```js\r\nvar arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]\r\n// 扁平化\r\nlet flatArr = arr.flat(4)\r\n// 去重\r\nlet disArr = Array.from(new Set(flatArr))\r\n// 排序\r\nlet result = disArr.sort(function(a, b) {\r\n    return a-b\r\n})\r\nconsole.log(result)\r\n// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\r\n```\r\n\r\n关于 Set 请查阅 [Set、WeakSet、Map及WeakMap](https://github.com/LuNaHaiJiao/blog/issues/24)\r\n\r\n参考链接：\r\n\r\n[探究JS V8引擎下的“数组”底层实现](https://juejin.im/post/5d80919b51882538036fc87d)\r\n\r\n[从Chrome源码看JS Array的实现](https://zhuanlan.zhihu.com/p/26388217)\r\n"
  },
  {
    "id": 8,
    "title": "使用windows事件在页面中实现快捷键监听",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "前端",
    "tags": [
      "Js",
      "React",
      "TypeScript"
    ],
    "date": "2024-08-09",
    "abstract": "由于博客编写需要加一个快速保存的功能，可以通过快捷键`Ctrl+S`实现，但是这个快捷键被浏览器绑定为下载网页，所以我们需要在页面中对这一个快捷键进行更改",
    "fileName": "使用windows事件在页面中实现快捷键监听.md",
    "filePath": "/2024/08/使用windows事件在页面中实现快捷键监听.md",
    "mdContent": "\r\n## 使用useEffect实现快捷键绑定\r\n\r\n由于博客编写需要加一个快速保存的功能，可以通过快捷键`Ctrl+S`实现，但是这个快捷键被浏览器绑定为下载网页，所以我们需要在页面中对这一个快捷键进行更改\r\n\r\n这里以React为例，使用`useEffect`来实现监听和函数执行\r\n\r\n```ts\r\nuseEffect(() => {\r\n    const handlekeydown = (e: KeyboardEvent) => {\r\n      if (e.ctrlKey && e.key === 's') {\r\n        e.preventDefault();\r\n        handleSave();\r\n      }\r\n    };\r\n\r\n    window.addEventListener('keydown', handlekeydown);\r\n\r\n    return () => {\r\n      window.removeEventListener('keydown', handlekeydown);\r\n    };\r\n  }, []);\r\n\r\nconst handleSave = () => {\r\n    // 执行保存\r\n}\r\n```\r\n\r\n`handlekeydown`是一个监听执行函数，他接收一个键盘操作事件对象，然后判断`Ctrl`和`S`键是否被点击，被点击后执行相关的保存操作\r\n\r\n由于这个`useEffect`的依赖数组为空，所以只会在页面加载的时候执行一次，`return`会在页面销毁前解除监听，释放内存\r\n\r\n如果需要监听更多的操作，或者绑定更多的事件，需要了解js的事件类型\r\n\r\n## Js中的事件\r\n\r\nJavaScript中的事件是指由用户或浏览器自身触发的特定动作。例如，用户点击按钮、移动鼠标、按下键盘键等，都可以触发事件。常见的事件类型有：\r\n\r\n1. 鼠标事件\r\n\r\n- click：单击元素时触发\r\n- dblclick：双击元素时触发\r\n- mousedown：按下鼠标按钮时触发\r\n- mouseup：释放鼠标按钮时触发\r\n- mousemove：鼠标在元素上移动时触发\r\n- mouseover：鼠标移入元素时触发\r\n- mouseout：鼠标移出元素时触发\r\n- contextmenu：右键点击元素时触发\r\n\r\n2. 键盘事件\r\n\r\n- keydown：按下键盘按键时触发\r\n- keyup：释放键盘按键时触发\r\n- keypress：按下键盘按键时触发（不推荐使用，现代浏览器多用keydown代替）\r\n\r\n3. 表单事件\r\n\r\n- submit：表单提交时触发\r\n- focus：元素获得焦点时触发\r\n- blur：元素失去焦点时触发\r\n- change：元素值改变并失去焦点时触发\r\n\r\n4. 窗口事件\r\n\r\n- load：页面或资源加载完成时触发\r\n- resize：窗口大小改变时触发\r\n- scroll：滚动条位置改变时触发\r\n\r\n5. 拖放事件\r\n\r\n- drag：元素正在拖动时触发\r\n- dragstart：用户开始拖动元素时触发\r\n\r\n## 事件委托是什么？如何实现\r\n\r\n事件委托是一种将事件监听器添加到父元素，而不是每个子元素的技术。这可以减少内存消耗和提高性能。实现方式是利用事件冒泡，在父元素上添加事件监听器，通过`event.target`判断触发事件的子元素。\r\n\r\n## 如何阻止原始事件\r\n\r\n`event.preventDefault()`\r\n\r\n## 什么是事件捕获和事件冒泡？\r\n\r\n事件捕获和冒泡是DOM事件流的两个阶段。捕获阶段从最外层的祖先元素开始，逐级向下到达目标元素；冒泡阶段则相反，从目标元素开始向上冒泡到最外层祖先元素。\r\n\r\n## 阻止事件冒泡\r\n\r\n`event.stopPropagation()`\r\n\r\n"
  },
  {
    "id": 9,
    "title": "关于JS中this指向问题",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "前端",
    "tags": [
      "Js"
    ],
    "date": "2024-08-09",
    "abstract": "说明this的指向相关的问题，箭头函数的指向问题以及如何更改指向",
    "fileName": "关于JS中this指向问题.md",
    "filePath": "/2024/08/关于JS中this指向问题.md",
    "mdContent": "\r\n# this的指向\r\n\r\nthis的指向归结起来只有一条原则：\r\n> 永远指向最后调用其的对象\r\n\r\n以例子直接说明：\r\n\r\n\r\n```js\r\nlet name = 'waiter'\r\n\r\nconst a = () => {\r\n    let name = 'xiaoyy';  \r\n    console.log(name);              // waiter\r\n    console.log(\"inner:\", this);    // Windows\r\n}\r\n\r\na();\r\nconsole.log(\"outer:\", this);  // Windows\r\n```\r\n\r\n再来一个例子\r\n\r\n\r\n```js\r\nvar name = \"windowsName\";\r\nvar a = {\r\n    name: \"Cherry\",\r\n    fn : function () {\r\n        console.log(this.name);      // Cherry\r\n    }\r\n}\r\na.fn();\r\n```\r\n\r\n这里再次说明了this指向最后调用其的对象\r\n\r\n>参考：https://juejin.cn/post/6844903496253177863\r\n\r\n\r\n```js\r\nvar name = \"windowsName\";\r\nvar a = {\r\n    name : null,\r\n    // name: \"Cherry\",\r\n    fn : function () {\r\n        console.log(this.name);      // windowsName\r\n    }\r\n}\r\n\r\nvar f = a.fn;\r\nf();\r\n```\r\n\r\n从这个例子也可以看出来， this永远指向最后调用其的对象\r\n\r\n# 箭头函数的this指向问题\r\n\r\n箭头函数的this指向问题记住一点：\r\n\r\n> 箭头函数的this始终指向函数定义时的this，而不是执行时\r\n\r\n> 箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。\r\n\r\n具体通过例子说明\r\n\r\n\r\n```js\r\nvar name = \"waiter\";\r\n\r\nvar a = {\r\n    name : \"xiaoyy\",\r\n\r\n    func1: function () {\r\n        console.log(this.name)     \r\n    },\r\n\r\n    func2: function () {\r\n        setTimeout( () => {\r\n            this.func1()\r\n        },100);\r\n    }\r\n\r\n};\r\n\r\na.func1()      // xiaoyy\r\na.func2()     // TypeError: this.func1 is not a function\r\n```\r\n\r\n此时的`a.func2()`里面定义的this是指向windows的，所以他无法得到func1这个方法，可以通过在函数内使用_this代替this\r\n\r\n```js\r\nvar name = \"waiter\";\r\n\r\nvar a = {\r\n    name : \"xiaoyy\",\r\n\r\n    func1: function () {\r\n        console.log(this.name)     \r\n    },\r\n\r\n    func2: function () {\r\n        var _this = this;  // 用_this获取运行时this\r\n        setTimeout( () => {\r\n            _this.func1()\r\n        },100);\r\n    }\r\n\r\n};\r\n\r\na.func2()     // xiaoyy\r\n```\r\n\r\n# 改变this的指向\r\n\r\n`apply`,`call`,`bind`都可以改变函数的this指向，具体可以这样子做\r\n\r\n- apply\r\n\r\napply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数\r\n\r\n语法：\r\n>fun.apply(thisArg, [argsArray])\r\n\r\n\r\n```js\r\nvar a = {\r\n    name : \"Cherry\",\r\n\r\n    func1: function () {\r\n        console.log(this.name)\r\n    },\r\n\r\n    func2: function () {\r\n        setTimeout(  function () {\r\n            this.func1()\r\n        }.apply(a),100);\r\n    }\r\n\r\n};\r\n\r\na.func2()            // Cherry\r\n\r\n```\r\n\r\n- call\r\n\r\n\r\n语法： \r\n\r\n> fun.call(thisArg[, arg1[, arg2[, ...]]])\r\n\r\n```js\r\nvar a = {\r\n    name : \"Cherry\",\r\n\r\n    func1: function () {\r\n        console.log(this.name)\r\n    },\r\n\r\n    func2: function () {\r\n        setTimeout(  function () {\r\n            this.func1()\r\n        }.bind(a)(),100);\r\n    }\r\n\r\n};\r\n\r\na.func2()            // Cherry\r\n```\r\n\r\n- bind\r\n\r\n\r\n```js\r\nvar a = {\r\n    name : \"Cherry\",\r\n\r\n    func1: function () {\r\n        console.log(this.name)\r\n    },\r\n\r\n    func2: function () {\r\n        setTimeout(  function () {\r\n            this.func1()\r\n        }.bind(a)(),100);\r\n    }\r\n\r\n};\r\n\r\na.func2()            // Cherry\r\n\r\n```\r\n\r\n\r\n"
  },
  {
    "id": 10,
    "title": "我发现了掘金的Bug",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "前端",
    "tags": [
      "掘金"
    ],
    "date": "2024-08-12",
    "abstract": "掘金论坛的编辑器图像渲染存在问题",
    "fileName": "我发现了掘金的Bug.md",
    "filePath": "/2024/08/我发现了掘金的Bug.md",
    "mdContent": "\r\n可能这个标题有点蛊惑性了，没错，我其实就是想引起官方君的注意。\r\n\r\n这个bug经过测试，确实应该是存在的，这个跟掘金论坛所用的编辑器有关。\r\n\r\n掘金用的编辑器有个开源版本，叫[bytemd](https://github.com/bytedance/bytemd)\r\n\r\n这个插件在我的[个人博客](https://waiterxiaoyy.github.io)和[在线编译器YIDE](http://xiaorongshu.cc)中都使用过，是一款非常不错的开源组件。\r\n\r\n在我自己开发的过程中，就发现其渲染是有一点问题的，主要是文本标签、代码块和图像的渲染问题。\r\n\r\n在自己的项目中，我发现一个就针对性的调整一个，我原本以为是我的适配问题，但是今天我在掘金写文章的时候，发现其图像渲染也存在一样的问题。\r\n\r\n看图\r\n\r\n![Snipaste_2024-08-12_12-08-53.png](http://yiyang-site.oss-cn-guangzhou.aliyuncs.com/site/images/Snipaste_2024-08-12_12-08-53.png)\r\n\r\n**当复制粘贴进去编辑器时，会发现他的图像渲染会失去平衡，图像撑大超过可视区域。**\r\n\r\n经过测试，这样子发布，在文章浏览页面是没有问题的，暂时只发现在编辑区会出现这个情况。\r\n\r\n在自己开发的过程，我修复过这个问题，修复很简单，就是把图像的宽度设置为`100%`即可。\r\n\r\n```js\r\nimg {\r\n    width: 100%;\r\n}\r\n```\r\n\r\n![Snipaste_2024-08-12_12-10-10](http://yiyang-site.oss-cn-guangzhou.aliyuncs.com/site/images/Snipaste_2024-08-12_12-10-10.png)\r\n\r\n完美解决！\r\n\r\n上面是我一些粗略的见解，大家看看即可，官方也可进而去修复一下这个问题。"
  },
  {
    "id": 11,
    "title": "我用一周时间开发了一个前端在线编译器目前已开源",
    "author": "WaiterXiaoYY",
    "avatar": "http://yiyang-site.oss-cn-guangzhou.aliyuncs.com/site/images/logo.png",
    "category": "前端",
    "tags": [
      "Js",
      "React",
      "TypeScript",
      "Egg.js"
    ],
    "date": "2024-08-12",
    "abstract": "一款轻量型的在线前端编译器(http://xiaorongshu.cc)",
    "fileName": "我用一周时间开发了一个前端在线编译器，目前已开源.md",
    "filePath": "/2024/08/我用一周时间开发了一个前端在线编译器，目前已开源.md",
    "mdContent": "\r\n<div align=\"center\">\r\n<img src='http://yiyang-site.oss-cn-guangzhou.aliyuncs.com/site/images/logo.png'>\r\n    \r\n<h1 align=\"center\">YIDE</h1>\r\n\r\n[English 🌏](https://github.com/waiterxiaoyy/yide/tree/master/README.md) / 简体中文\r\n\r\n:point_right: 一款轻量型的在线前端编译器:cupid: :point_left:\r\n\r\n\r\n线上版本：[YIDE在线地址](http://xiaorongshu.cc)\r\n\r\n文档持续完善中......\r\n\r\n![GitHub Repo stars](https://img.shields.io/github/stars/waiterxiaoyy/YIDE)\r\n![GitHub commit activity](https://img.shields.io/github/commit-activity/y/waiterxiaoyy/YIDE)\r\n![GitHub package.json version](https://img.shields.io/github/package-json/v/waiterxiaoyy/YIDE)\r\n![GitHub License](https://img.shields.io/github/license/waiterxiaoyy/YIDE)\r\n![GitHub language count](https://img.shields.io/github/languages/count/waiterxiaoyy/YIDE)\r\n\r\n</div>\r\n\r\n## 介绍 :star2:\r\n\r\n![项目登录页](http://yiyang-site.oss-cn-guangzhou.aliyuncs.com/site/images/login.png)\r\n![项目主图](http://yiyang-site.oss-cn-guangzhou.aliyuncs.com/site/images/image.png)\r\n\r\n- YIDE是一款支持在线编写前端代码的编辑器，以`React`和`Typescript`为前端，以`Egg.js`和`Mysql`为后端，支持`html`、`js`、`css`和`markdown`编译，非常适合验证想法，实践操作和整理文档。\r\n\r\n- 本项目相比于当前一些在线编译器有以下特点：\r\n    - 支持用户区分，用户可拥有独立的文件管理空间\r\n    - 支持自定义脚本和样式文件\r\n    - 支持Markdown文件书写和编译\r\n\r\n- 开发此项目的初衷主要是两点：\r\n    - 一是经常问GPT写一些样式，但是不能及时查看到效果，干脆直接手撸一个自己的在线查看器，后面做着做着完善了一些功能\r\n    - 二是增加一下自己的项目经历\r\n\r\n\r\n## 特点 :boom:\r\n\r\n- :file_folder: **文件管理**：支持区分用户和文件存储，目前仅支持新文件创建，相比于其他在线平台，支持选择编译的主文件如html和md文件。\r\n\r\n- :cat: **效率编辑**：集成进来的`Monaco-Editor`，支持语言识别，代码补全以及高亮，支持一系列快捷键，如一键保存编译和格式化代码。\r\n\r\n- :penguin: **窗口拖动**：主要页面布局是文件区Explorer，编辑器Editor和展示区Viewer，支持各栏“自由”拖动。\r\n\r\n- :panda_face: **多类型文件编译**：支持`html`结合样式文件和脚本文件，支持`Markdown`格式文件编译。\r\n\r\n- :monkey: **自由化**：编写`html`文件支持自动引入默认的脚本文件和样式文件，也可自定义脚本文件和样式文件，具体查看使用文档。\r\n\r\n- :dog: **内置图床**：`Markdwon`支持图像上传，内置`OSS`图床。\r\n\r\n## 使用文档 :iphone:\r\n\r\n- **创建新文件**\r\n\r\n在主页的左侧文件索引区Explorer创建新建文件，支持`html`，`css`，`js`，`md`为后缀的文件，其中html和md是可编译执行的文件。\r\n\r\n**默认文件：`index.html`，`script.js`，`style.css` 是默认文件，默认文件不允许删除。**\r\n\r\n**自行创建的文件名不建议包含`index`，`style`和`script`字眼。**\r\n\r\n- **编辑文件**\r\n\r\n在主页的中间区域是文件编辑区Editor，中间展示的当前文件名，可调节编辑区内的字体大小，选择编译文件（`html/md`），点击`编译按钮`则会自动保存所有未保存的文件然后编译，点击`保存按钮`会保存当前文件。\r\n\r\n1.  `html`编辑\r\n\r\n`html`文件不需要标准模板，只需要书写主要结构即可\r\n\r\n```html\r\n<div>\r\n    <h1 style=\"color: #eb7806\">Welcome to YIDE</h1>\r\n    <h3 style=\"color: #eb7806\">by waiterxiaoyy</h3>\r\n</div>\r\n```\r\n\r\n2. `css`编辑\r\n\r\n`css`编辑如下\r\n\r\n```css\r\nbody {\r\n    color: #e56e0c;\r\n    margin: 0;\r\n    padding: 0;\r\n    background-color: #f4f4f4;\r\n}\r\n```\r\n\r\n3. `js`编辑\r\n\r\n`js`编辑如下\r\n\r\n```js\r\ndocument.addEventListener('DOMContentLoaded', function () { \r\n    console.log('JavaScript loaded for YIDE'); \r\n});\r\n```\r\n\r\n4. `Md`编辑\r\n\r\n`Md`文件编辑支持常规的基础操作，暂不支持复杂的样式如类图、流程图。\r\n\r\n- **文件编译**\r\n\r\n文件编译目前仅支持html和md文件编译，后续集成查看TODO List。\r\n\r\n1. html编译\r\n\r\nhtml会由后台自动解析出合格的代码，同时会解析`style.css`和`script.js`中的代码，由后台组合成一套完整的页面代码返回前台展示。\r\n\r\n如果需要**自定义样式文件和脚本文件**，需要在`html`文件中加入下面两行：\r\n\r\n```html\r\n<!-- 取消引入默认样式和脚本 -->\r\n// no style.css\r\n// no script.js\r\n```\r\n\r\n这两行代码需要严格按照上述格式写在需要自定义的`html`文件中，后台会识别并且取消加入默认的样式和脚本文件，用户自定义文件引入如下：\r\n\r\n```html\r\n<!-- 取消引入默认样式和脚本 -->\r\n// no style.css\r\n// no script.js\r\n\r\n<!-- 引入样式文件 -->\r\n<link rel=\"stylesheet\" href=\"/my.css\" />\r\n\r\n<!-- 引入脚本文件 -->\r\n<script type=\"text/script\" src=\"/my.js\" ></script>\r\n\r\n<div>\r\n    <h1 style=\"color: #eb7806\">Welcome to YIDE</h1>\r\n    <h3 style=\"color: #eb7806\">by waiterxiaoyy</h3>\r\n</div>\r\n```\r\n\r\n> 注意： 引入自定义文件需以斜杠`/`开头，否则将不能识别用户下的文件。\r\n\r\n当然，如果不需要引入文件，也可以直接在`html`文件的`<style></style>`和`<script></script>`中书写样式和脚本操作。\r\n\r\n2. `Md`编译\r\n\r\n`Md`编译结合的是掘金论坛主题，暂时不支持更换主题。\r\n\r\n- **下载文件**\r\n\r\n在文件索引区和编辑区都支持下载文件，点击`下载按钮`即可。\r\n\r\n- **上传文件**\r\n\r\n暂不支持上传\r\n\r\n- **文件重命名**\r\n\r\n暂不支持，后续更新\r\n\r\n## 安装/配置 :wrench:\r\n\r\n- **克隆项目**\r\n\r\n```sh\r\ngit clone git@github.com:waiterxiaoyy/YIDE.git\r\n```\r\n\r\n- **项目结构**\r\n\r\n```md\r\nYIDE\r\n├── YIDE-Egg-Server\r\n├── YIDE-React-Client\r\n```\r\n\r\n`YIDE-Egg-Server`是以`Egg.js`和`mysql`为技术栈的后端项目，`YIDE-React-Client`是以`React`为技术栈的前端项目，两个需同时启动才能正常使用\r\n\r\n- 全局安装`yarn`\r\n\r\n项目启动和部署需要`node`环境，请先提前安装好环境，项目中使用的`node`版本为`v18.18.1`，下面操作都基于此版本，如有不一致，请安装`nvm`切换到相应的node版本，安装`nvm`请自行查阅相关资料。\r\n\r\n```shell\r\nnpm install -g yarn\r\n```\r\n\r\n- **前端项目`YIDE-React-Client`配置/启动**\r\n\r\n1. 安装依赖\r\n\r\n```shell\r\ncd YIDE-React-Client\r\n\r\n// 安装依赖\r\nyarn\r\n\r\n```\r\n\r\n2. 配置端口\r\n\r\n在`vite.config.js`和`vite.config.ts`中配置项目端口和代理转发，默认的前端端口是`3001`，后端的端口是`8000`\r\n\r\n3. 启动项目\r\n\r\n```shell\r\n// 开发环境下启动项目\r\nyarn dev\r\n```\r\n\r\n- **后端项目`YIDE-Egg-Server`配置/启动**\r\n\r\n1. 安装和配置`MySQL`\r\n\r\n后端需要提前安装好`MySQL`，自行查阅资料安装，版本`8.0`以上。\r\n\r\n安装好后需要配置用户名和密码。\r\n\r\n2. 项目中配置`MySQL`\r\n\r\n在`YIDE-Egg-Server/config`的`config.default.js`中配置`mysql`项和`sequelize`项，密码和数据库改成你自己设置的。\r\n\r\n```js\r\nconfig.mysql = {\r\n    app: true,\r\n    agent: false,\r\n    client: {\r\n        host: 'localhost',\r\n        port: '3306',\r\n        user: 'root',\r\n        password: '',\r\n        database: 'yide'\r\n    }\r\n};\r\n\r\nconfig.sequelize = {\r\n    dialect: 'mysql',\r\n    host: 'localhost',\r\n    port: '3306',\r\n    user: 'root',\r\n    password: '',\r\n    database: 'yide',\r\n    define: {\r\n        timestamps: false,\r\n        freezeTableName: true\r\n    }\r\n};\r\n```\r\n\r\n3. 执行sql语句导入表和基础数据\r\n\r\n在项目目录下有`app.sql`文件，将里面的代码全部复制到`MySQL`控制台执行。\r\n\r\n4. 安装依赖\r\n\r\n在目录`YIDE-Egg-Server`下\r\n\r\n```shell\r\nyarn\r\n```\r\n\r\n5. 配置`oss`服务（可选）\r\n\r\n由于项目中用到了图床，使用的是`oss`云服务，所以需要配置`oss`，否则图床会无法使用。\r\n\r\n在`config.default.js`中配置`oss`项，`region`、`accessKeyId`、`accessKeySecret`、`bucket`是在`oss`申请时得到的，具体的`oss`服务开通请自行查阅资料。\r\n\r\n```js\r\nconfig.oss = {\r\n    client: {\r\n        region: '',\r\n        accessKeyId: '',\r\n        accessKeySecret: '',\r\n        bucket: ''\r\n    }\r\n};\r\n```\r\n\r\n5. 启动项目\r\n\r\n启动项目后，项目将在暴露在`8000`端口下\r\n\r\n```shell\r\nyarn dev\r\n```\r\n\r\n- 项目部署\r\n\r\n服务器使用`docker`进行管理项目，前端项目使用`nginx`部署，后端打包成镜像启动即可。\r\n\r\n部署疑问欢迎添加微信交流：`zhouyiyang0328`\r\n\r\n## 更新日志 📅\r\n\r\n查看 [更新日志] (https://github.com/waiterxiaoyy/yide/blob/master/CHANGELOG.md) 获取最新更新情况。\r\n\r\n## TODO List 📋\r\n\r\n如果想参与进来，欢迎提交PR成为项目贡献者，一起打造更加轻量和好用的在线IDE。\r\n\r\n- [ ] 页面布局优化：索引区缩进、响应式适配\r\n- [ ] 文件上传功能\r\n- [ ] 支持更多文件类型编译：vue、react等\r\n- [ ] 集成控制台\r\n- [ ] 文件重命名\r\n- [ ] 创建目录，目录管理，目录树\r\n- [ ] 代码分享\r\n\r\n## 贡献者 🤝\r\n\r\n欢迎贡献！请随时提交拉取请求。\r\n\r\n这个项目的存在感谢所有贡献者：\r\n\r\n<a href=\"https://github.com/waiterxiaoyy/YIDE/graphs/contributors\">\r\n  <img src=\"https://contrib.rocks/image?repo=waiterxiaoyy/YIDE\" />\r\n</a>\r\n\r\n## 许可证 📄\r\n\r\n此项目根据 MIT 许可证授权 - 有关详细信息，请参阅 [LICENSE](https://github.com/waiterxiaoyy/YIDE/blob/master/LICENSE) 文件。\r\n\r\n## 期待支持 💖\r\n\r\n如果你发现此项目对你有所帮助，请考虑在 [GitHub](https://github.com/waiterxiaoyy/YIDE) 上给它一个⭐️ !\r\n"
  },
  {
    "id": 12,
    "title": "最全Zod入门",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "前端",
    "tags": [
      "搬运",
      "TypeScript"
    ],
    "date": "2024-08-13",
    "abstract": "Zod 是一个以 TypeScript 为首的模式声明和验证库 ，弥补了 TypeScript 无法在运行时进行校验的问题",
    "fileName": "最全Zod入门.md",
    "filePath": "/2024/08/最全Zod入门.md",
    "mdContent": "\n> https://juejin.cn/post/7163548790787358756\n\nZod 是一个以 TypeScript 为首的模式声明和验证库 ，弥补了 TypeScript 无法在运行时进行校验的问题\n\nZod 既可以用在服务端也可以运行在客户端，以保障 [Web Apps 的类型安全](https://juejin.cn/post/7161619831844765710)\n\n接下来会用十个有趣的例子，带你快速入门 Zod，体会 Zod 的强大和便利 ～ 感谢 Matt Pocock 提供的 [示例](https://www.totaltypescript.com/tutorials/zod)\n\n\n本文仓库地址传送门 [👉](https://github.com/zidanDirk/zod-tutorial-cn)\n\n> 提示：本文 Star Wars API 有时会有超时情况，如遇超时则重试几遍哈\n\n# 01 - 使用 Zod 进行运行时类型校验\n\n## 问题\n\nTypeScript 是一个非常有用的类型工具，用于检查代码中变量的类型\n\n但是我们不能总是保证代码中变量的类型，比如这些变量来自 API 接口或者表单输入\n\nZod 库使得我们能够在 `运行时` 检查变量的类型，它对于我们的大部分项目都是有用的\n\n### 初探运行时检查\n\n看看这个 `toString` 函数：\n\n```javascript\nexport const toString = (num: unknow) => {\n    return String(num)\n}\n```\n我们将 num 的入参设置为 unknow\n\n这意味着我们可以在编码过程中给 `toString` 函数传递任何类型的参数，包括 object 类型或者 undefined :\n```javascript\ntoString('blah')\ntoString(undefined)\ntoString({name: 'Matt'})\n```\n到目前为止还是没有报错的，但我们想要在 `运行时` 防止这样的事情发生\n\n如果我们给 `toString` 传入一个字符串，我们想要抛出一个错误，并提示预期传入一个数字但是接收到一个字符串\n\n```javascript\nit(\"当入参不是数字的时候，需要抛出一个错误\", () => {\n  expect(() => toString(\"123\")).toThrowError(\n    \"Expected number, received string\",\n  );\n});\n```\n如果我们传入一个数字，`toString` 是能够正常运行的\n\n```javascript\nit(\"当入参是数字的时候，需要返回一个字符串\", () => {\n    expect(toString(1)).toBeTypeOf(\"string\");\n});\n```\n\n## 解决方案\n\n### 创建一个 `numberParser`\n\n各种 Parser 是 Zod 最基础的功能之一\n\n我们通过 `z.number()` 来创建一个 `numberParser`\n\n它创建了 `z.ZodNumber` 对象，这个对象提供了一些有用的方法\n\n```javascript\nconst numberParser = z.number();\n```\n如果数据不是数字类型的话，那么将这些数据传进 `numberParser.parse()` 后会报错\n\n这就意味着，所有传进  `numberParser.parse()` 的变量都会被转成数字，然后我们的测试才能够通过。\n\n添加 `numberParser` , 更新 `toString` 方法\n\n```javascript\n\nconst numberParser = z.number();\n\nexport const toString = (num: unknown) => {\n  const parsed = numberParser.parse(num);\n  return String(parsed);\n};\n\n```\n\n### 尝试不同的类型\n\nZod 也允许其他的类型检验\n\n比如，如果我们要接收的参数不是数字而是一个 boolean 值，那么我们可以把 `numberParser` 修改成 `z.boolean()`\n\n当然，如果我们只修改了这个，那么我们原有的测试用例就会报错哦\n\n\nZod 的这种技术为我们提供了坚实的基础。 随着我们的深入使用，你会发现 Zod 模仿了很多你在 TypeScript 中习惯的东西。\n\n可以在 [这里](https://zod.dev/?id=primitives) 查看 Zod 完整的基础类型\n\n\n\n# 02 - 使用 Object Schema 对未知的 API 进行校验\n\n## 问题\n\nZod 经常被用于校验未知的 API 返回内容\n\n在下面这个例子中，我们从 Star Wars API 中获取一个人物的信息\n\n```javascript\nexport const fetchStarWarsPersonName = async (id: string) => {\n  const data = await fetch(\"<https://swapi.dev/api/people/>\" + id).then((res) =>\n    res.json(),\n  );\n\n  const parsedData = PersonResult.parse(data);\n\n  return parsedData.name;\n};\n```\n\n注意到现在 `PersonResult.parser()` 处理的数据是从 fetch 请求来的\n\n`PersonResult` 变量是由 `z.unknown()` 创建的，这告诉我们数据是被认为是 `unknown` 类型因为我们不知道这些数据里面包含有什么\n\n```javascript\nconst PersonResult = z.unknown();\n```\n\n### 运行测试\n\n如果我们是用 `console.log(data)` 打印出 fetch 函数的返回值，我们可以看到这个 API 返回的内容有很多，不仅仅有人物的 name ，还有其他的比如 eye_color，skin_color 等等一些我们不感兴趣的内容\n\n\n接下来我们需要修复这个 `PersonResult` 的 unknown 类型\n\n## 解决方案\n\n### 使用 `z.object` 来修改 PersonResult\n\n首先，我们需要将 `PersonResult` 修改为 `z.object`\n\n它允许我们使用 key 和类型来定义这些 object\n\n在这个例子中，我们需要定义 `name` 成为字符串\n\n```javascript\nconst PersonResult = z.object({\n  name: z.string(),\n});\n```\n\n注意到这里有点像我们在 TypeScript 中创建 interface\n\n```javascript\ninterface PersonResult {\n    name: string;\n}\n```\n\n### 检查我们的工作\n\n在 `fetchStarWarsPersonName` 中，我们的 `parsedData` 现在已经被赋予了正确的类型，并且拥有了一个 Zod 能识别的结构\n\n重新调用 API 我们依然能够看到返回的数据里面有很多我们不感兴趣的信息\n\n现在如果我们用 `console.log` 打印 `parsedData`，我们可以看到 Zod 已经帮我们过滤掉我们不感兴趣的 Key 了，只给我们 `name` 字段\n\n### 更多\n\n任何额外加入 `PersonResult` 的 key 都会被添加到 `parsedData` 中\n\n能够显式的指明数据中每个 key 的类型是 Zod 中一个非常有用的功能\n\n\n# 03 - 创建自定义类型数组\n\n## 问题\n\n在这个例子中，我们依然使用 Star Wars API，但是这一次我们要拿到 `所有` 人物的数据\n\n一开始的部分跟我们之前看到的非常类似，`StarWarsPeopleResults` 变量会被设置为 `z.unknown()`\n\n```javascript\nconst StarWarsPeopleResults = z.unknown();\n\nexport const fetchStarWarsPeople = async () => {\n  const data = await fetch(\"https://swapi.dev/api/people/\").then((res) =>\n    res.json(),\n  );\n\n  const parsedData = StarWarsPeopleResults.parse(data);\n\n  return parsedData.results;\n};\n```\n\n跟之前类似，添加 `console.log(data)` 到 fetch 函数中，我们可以看到数组中有很多数据即使我们只对数组中的 name 字段感兴趣\n\n如果这是一个 TypeScript 的 interface，它可能是需要写成这样\n```javascript\ninterface Results {\n  results: {\n    name: string;\n  }[];\n}\n\n```\n### 作业\n\n通过使用 object schema 更新 `StarWarsPeopleResults` ，来表示一个 `StarWarsPerson` 对象的数组\n\n可以参考[这里](https://zod.dev/?id=arrays)的文档来获得帮助\n\n## 解决方案\n\n正确的解法就是创建一个对象来饮用其他的对象。在这个例子中，`StarWarsPeopleResults` 将是一个包含 `results` 属性的 `z.object`\n\n关于 `results`，我们使用 `z.array` 并提供 `StarWarsPerson` 作为参数。我们也不用重复写 `name: z.string()` 这部分了\n\n这个是之前的代码\n```javascript\nconst StarWarsPeopleResults = z.unknown()\n```\n\n修改之后\n```javascript\nconst StarWarsPeopleResults = z.object({\n  results: z.array(StarWarsPerson),\n});\n```\n\n如果我们 `console.log` 这个 `parsedData` ，我们可以获得期望的数据\n\n像上面这样声明数组的 object 是 `z.array()` 最常用的的功能一直，特别是当这个 object 已经创建好了。\n\n\n# 04 - 提取对象类型\n\n## 问题\n\n现在我们使用 console 函数将 StarWarsPeopleResults 打印到控制台\n```javascript\nconst logStarWarsPeopleResults = (data: unknown) => {\n  data.results.map((person) => {\n    console.log(person.name);\n  });\n};\n```\n再一次，`data` 的类型是 `unknown`\n\n为了修复，可能会尝试使用下面这样的做法：\n```javascript\nconst logStarWarsPeopleResults = (data: typeof StarWarsPeopleResults)\n```\n然而这样还是会有问题，因为这个类型代表的是 Zod 对象的类型而不是 `StarWarsPeopleResults` 类型\n\n\n### 作业\n更新 `logStarWarsPeopleResults` 函数去提取对象类型\n\n\n## 解决方案\n\n### 更新这个打印函数\n使用 `z.infer` 并且传递 `typeof StarWarsPeopleResults` 来修复问题\n\n```javascript\nconst logStarWarsPeopleResults = (\n  data: z.infer<typeof StarWarsPeopleResults>,\n) => {\n  ...\n```\n现在当我们在 VSCode 中把鼠标 hover 到这个变量上，我们可以看到它的类型是一个包含了 results 的 object\n\n当我们更新了 `StarWarsPerson` 这个 schema，函数的 data 也会同步更新\n\n这是一个很棒的方式，它做到使用 Zod 在运行时进行类型检查，同时也可以在构建时获取数据的类型\n\n\n### 一个替代方案\n\n当然，我们也可以把 StarWarsPeopleResultsType 保存为一个类型并将它从文件中导出\n```javascript\nexport type StarWarsPeopleResultsType = z.infer<typeof StarWarsPeopleResults>;\n```\n`logStarWarsPeopleResults` 函数则会被更新成这样\n```javascript\nconst logStarWarsPeopleResults = (data: StarWarsPeopleResultsType) => {\n  data.results.map((person) => {\n    console.log(person.name);\n  });\n};\n```\n\n这样别的文件也可以获取到 `StarWarsPeopleResults` 类型，如果需要的话\n\n# 05 - 让 schema 变成可选的\n\n## 问题\n\nZod 在前端项目中也同样是有用的\n\n在这个例子中，我们有一个函数叫做 `validateFormInput`\n\n这里 `values` 的类型是 `unknown`，这样做是安全的因为我们不是特别了解这个 form 表单的字段。在这个例子中，我们收集了 `name` 和 `phoneNumber` 作为 `Form` 对象的 schema\n\n```javascript\nconst Form = z.object({\n  name: z.string(),\n  phoneNumber: z.string(),\n});\n\nexport const validateFormInput = (values: unknown) => {\n  const parsedData = Form.parse(values);\n\n  return parsedData;\n};\n```\n目前的状况来说，我们的测试会报错如果 phoneNumber 字段没有被提交\n\n### 作业\n因为 phoneNumber 不总是必要的，需要想一个方案，不管 phoneNumber 是否有提交，我们的测试用例都可以通过\n\n## 解决方案\n\n在这种情况下，解决方案非常直观！\n在 `phoneNumber` schema 后面添加 `.optional()`，我们的测试将会通过\n\n```javascript\nconst Form = z.object({ name: z.string(), phoneNumber: z.string().optional(), });\n```\n\n我们说的是， `name` 字段是一个必填的字符串，`phoneNumber` 可能是一个字符串或者 undefined\n\n我们不需要再做更多什么额外的事情，让这个 schema 变成可选的就是一个非常不错的方案\n\n# 06 - 在 Zod 中设置默认值\n\n## 问题\n\n我们的下一个例子跟之前的很像：一个支持可选值的 form 表单输入校验器\n\n这一次，`Form` 有一个 `repoName` 字段和一个可选数组字段 `keywords`\n\n```javascript\nconst Form = z.object({\n  repoName: z.string(),\n  keywords: z.array(z.string()).optional(),\n});\n```\n为了使实际表单更容易，我们希望对其进行设置，以便不必传入字符串数组。\n\n### 作业\n修改 `Form` 使得当 `keywords` 字段为空的时候，会有一个默认值（空数组）\n\n\n## 解决方案\n\nZod 的 [default schema 函数](https://zod.dev/?id=default)，允许当某个字段没有传参时提供一个默认值\n\n在这个例子中，我们将会使用 `.default([])` 设置一个空数组\n\n修改前\n\n```javascript\nkeywords: z.array(z.string()).optional()\n```\n\n修改后\n\n```javascript\nkeywords: z.array(z.string()).default([])\n```\n\n因为我们添加了默认值，所以我们不需要再使用 `optional()` ，optional 已经是被包含在其中了。\n\n修改之后，我们的测试可以通过了\n\n### 输入不同于输出\n\n在 Zod 中，我们已经做到了输入与输出不同的地步。\n\n也就是说，我们可以做到基于输入生成类型也可以基于输出生成类型\n\n比如，我们创建 `FormInput` 和 `FormOutput` 类型\n\n```javascript\ntype FormInput = z.infer<typeof Form>\ntype FormOutput = z.infer<typeof Form>\n```\n\n### 介绍 `z.input`\n\n就像上面写的，输入不完全正确，因为当我们在给 `validateFormInput` 传参数时，我们没有必要一定要传递 `keywords` 字段\n\n我们可以使用 `z.input` 来替代 `z.infer` 来修改我们的 FormInput\n\n如果验证函数的输入和输出之间存在差异，则为我们提供了另外一种生成的类型的方法。\n\n```javascript\ntype FormInput = z.input<typeof Form>\n```\n\n# 07 - 明确允许的类型\n\n## 问题\n\n在这个例子中，我们将再一次校验表单\n\n这一次，Form 表单有一个 `privacyLevel` 字段，这个字段只允许 `private` 或者 `public` 这两个类型\n```javascript\nconst Form = z.object({\n  repoName: z.string(),\n  privacyLevel: z.string(),\n});\n```\n如果是在 TypeScript 中，我们会这么写\n```javascript\ntype PrivacyLevel = 'private' | 'public'\n```\n\n当然，我们可以在这里使用 boolean 类型，但如果将来我们还需要往 `PrivacyLevel` 中添加新的类型，那就不太合适了。在这里，使用联合类型或者枚举类型是更加安全的做法。\n\n\n### 作业\n\n第一个测试报错了，因为我们的 `validateFormInput` 函数有除了 \"private\" 或 \"public\" 以外的其他值传入 `PrivacyLevel` 字段\n\n```javascript\nit(\"如果传入一个非法的 privacyLevel 值，则需要报错\", async () => {\n  expect(() =>\n    validateFormInput({\n      repoName: \"mattpocock\",\n      privacyLevel: \"something-not-allowed\",\n    }),\n  ).toThrowError();\n});\n```\n你的任务是要找到一个 Zod 的 API 来允许我们明确入参的字符串类型，以此来让测试能够顺利通过。\n\n\n## 解决方案\n\n### 联合 (Unions) & 字面量 (Literals)\n\n第一个解决方案，我们将使用 [Zod 的 联合函数](https://zod.dev/?id=unions)，再传一个包含 \"private\" 和 \"public\" [字面量](https://zod.dev/?id=literals) 的数组\n\n```javascript\nconst Form = z.object({\n  repoName: z.string(),\n  privacyLevel: z.union([z.literal(\"private\"), z.literal(\"public\")]),\n});\n```\n字面量可以用来表示：数字，字符串，布尔类型；不能用来表示对象类型\n\n我们能使用 `z.infer` 检查我们 `Form` 的类型\n\n```javascript\ntype FormType = z.infer<typeof Form>\n```\n在 VS Code 中如果你把鼠标移到 FormType 上，我们可以看到 `privacyLevel` 有两个可选值：\"private\" 和 \"public\"\n\n### 可认为是更加简洁的方案：枚举\n\n通过 `z.enum` 使用 [Zod 枚举](https://zod.dev/?id=zod-enums)，也可以做到相同的事情，如下：\n```javascript\nconst Form = z.object({\n  repoName: z.string(),\n  privacyLevel: z.enum([\"private\", \"public\"]),\n});\n```\n\n我们可以通过语法糖的方式来解析字面量，而不是使用 `z.literal`\n\n这个方式不会产生 TypeScript 中的枚举类型，比如\n```javascript\nenum PrivacyLevcel {\n    private,\n    public\n}\n```\n一个新的联合类型会被创建\n\n同样，我们通过把鼠标移到类型上面，我们可以看到一个新的包含 \"private\" 和 \"public\" 的联合类型\n\n# 08 - 复杂的 schema 校验\n\n## 问题\n\n到目前为止，我们的表单校验器函数已经可以检查各种值了\n\n表单拥有 name，email 字段还有可选的 phoneNumber 和 website 字段\n\n然而，我们现在想对一些值做强约束\n\n需要限制用户不能输入不合法的 URL 以及电话号码\n\n### 作业\n\n你的任务是寻找 Zod 的 API 来为表单类型做校验\n\n电话号码需要是合适的字符，邮箱地址和 URL 也需要正确的格式\n\n\n## 解决方案\n\nZod 文档的[字符串章节](https://zod.dev/?id=strings)包含了一些校验的例子，这些可以帮助我们顺利通过测试\n\n现在我们的 Form 表单 schema 会是写成这样\n```javascript\nconst Form = z.object({\n  name: z.string().min(1),\n  phoneNumber: z.string().min(5).max(20).optional(),\n  email: z.string().email(),\n  website: z.string().url().optional(),\n});\n```\n\n`name` 字段加上了 `min(1)`，因为我们不能给它传空字符串\n\n`phoneNumber` 限制了字符串长度是 5 至 20，同时它是可选的\n\nZod 有内建的邮箱和 url 校验器，我们可以不需要自己手动编写这些规则\n\n可以注意到，我们不能这样写 `.optional().min()`， 因为optional 类型没有 `min` 属性。这意味着我们需要将 `.optional()` 写在每个校验器后面\n\n还有很多其他的校验器规则，我们可以在 Zod 文档中找到\n\n# 09 - 通过组合 schema 来减少重复\n\n## 问题\n\n现在，我们来做一些不一样的事情\n\n在这个例子中，我们需要寻找方案来重构项目，以减少重复代码\n\n这里我们有这些 schema，包括：`User`, `Post` 和 `Comment`\n\n```javascript\nconst User = z.object({\n  id: z.string().uuid(),\n  name: z.string(),\n});\n\nconst Post = z.object({\n  id: z.string().uuid(),\n  title: z.string(),\n  body: z.string(),\n});\n\nconst Comment = z.object({\n  id: z.string().uuid(),\n  text: z.string(),\n});\n```\n我们看到, id 在每个 schema 都出现了\n\nZod 提供了许多方案可以将 object 对象组织到不同的类型中，使得我们可以让我们的代码更加符合 [`DRY`](https://www.ruanyifeng.com/blog/2013/01/abstraction_principles.html) 原则\n\n\n### 作业\n\n你的挑战是，需要使用 Zod 进行代码重构，来减少 id 的重复编写\n\n#### 关于测试用例语法\n\n你不用担心这个测试用例的 TypeScript 语法，这里有个快速的解释：\n\n```javascript\nExpect<\n  Equal<z.infer<typeof Comment>, { id: string; text: string }>\n>\n```\n在上面的代码中，`Equal` 是确认 `z.infer<typeof Comment>` 和 `{id: string; text: string}` 是相同的类型\n\n如果你删除掉 `Comment` 的 `id` 字段，那么在 VS Code 中可以看到 `Expect` 会有一个报错，因为这个比较不成立了\n\n## 解决方案\n\n我们有很多方法可以重构这段代码\n\n作为参考，这是我们开始的内容：\n```javascript\nconst User = z.object({\n  id: z.string().uuid(),\n  name: z.string(),\n});\n\nconst Post = z.object({\n  id: z.string().uuid(),\n  title: z.string(),\n  body: z.string(),\n});\n\nconst Comment = z.object({\n  id: z.string().uuid(),\n  text: z.string(),\n});\n```\n\n\n### 简单的方案\n最简单的方案是抽取 `id` 字段保存成一个单独的类型，然后每一个 `z.object` 都可以引用它\n\n```javascript\nconst Id = z.string().uuid();\n\nconst User = z.object({\n  id: Id,\n  name: z.string(),\n});\n\nconst Post = z.object({\n  id: Id,\n  title: z.string(),\n  body: z.string(),\n});\n\nconst Comment = z.object({\n  id: Id,\n  text: z.string(),\n});\n```\n这个方案挺不错，但是 `id: ID` 这段仍然是一直在重复。所有的测试都可以通过，所以也还行\n\n### 使用扩展（Extend）方法\n另一个方案是创建一个叫做 `ObjectWithId` 的基础对象，这个对象包含 `id` 字段\n\n```javascript\nconst ObjectWithId = z.object({\n  id: z.string().uuid(),\n});\n```\n我们可以使用[扩展方法](https://zod.dev/?id=extend)去创建一个新的 schema 来添加基础对象\n\n```javascript\nconst ObjectWithId = z.object({\n  id: z.string().uuid(),\n});\n\nconst User = ObjectWithId.extend({\n  name: z.string(),\n});\n\nconst Post = ObjectWithId.extend({\n  title: z.string(),\n  body: z.string(),\n});\n\nconst Comment = ObjectWithId.extend({\n  text: z.string(),\n});\n```\n请注意，`.extend()` 会覆盖字段\n\n\n### 使用合并（Merge）方法\n\n跟上面的方案类似，我们可以使用[合并方法](https://zod.dev/?id=merge)来扩展基础对象 `ObjectWithId` :\n\n```javascript\nconst User = ObjectWithId.merge(\n  z.object({\n    name: z.string(),\n  }),\n);\n```\n\n使用 `.merge()` 会比 `.extend()` 更加冗长。我们必须传一个包含 `z.string()` 的 `z.object()` 对象\n\n合并通常是用于联合两个不同的类型，而不是仅仅用来扩展单个类型\n\n这些是在 Zod 中将对象组合在一起的几种不同方式，以减少代码重复量，使代码更加符合 DRY，并使项目更易于维护！\n\n\n# 10 - 通过 schema 转换数据\n\n## 问题\n\nZod 的另一个十分有用的功能是控制从 API 接口响应的数据\n\n现在我们翻回去看看 Star Wars 的例子\n\n想起我们创建了 `StarWarsPeopleResults` , 其中 `results` 字段是一个包含 `StarWarsPerson` schema 的数组\n\n当我们从 API 获取 `StarWarsPerson` 的 `name`，我们获取的是他们的全称\n\n现在我们要做的是为 `StarWarsPerson` 添加转换\n\n\n### 作业\n\n你的任务是为这个基础的 `StarWarsPerson` 对象添加一个转换，将 `name` 字段按照空格分割成数组，并将数组保存到 `nameAsArray` 字段中\n\n\n测试用例大概是这样的：\n\n```javascript\nit(\"需要解析 name 和 nameAsArray 字段\", async () => {\n  expect((await fetchStarWarsPeople())[0]).toEqual({\n    name: \"Luke Skywalker\",\n    nameAsArray: [\"Luke\", \"Skywalker\"],\n  });\n});\n```\n\n## 解决方案\n\n提醒一下，这是 `StarWarsPerson` 在转换前的样子：\n\n```javascript\nconst StarWarsPerson = z.object({\n  name: z.string()\n});\n```\n\n### 添加一个转换 (Transformation)\n\n当我们在 `.object()` 中的 `name` 字段时，我们可以获取 `person` 参数，然后转换它并添加到一个新的属性中\n\n```javascript\nconst StarWarsPerson = z\n  .object({\n    name: z.string(),\n  })\n  .transform((person) => ({\n    ...person,\n    nameAsArray: person.name.split(\" \"),\n  }));\n```\n\n在 `.transform()` 内部，`person` 是上面包含 `name` 的对象。\n\n这也是我们添加满足测试的 `nameAsArray` 属性的地方。\n\n所有这些都发生在 `StarWarsPerson` 这个作用域中，而不是在 `fetch` 函数内部或其他地方。\n\n### 另一个例子\n\nZod 的转换 API 适用于它的任何原始类型。\n\n比如，我们可以转换 `name` 在 `z.object` 的内部\n\n```javascript\nconst StarWarsPerson = z\n  .object({\n    name: z.string().transform((name) => `Awesome ${name}`)\n  }),\n  ...\n```\n\n现在我们拥有一个 `name` 字段包含 `Awesome Luke Skywalker` 和一个 `nameAsArray` 字段包含 `['Awesome', 'Luke', 'Skywalker']`\n\n转换过程在最底层起作用，可以组合，并且非常有用\n\n\n# 总结\n以上就是教程的所有内容，后续还会一直补充更多的实用例子，建议收藏 ～ 也欢迎各位小伙伴看完之后能跟我一起讨论有关于 Zod 的相关问题，提出宝贵意见 ～ \n\n\n### 引用文献\n- https://www.totaltypescript.com/tutorials/zod\n- https://zod.dev/\n"
  },
  {
    "id": 13,
    "title": "认识Blob对象：没有后端，前端如何实现文件下载功能",
    "author": "WaiterXiaoYY",
    "avatar": "http://yiyang-site.oss-cn-guangzhou.aliyuncs.com/site/images/Snipaste_2024-08-12_23-04-40.png",
    "category": "前端",
    "tags": [
      "Js",
      "React",
      "TypeScript"
    ],
    "date": "2024-08-12",
    "abstract": "在开发博客编辑的时候，我要实现下载功能，但是由于博客是静态页面，所以文件书写和下载都只能前端完成，最直接和最有效的做法就是`Blob`对象。",
    "fileName": "没有后端前端如何实现文件下载功能.md",
    "filePath": "/2024/08/没有后端前端如何实现文件下载功能.md",
    "mdContent": "\n在开发博客编辑的时候，我要实现下载功能，但是由于博客是静态页面，所以文件书写和下载都只能前端完成\n\n最直接和最有效的做法就是`Blob`对象。\n\n## 实现前端下载\n\n先看代码是怎么做的，我写了一个下载文件的函数，用于提取文件内容封装成`Blob`对象：\n\n```js\nconst handleDownload = () => {\n    const blob = new Blob([value], { type: 'text/markdown' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    \n    a.href = url;\n    a.download = `${form.getFieldValue('title')}.md`;\n    document.body.appendChild(a);\n    a.click();\n    \n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n};\n```\n\n`value`值就是文件的内容，创建`Blob`对象，通过`createObjectURL`方法构建`url`\n\n然后就是创建一个`<a>`标签，给标签绑定上`url`,之后点击`<a>`标签即可实现文件下载\n\n需要在下载完成后移除`<a>`标签并且释放`Blob`对象的`URL`。\n\n上面就是一套完整的无需后端参与，仅前端即可实现文件下载的功能，最核心的地方就是`Blob`，所以接下来，我们探究一下它。\n\n## Blob 对象\n\n![Snipaste_2024-08-12_23-04-40.png](http://yiyang-site.oss-cn-guangzhou.aliyuncs.com/site/images/Snipaste_2024-08-12_23-04-40.png)\n\n通过这张图，大概能了解清楚各个对象之间的关系。\n\n> MDN解释\n\n`Blob`全称（Binary Large Object），从名字里面就知道，它是一个存储或者携带二进制数据的对象，其表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 `ReadableStream` 来用于数据操作。\n\n`Blob` 表示的不一定是 `JavaScript` 原生格式的数据。`File` 接口基于 `Blob`，继承了 `blob` 的功能并将其扩展以支持用户系统上的文件。\n\n### 创建 Blob\n\n\n"
  },
  {
    "id": 14,
    "title": "由一道bilibili面试题看Promise异步执行机制",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "前端",
    "tags": [
      "记录",
      "Promise"
    ],
    "date": "2024-08-12",
    "abstract": "Promise异步执行机制",
    "fileName": "由一道bilibili面试题看Promise异步执行机制.md",
    "filePath": "/2024/08/由一道bilibili面试题看Promise异步执行机制.md",
    "mdContent": "\r\n```js\r\nvar date = new Date() \r\n\r\nconsole.log(1, new Date() - date) \r\n\r\nsetTimeout(() => {\r\n    console.log(2, new Date() - date)\r\n}, 500) \r\n\r\nPromise.resolve().then(console.log(3, new Date() - date)) \r\n\r\nwhile(new Date() - date < 1000) {} \r\n\r\nconsole.log(4, new Date() - date)\r\n```\r\n\r\n求上面的输出顺序和输出值，为什么？\r\n\r\n**答案：**\r\n\r\n```js\r\n1 0\r\n3 1\r\n4 1000\r\n2 1000\r\n```\r\n\r\n其中，关于时间差结果可能因为计算机性能造成的微小差异，可忽略不计\r\n\r\n你答对了吗？下面我们由浅入深探索本题\r\n\r\n## 由浅入深探索 Promise 异步执行\r\n\r\n首先，看一下 `event loop` 的基础必备内容\r\n\r\n `event loop` 执行顺序：\r\n\r\n- 首先执行 `script` 宏任务\r\n- 执行同步任务，遇见微任务进入微任务队列，遇见宏任务进入宏任务队列\r\n- 当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完\r\n- 执行浏览器 UI 线程的渲染工作\r\n- 检查是否有`Web Worker`任务，有则执行\r\n- 执行下一个宏任务，回到第二步，依此循环，直到宏任务和微任务队列都为空\r\n\r\n**微任务包括：**`MutationObserver`、`Promise.then()或catch()`、`Promise为基础开发的其它技术，比如fetch API`、`V8`的垃圾回收过程、`Node独有的process.nextTick` 、 `Object.observe`（已废弃；`Proxy` 对象替代）\r\n\r\n**宏任务包括**：`script` 、`setTimeout`、`setInterval` 、`setImmediate` 、`I/O` 、`UI rendering` 、 `postMessage` 、 `MessageChannel` \r\n\r\n**注意：** 下面的题目都是执行在浏览器环境下\r\n\r\n遇到不好理解的，可结合 [`promise` 源码](https://github.com/sisterAn/blog/issues/13) 进行理解，就很简单了\r\n\r\n### 1. 同步 + Promise\r\n\r\n#### 题目一：\r\n\r\n```js\r\nvar promise = new Promise((resolve, reject) => {\r\n    console.log(1)\r\n    resolve()\r\n    console.log(2)\r\n})\r\npromise.then(()=>{\r\n    console.log(3)\r\n})\r\nconsole.log(4)\r\n// 1\r\n// 2\r\n// 4\r\n// 3\r\n```\r\n\r\n**解析：**\r\n\r\n- 首先明确， `Promise` 构造函数是同步执行的， `then` 方法是异步执行的\r\n- 开始 `new Promise` ，执行构造函数同步代码，输出 `1`\r\n- 再 `resolve()`， 将 `promise` 的状态改为了 `resolved` ，并且将 `resolve`  值保存下来，此处没有传值\r\n- 执行构造函数同步代码，输出 `2`\r\n- 跳出`promise`，往下执行，碰到 `promise.then` 这个微任务，将其加入微任务队列\r\n- 执行同步代码，输出 `4`\r\n- 此时宏任务执行完毕，开始检查微任务队列，执行 `promise.then` 微任务，输出 `3`\r\n\r\n#### 题目二：\r\n\r\n```js\r\nvar promise = new Promise((resolve, reject) => {\r\n    console.log(1)\r\n})\r\npromise.then(()=>{\r\n    console.log(2)\r\n})\r\nconsole.log(3)\r\n// 1\r\n// 3\r\n```\r\n\r\n**解析：**\r\n\r\n- 开始 `new Promise` ，执行构造函数同步代码，输出 `1`\r\n- 再 `promise.then` ，因为 `promise`中并没有`resolve` ，所以 `then` 方法不会执行\r\n- 执行同步代码，输出 `3`\r\n\r\n#### 题目三：\r\n\r\n```js\r\nvar promise = new Promise((resolve, reject) => {\r\n    console.log(1)\r\n})\r\npromise.then(console.log(2))\r\nconsole.log(3)\r\n// 1\r\n// 2\r\n// 3\r\n```\r\n\r\n**解析：**\r\n\r\n- 首先明确， `.then` 或者 `.catch` 的参数期望是函数，传入非函数则会发生值透传（ `value => value` ）\r\n- 开始 `new Promise` ，执行构造函数同步代码，输出 `1`\r\n- 然后 `then()` 的参数是一个 `console.log(2)`  （注意：并不是一个函数），是立即执行的，输出 `2` \r\n- 执行同步代码，输出 `3`\r\n\r\n#### 题目四：\r\n\r\n```js\r\nPromise.resolve(1)\r\n  .then(2)\r\n  .then(Promise.resolve(3))\r\n  .then(console.log)\r\n// 1\r\n```\r\n\r\n**解析：**\r\n\r\n- `then(2)` 、 `then(Promise.resolve(3))` 发生了值穿透，直接执行最后一个 `then` ，输出 `1`\r\n\r\n#### 题目五：\r\n\r\n```js\r\nvar promise = new Promise((resolve, reject) => {\r\n    console.log(1)\r\n    resolve()\r\n    reject()\r\n})\r\npromise.then(()=>{\r\n    console.log(2)\r\n}).catch(()=>{\r\n    console.log(3)\r\n})\r\nconsole.log(4)\r\n// 1\r\n// 4\r\n// 2\r\n```\r\n\r\n**解析：**\r\n\r\n- 开始 `new Promise` ，执行构造函数同步代码，输出 `1`\r\n- 再 `resolve()`， 将 `promise` 的状态改为了 `resolved` ，并且将 `resolve`  值保存下来，此处没有传值\r\n- 再 `reject()` ，此时 `promise` 的状态已经改为了 `resolved` ，不能再重新翻转（状态转变只能是pending —> resolved 或者 pending —> rejected，状态转变不可逆）\r\n- 跳出`promise`，往下执行，碰到 `promise.then` 这个微任务，将其加入微任务队列\r\n- 往下执行，碰到 `promise.catch` 这个微任务，此时 `promise` 的状态为 `resolved` （非 `rejected` ），忽略 `catch` 方法\r\n- 执行同步代码，输出 `4`\r\n- 此时宏任务执行完毕，开始检查微任务队列，执行 `promise.then` 微任务，输出 `2`\r\n\r\n#### 题目六：\r\n\r\n```js\r\nPromise.resolve(1)\r\n  .then(res => {\r\n    console.log(res);\r\n    return 2;\r\n  })\r\n  .catch(err => {\r\n    return 3;\r\n  })\r\n  .then(res => {\r\n    console.log(res);\r\n  });\r\n// 1\r\n// 2\r\n```\r\n\r\n**解析：**\r\n\r\n-  首先 `resolve(1)`， 状态改为了 `resolved` ，并且将 `resolve`  值保存下来\r\n-  执行 `console.log(res)` 输出 `1`\r\n-  返回 `return 2` 实际上是包装成了 `resolve(2)` \r\n-  状态为 `resolved` ， `catch` 方法被忽略\r\n-  最后 `then` ，输出 `2`\r\n\r\n### 2. 同步 + Promise + setTimeout\r\n\r\n#### 题目一：\r\n\r\n```js\r\nsetTimeout(() => {\r\n  console.log(1)\r\n})\r\nPromise.resolve().then(() => {\r\n  console.log(2)\r\n})\r\nconsole.log(3)\r\n// 3\r\n// 2\r\n// 1\r\n```\r\n\r\n**解析：**\r\n\r\n- 首先 `setTimout` 被放入宏任务队列\r\n- 再 `Promise.resolve().then` ， `then` 方法被放入微任务队列\r\n- 执行同步代码，输出 `3`\r\n- 此时宏任务执行完毕，开始检查微任务队列，执行 `then` 微任务，输出 `2`\r\n- 微任务队列执行完毕，检查执行一个宏任务\r\n- 发现 `setTimeout` 宏任务，执行输出 `1`\r\n\r\n#### 题目二：\r\n\r\n```js\r\nvar promise = new Promise((resolve, reject) => {\r\n  console.log(1)\r\n  setTimeout(() => {\r\n    console.log(2)\r\n    resolve()\r\n  }, 1000)\r\n})\r\n\r\npromise.then(() => {\r\n  console.log(3)\r\n})\r\npromise.then(() => {\r\n  console.log(4)\r\n})\r\nconsole.log(5)\r\n// 1\r\n// 5\r\n// 2\r\n// 3\r\n// 4\r\n```\r\n\r\n**解析：**\r\n\r\n- 首先明确，当遇到 `promise.then` 时，如果当前的 `Promise` 还处于 `pending` 状态，我们并不能确定调用 `resolved` 还是 `rejected` ，只有等待 `promise` 的状态确定后，再做处理，所以我们需要把我们的两种情况的处理逻辑做成 `callback` 放入 `promise` 的回调数组内，当 `promise` 状态翻转为 `resolved` 时，才将之前的 `promise.then` 推入微任务队列\r\n- 开始， `Promise` 构造函数同步执行，输出 `1` ，执行 `setTimeout`\r\n- 将 `setTimeout` 加入到宏任务队列中\r\n- 然后，第一个 `promise.then` 放入 `promise` 的回调数组内\r\n- 第二个 `promise.then` 放入 `promise` 的回调数组内\r\n- 执行同步代码，输出 `5`\r\n- 检查微任务队列，为空\r\n- 检查宏任务队列，执行 `setTimeout` 宏任务，输入 `2` ，执行 `resolve` ， `promise` 状态翻转为 `resolved` ，将之前的 `promise.then` 推入微任务队列\r\n- `setTimeout` 宏任务出队，检查微任务队列\r\n- 执行第一个微任务，输出 `3`\r\n- 执行第二个微任务，输出 `4`\r\n\r\n### 回到开头\r\n\r\n现在看，本题就很简单了\r\n\r\n```js\r\nvar date = new Date() \r\n\r\nconsole.log(1, new Date() - date) \r\n\r\nsetTimeout(() => {\r\n    console.log(2, new Date() - date)\r\n}, 500) \r\n\r\nPromise.resolve().then(console.log(3, new Date() - date)) \r\n\r\nwhile(new Date() - date < 1000) {} \r\n\r\nconsole.log(4, new Date() - date)\r\n```\r\n\r\n**解析：**\r\n\r\n- 首先执行同步代码，输出 `1 0`\r\n- 遇到 `setTimeout` ，定时 `500ms` 后执行，此时，将 `setTimeout` 交给异步线程，主线程继续执行下一步，异步线程执行 `setTimeout`  \r\n- 主线程执行 `Promise.resolve().then` , `.then` 的参数不是函数，直接执行（ `value => value` ） ，输出 `3 1`\r\n- 主线程继续执行同步任务 `whlie` ，等待 `1000ms` ，在此期间，`setTimeout` 定时 `500ms` 完成，异步线程将 `setTimeout` 回调事件放入宏任务队列中\r\n- 继续执行下一步，输出 `4 1000` \r\n- 检查微任务队列，为空\r\n- 检查宏任务队列，执行 `setTimeout` 宏任务，输入 `2 1000` \r\n\r\n### 总结\r\n\r\n- `Promise` 构造函数是同步执行的， `then` 方法是异步执行的\r\n\r\n- `.then` 或者 `.catch` 的参数期望是函数，传入非函数则会直接执行\r\n- `Promise`的状态一经改变就不能再改变，构造函数中的 `resolve` 或 `reject` 只有第一次执行有效，多次调用没有任何作用\r\n- `.then`方法是能接收两个参数的，第一个是处理成功的函数，第二个是处理失败的函数，再某些时候你可以认为`catch`是`.then`第二个参数的简便写法\r\n- 当遇到 `promise.then` 时， 如果当前的 `Promise` 还处于 `pending` 状态，我们并不能确定调用 `resolved` 还是 `rejected` ，只有等待 `promise` 的状态确定后，再做处理，所以我们需要把我们的两种情况的处理逻辑做成 `callback` 放入 `promise` 的回调数组内，当 `promise` 状态翻转为 `resolved` 时，才将之前的 `promise.then` 推入微任务队列\r\n"
  },
  {
    "id": 15,
    "title": "经典排序算法汇总总结（冒泡、选择、插入、快速、归并）",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "Js",
      "排序"
    ],
    "date": "2024-08-11",
    "abstract": "经典排序算法的总结",
    "fileName": "经典排序算法汇总总结（冒泡、选择、插入、快速、归并）.md",
    "filePath": "/2024/08/经典排序算法汇总总结（冒泡、选择、插入、快速、归并）.md",
    "mdContent": "\n# 排序算法\n\n## 冒泡排序\n\n- 想象你有一组泡泡，每个泡泡上写着一个数字。泡泡比较相邻的两个数字，较大的泡泡会浮上去，较小的泡泡沉下来。经过多次比较，最大的泡泡最终会浮到最右边，而整个过程就像是把最大的泡泡慢慢“泡”到上面去。\n\n\n```js\nconst bubbleSort = (arr) => {\n    let n = arr.length;\n    for(let i = 0; i < n - 1; i++) {\n        for(let j = 0; j < n - i -1; j++） {\n            if(arr[j] > arr[j+1]) {\n                let tmp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n    return arr;\n}\nconsole.log(bubbleSort([64, 34, 25, 12, 22, 11, 90]));\n```\n \n## 选择排序\n\n- 假设你有一群孩子站成一排，你要按照身高从矮到高排队。你先从这群孩子中挑出最矮的，站到最左边；然后从剩下的孩子中挑出最矮的，站在第一个孩子的右边。如此反复，直到所有孩子都排好队。\n\n```js\nconst selectionSort = arr => {\n    let n = arr.length;\n    for(let i = 0; i < n - 1; i++) {\n        let minIndex = i;\n        for(let j = i + 1; j < n; j++) {\n            if(arr[j] < arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n        let tmp = arr[minIndex];\n        arr[minIndex] = arr[i];\n        arr[i] = temp;\n    }\n    return arr;\n}\n\nconsole.log(selectionSort([64, 34, 25, 12, 22, 11, 90]));\n```\n\n## 插入排序\n\n- 想象你在整理一手扑克牌，每次你从桌上抓起一张牌，然后把它插入到你手里已经排好顺序的牌组中。你要找到合适的位置，确保手中的牌始终是从小到大的顺序。\n\n```js\nconst insertionSort = arr => {\n    let n = arr.length;\n    for(let i = 1; i < n; i++) {\n        let key = arr[i];\n        let j = i - 1;\n        while(j >= 0 && arr[j] < key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n   }\n   return arr;\n}\n\nconsole.log(insertionSort([64, 34, 25, 12, 22, 11, 90]));\n```\n\n## 快速排序\n\n- 快速排序就像是在挑选基准点，将列表分成左右两部分。你随机选取一个元素作为“枢轴”，然后将比它小的元素放在左边，比它大的元素放在右边。对左右两部分递归地进行相同的操作，直到整个列表都有序。\n\n```js\nconst quickSort = arr => {\n    if(arr.length <= 1) {\n        return arr;\n    }\n    \n    let pivot = arr[Math.floor(arr.length / 2)];\n    let left = [];\n    let right = [];\n    \n    for (let i = 0; i < arr.length; i++) {\n        if(i == Math.floor(arr.length / 2)) continue;\n        if(arr[i] < pivot) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n    return quickSort(left).concat([pivot], quicksourt(right));\n    \nconsole.log(quickSort([64, 34, 25, 12, 22, 11, 90]));\n```\n\n## 归并排序\n\n- 归并排序就像在两个有序的文件中查找并合并数据。你把列表分成两半，分别对每一半进行排序，然后合并这两个有序列表，就像是把两个已经排好顺序的文件夹合并成一个。\n\n```js\nconst mergeSort = arr => {\n    if(arr.length <= 1) {\n        return arr;\n    }\n    let mid = Math.floor(arr.length / 2);\n    let left = mergeSort(arr.slice(0, mid));\n    let right = mergeSort(arr.slice(mid, arr.length));\n    return merge(left, right);\n}\n\nconst merge = (left, right) => {\n    let result = [];\n    let i = 0;\n    let j = 0;\n    while(i < left.length && j < right.length) {\n        if(left[i] < right[j]) {\n            result.push(left[i]);\n            i++;\n        } else {\n            result.push(right[j]);\n            j++;\n        }\n    }\n    return result.concat(left.slice(i)).concat(right.slice(j));\n}\n\nconsole.log(mergeSort([64, 34, 25, 12, 22, 11, 90]));\n```\n\n"
  },
  {
    "id": 16,
    "title": "LeetCode学习笔记——“多”数之和（JAVA实现）",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "LeetCode",
      "双指针"
    ],
    "date": "2020-04-13",
    "abstract": "",
    "fileName": "LeetCode学习笔记——“多”数之和（JAVA实现）.md",
    "filePath": "/old_blogs/LeetCode学习笔记——“多”数之和（JAVA实现）.md",
    "mdContent": "\n\n## 前言\n\n在最近LeetCode的刷题过程中，\n\n发现了几道有意思又相似的题目，\n\n就是求两数之和，三数之和，四数之和，\n\n一开始在做两数之和的时候，我使用的是C，\n\n在做到三数之和的时候，一开始还是想使用C尝试一下，\n\n但是面临要去重的问题，用C感觉就很麻烦（主要是不会），\n\n但是用到Java的话，就感觉大大便利了。\n\n\n### 1.两数之和\n\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n**示例**\n\n> 给定 nums = [2, 7, 11, 15], target = 9\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n\n\n\n#### 解题思路\n\n题目要求的是找出等于target的两个数的数组下标，且说明了一次输入只有一个答案，\n\n所以可以定义一个**长度为2数组**来保留两个数的数组下标。\n\n找数组中两个数，我一开始想到的就是**双指针**，\n\n**慢指针**（姑且这么叫吧）作为一端的端点，而**快指针**（姑且也这么叫吧）则从**端点+1**的位置遍历数组，\n\n直到找出等于target的两个数，将数组下标保存在数组中，返回。\n\n\n\n#### 代码\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n\t\t//数组内初始值为-1，不能为0，在没有找到值的时候返回0会错误。\n        int[] res= {-1,-1};\n        int n = nums.length;\n        int i,j;\n        for(i=0;i < n-1;i++){\n            for(j=i+1;j < n;j++){\n\t\t\t\t//相等时则存入数组下标\n                if(nums[i] + nums[j] == target){\n                    res[0] = i;\n                    res[1] = j;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n### 15.三数之和\n\n给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n\n注意：答案中不可以包含重复的三元组。\n\n**示例**\n\n> 给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n\n\n#### 解题思路\n\n相比于两数之和，这道题难度我感觉大大真高了，在leetcode里面也属于mid类的，\n\n主要是涉及到去重的问题，可以用java中的**HashSet**来实现，\n\n与ArrayList不同HashSet不能保存相同的东西，这样我们就可以使用HashSet的列表去保留我们找到的数值，\n\n如果数是完全重复的，那么就不会加到里面去，最后我们再把它整个加到一个新的数组里面，返回新的数组。\n\n上面是关于去重的做法，下面是这道题的思路，\n\n与两数之和思路有相同之处，不过我们**先对数组进行排序**，从小到大排序，\n\n我们还是先找到一个端点，就从数组下标0开始，也弄一个双指针，一个从**端点+1**开始，一个在**数组末端**，\n\n判断三个数的大小，\n\n**等于0则加入到HashSet的列表中，**\n\n**如果小于0，因为我们已经排好序，那就将左边的指针+1，**\n\n**如果大于0，就将右边的指针-1。**\n\n\n#### 代码\n\n```java\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n\t\t//创建一个HashSet的列表，用于去重\n        Set<List<Integer>> res = new HashSet<>();\n\t\t//将数组进行排序\n        Arrays.sort(nums);\n        int n = nums.length;\n        for(int i=0;i < n -2;i++){\n            int l = i + 1; //左指针\n            int r = n - 1; //右指针\n            while(l < r){\n                if(nums[i] + nums[l] + nums[r] == 0){ //等于0，则加入到列表中\n                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));  \n                    l++;\n                    r--;\n                }\n                else if(nums[i] + nums[l] + nums[r] < 0){  //小于0，左指针++\n                    l++;\n                }else{    //大于0，右指针--\n                    r--;\n                }\n            }\n        }\n\t\t//创建一个新的数组\n        List<List<Integer>> ans = new ArrayList<>();\n        ans.addAll(res);  //将HashSet全部加到数组里面\n        return ans;\n    }\n}\n```\n\n\n\n### 18.四数之和\n\n给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。\n\n注意：答案中不可以包含重复的四元组。\n\n**示例**\n\n> 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。\n满足要求的四元组集合为：\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]\n\n</br>\n\n#### 解题思路\n\n四数之和其实和三数之和是差不多的，我也是直接在三数之和的基础上改的，\n\n去重的方式一样，这里就不赘述了，\n\n但四数之和要比三数之和多一个指针，其实也看作是一个端点（叫做后端点），\n\n相比于前端点多了一个位置，其实就是**两层for循环**。\n\n与三数之和相同，两个的端点的值不能到达数组末尾了，因为我们要保留一个四元组。\n\n</br>\n\n#### 代码\n\n```java\nclass Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n\t\t//新建一个HashSet的列表，用于去重\n        Set<List<Integer>> res = new HashSet<>();\n\t\t//将数组进行排序\n        Arrays.sort(nums);\n        int n = nums.length;\n        int i,j;\n\t\t//i只能到达n-3的位置，后面要有足够的空间判断\n        for(i=0;i < n-3;i++){\n\t\t\t//j只能到达n-2\n            for(j=i+1;j < n-2;j++){\n                int l = j + 1;\n                int r = n - 1;\n                while(l < r){\n\t\t\t\t\t//相等则将数存入数组列表中\n                    if(nums[i] + nums[j] + nums[l] + nums[r] == target){ \n                        res.add(Arrays.asList(nums[i],nums[j],nums[l],nums[r]));\n                        l++;\n                        r--;\n                    }\n\t\t\t\t\t//小于就左指针++\n                    else if(nums[i] + nums[j] + nums[l] + nums[r] < target){ \n                        l++;\n                    }\n                    else   //大于就右指针--\n                        r--;\n                }\n            }\n        }\n\t\t//新建一个数组，将HashSet中的值全部转移过来\n        List<List<Integer>> ans = new ArrayList<>();\n        ans.addAll(res);\n        return ans;\n    }\n}\n```"
  },
  {
    "id": 17,
    "title": "LeetCode学习笔记——二叉树的最近公共祖先",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "LeetCode",
      "递归"
    ],
    "date": "2020-04-13",
    "abstract": "",
    "fileName": "LeetCode学习笔记——二叉树的最近公共祖先.md",
    "filePath": "/old_blogs/LeetCode学习笔记——二叉树的最近公共祖先.md",
    "mdContent": "\n最近有一道题频繁让我遇到，就是求二叉树的最近公共祖先，其实很好理解，就是求两个结点的最近相交的结点\n\n遇到树的问题，大多数情况都要往递归方向思考，那确定了递归做法，就得考虑怎么递，又怎么归，今天，借助这道题，总结一下递归的常规做法。\n\n\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n比如给定一个二叉树，求结点 8 和结点 5 的公共祖先，可知 公共祖先 为结点3，也是根节点。\n\n![](https://note.youdao.com/yws/api/personal/file/WEBfc48a193390d3a6c00114e8a96665e48?method=download&shareKey=2d41d26083a66f09e06a6137fbaeef77)\n\n\n\n当我们在思考如何递归的时候，不要那么贪心的想要把整个过程都想的明明白白，而是**化整为零**，先思考一个过程，再思考递推到下一个过程。\n\n那一个过程是什么？\n\n![](https://note.youdao.com/yws/api/personal/file/WEBdcb7e8a6739be0059664708bb308b1d8?method=download&shareKey=7abb518b9ee91fa9805cd38748acffeb)\n\n就是一个根节点带着两个子节点。\n\n我们分析题目，知道给定的**两个结点 p, q** 不一定是分别分布在根节点的左右子树中，也可能都分布在根节点的左子树，或者都分布在根节点的右子树。\n\n所以，我们应该一边一边的去寻找，对于单单一个过程中，先去找左子树，然后再去找右子树。\n\n对于结点 3 这个过程：\n\n```java\nTreeNode left = root.left;\nTreeNode right = root.right;\n```\n\n如果没有找到，这时候就要递推了，同样的，把它的左子树和右子树分别看作根节点，各自看作一个过程继续去找，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB18f8117dd33fa80dc3bebb477dd66e6e?method=download&shareKey=f4d690935a2c22a67eb9300f865493da)\n\n对于结点 4 这个过程，\n\n```java\nTreeNode left = root.left;\nTreeNode right = root.right;\n```\n\n发现，当再以结点 4 的左右子树分别作为一个子过程的时候，结点  8 为根节点的过程是满足了题目要求，也就是根节点是满足了我们要找的结点，这时候就要返回。\n\n```java\nif(root == p || root == q)\n    return root;\n```\n\n而结点 8 作为结点 4 的子过程，又是结点 4 的右子树，所以返回上一层时，将是这样：\n\n结点 4：\n\n```java\nTreeNode left = root.left;\nTreeNode right = 结点 8;\n```\n\n对于结点 4 的左子树，它啥也没找到，毫无疑问返回的是 null，\n\n```java\nTreeNode left = null;\nTreeNode right = 结点 8;\n```\n\n这时候，要继续往上面回归了，结点 4 往上面回归，要对结点 4 的左右子树进行判断，刚刚我们得出，在结点 4 的右子树找到了结点了，而左子树没有找到，所以要将右子树继续回归。\n\n```java\nif(left == null)\n\treturn right;\nif(right == null)\n\treturn left;\n```\n\n所以对于结点 3 这个过程，结点 4 作为它的左子树是带着结果回来了：\n\n结点 3：\n\n```\nTreeNode left = 结点 4(结点 8);\nTreeNode right = root.right;\n```\n\n所以对于结点 3 作为根节点来说，它的左子树这时就完成了递推和回归，而且左子树是带着结点回来的，\n\n我们继续看结点 3 的右子树，\n\n同样的，根据前面的步骤，会递推到 结点 6 这个位置，把结点 6 看作单独一个过程，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB1d4895eb4c364be2f0c44f9e8558d311?method=download&shareKey=0335f4d83f4e063b0f4bf6f59b5ee11b)\n\n结点 6：\n\n```java\nTreeNode left = root.left;\nTreeNode right = root.right;\n```\n\n发现，当以结点 6 的右子树为根节点的过程是找到了结点，所以返回结点 5，而左子树啥也没，就返回null，\n\n结点 6:\n\n```java\nTreeNode left = null;\nTreeNode right = 结点 5;\n```\n\n同样，根据前面的步骤，结点 6 继续回归，最终回归到 结点 7，\n\n对于结点 7来说，\n\n```java\nTreeNode left = 结点 6(结点 5);\nTreeNode right = null;\n```\n\n这时候再看最上面的结点 3，它的右子树也回归了，也是带着值的，\n\n对其左右子树进行判断，\n\n```java\nif(left != null && right != null)\n\treturn root;\n```\n\n对于左右子树都不为空，也是都找到值回来的，那么此根节点也就是他们最近的公共祖先。\n\n\n\n所以，这道题总结递推和回归的情况就是，\n\n**递推**\n\n- **当以此为根节点的过程没有返回值的时候，将其左右子树再分别看作单个过程，往下递推**\n\n**回归**\n\n- **当以此为根节点的过程找到了所需要的结点，返回此根节点**\n- **当单个过程的根节点为空的情况，就直接返回**\n\n所以综上，应该就可以对这道题的递归过程了解透了，\n\n下面看一下完整代码：\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        //单个过程的根节点为空，则直接返回\n        if(root == null)\n            return root;\n        //如果该过程的根节点等于需要的节点，就返回根节点\n        if(root == p || root == q)\n            return root;\n\t\t\n        //根节点不符合，则进行递推，把左右子树分别都看作单独的一个过程\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n\n        //到这里的时候，对于单独的一个过程来说，它的左右节点是带着值返回了\n        \n        //当左右子树都不为空，也是都找到了，那么根节点就是最近的公共祖先\n        if(left != null && right != null)\n            return root;\n        //如果左子树找不到，说明右子树找到了，就返回右子树\n        else if(left == null) {\n            return right;\n        }\n        //如果右子树找不到，说明左子树找到了，就返回左子树\n        else {\n            return left;\n        }\n        \n    }\n}\n```\n\n\n\n<br>\n\n面对递归问题，我们不能急于去了解全盘的递推和回归，而是把它分成了一个一个小小单独的过程，对于单个过程来分析在什么情况进行递推，在什么情况下回归就容易许多，然后再推往整体，看看哪一部分是在递推后需要进行判断的，哪一部分是在回归时候需要判断的，这样子，这一道题就解答出来了。"
  },
  {
    "id": 18,
    "title": "eetCode学习笔记——初学动态规划",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "LeetCode",
      "动态规划"
    ],
    "date": "2020-03-19",
    "abstract": "",
    "fileName": "LeetCode学习笔记——初学动态规划.md",
    "filePath": "/old_blogs/LeetCode学习笔记——初学动态规划.md",
    "mdContent": "\n\n今天，开始接触到动态规划问题，现在我对动态规划还没有一个完整的认识，\n\n目前我对动态规划的理解是，\n\n在递归的过程中，我们可能会进行对一个数进行重复递归，这样子就导致时间复杂度呈指数增长，\n\n比如：\n\n在**斐波那契数列**中，\n\n我们知道 fib(n) = {1, 1, 2, 3 , 5, 8，……}， 这里举个例子，假如我们还不知道 fib(5) 是多少，\n\n如果我们要算 fib(5) ，按照我们递归的思维，我们会这样做:\n\n\n```java\npublic int fib(int n) {\n\tif(n == 1 || n == 2)\n\t\treturn 1;\n\treturn fib(n - 1) + fib(n - 2);\n}\n```\n\n内在流程是这样子的：\n\n![](https://note.youdao.com/yws/api/personal/file/WEB256e02a840992ccc16f44aa9026019ea?method=download&shareKey=87ccea5ab1e51a801d592838c2008b6c)\n\n其实在运算的过程中，我们**重复运算了 fib(3)** ，\n\n这时候如果我们想改进算法的话，**是不是可以把 fib(3) 的值存起来**，\n\n当下面某一次递归到 fib(3) 的时候，我们就可以直接用了？\n\n改进上面那个算法后，长这个样子：\n\n```java\npublic int fib(int n) {\n    //判断特殊值\n    if(n == 1 || n == 2)\n        return 1;\n    //申请一个数组来保存算过的值\n    int []dp = new int[n + 1]; \n    //初始我们前面的值，如果这个值没有初始化是没有规律可行的\n    dp[1] = 1;\n    dp[2] = 1;\n    for(int i = 3; i <= n; i++) {\n        dp[i] = dp[n - 1] + dp[n - 2];\n    }\n    return dp[n];\n}\n```\n\n这个就是我初步认识的动态规划。\n\n\n\n在leetcode里面有几道类似这样的题，哦不，不是类似，方法感觉就是一模一样的（狗头保命）\n\n\n\n### 一. 青蛙跳台阶问题\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个  `n`  级的台阶总共有多少种跳法。\n\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n\n\n\n\n**示例 1：**\n\n```\n输入：n = 2\n输出：2\n```\n\n**示例 2：**\n\n```\n输入：n = 7\n输出：21\n```\n\n\n#### 解题思路\n\n这道题可以分为两part，\n\n第一先是考虑如何求出跳上n级台阶有多少种跳法，\n\n然后再考虑对结果怎么取模；\n\n\n\n这道题有个隐藏的条件没有给出来，就是 `n == 0` 的时候，结果应该是等于1的，\n\n别问我怎么知道的（都是泪）。\n\n跳台阶，有两种方法，一种跳一级，一种跳两级，\n\n当 `n == 1`的时候，只有一种跳法，\n\n当 `n == 2` 的时候，有两种跳法\n\n- 每次都跳一级，跳两次\n\n- 一次跳两级\n\n这时候我们来看看 `n == 3`，\n\nn为3的时候，是可以分为子问题进行考虑的，\n\n比如，青蛙是从哪一级跳到第三级的，\n\n**有可能是从第一级，直接跳两级，**\n\n**有可能是从第二级，直接跳一级，**\n\n什么？有可能从第一级，每一次跳一级？\n\n这种情况其实就是在第二级跳到第三级。\n\n那青蛙是怎么跳到第二级或者第一级，我们已经讨论过了，\n\n问题拆解完毕！\n\n这样子，我们就知道，跳到 n 级，其实是跟怎么跳到 `n - 1`和 `n - 2`有关，\n\n那这就是递归的思想，\n\n**f(n) = f(n - 1) + f(n - 2)**\n\n这就跟上面的斐波那契数列一模一样了。\n\n利用动态规划优化一下，而且这道题用动态规划才能AC，因为递归进去，会超时。\n\n第二步，是需要我们将答案取模，\n\n我一开始这样做的：\n\n```java\nreturn dp[n] % 1000000007;\n```\n\n结果打脸，因为如果针对结果取模的话，数组里面除的数就会超出范围了。\n\n\n\n#### 代码\n\n```java\nclass Solution {\n    public int numWays(int n) {\n        //判断特殊值\n        if(n == 0 || n == 1)\n            return 1;\n        //申请一个数组记录已经计算后对应的值\n        int []dp = new int[n + 1];\n        //初始值，n == 2情况下的值必须作为初始值\n        dp[0] = 1;\n        dp[1] = 1;\n        dp[2] = 2;\n        for(int i = 2; i <= n; i++) {\n            //对结果进行取模后再存入数组\n            dp[i] = (dp[i - 1] + dp[i -2]) % 1000000007;\n        }\n        return dp[n] ;\n    }\n}\n```\n\n\n### 二. 爬楼梯问题\n\n假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n**注意：**给定 *n* 是一个正整数。\n\n\n**示例 1：**\n\n```\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n```\n\n**示例 2：**\n\n```\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n```\n\n\n#### 解题思路\n\n这道题和青蛙的题目是一样的，只不过人换成了青蛙，台阶换成了楼梯\n\n直接上代码\n\n\n####  代码\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        if(n == 0 || n == 1)\n            return 1;\n        int []dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n        dp[2] = 2;\n        for(int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i -2];\n        }\n        return dp[n] ;\n    }   \n}\n```\n\n"
  },
  {
    "id": 19,
    "title": "LeetCode学习笔记——单词拼写",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "LeetCode",
      "数组"
    ],
    "date": "2020-03-17",
    "abstract": "",
    "fileName": "LeetCode学习笔记——单词拼写.md",
    "filePath": "/old_blogs/LeetCode学习笔记——单词拼写.md",
    "mdContent": "\n\n### 1160. 拼写单词\n\n给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。\n\n假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），\n\n那么我们就认为你掌握了这个单词。\n\n注意：每次拼写时，chars 中的每个字母都只能用一次。\n\n返回词汇表 words 中你掌握的所有单词的 长度之和。\n\n**示例 1：**\n\n> 输入：words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\n> 输出：6\n> 解释： \n> 可以形成字符串 \"cat\" 和 \"hat\"，所以答案是 3 + 3 = 6。\n\n**示例 2：**\n\n> 输入：words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\n> 输出：10\n> 解释：\n> 可以形成字符串 \"hello\" 和 \"world\"，所以答案是 5 + 5 = 10。\n\n\n#### 解题思路\n\n**1.**利用长度为26的数组，例如**int []chars = new int[26]**\n\n**2.**记录单词表中每个word中各自字符出现的数量，同时也记录chars中字符的数量\n\n**3.**对单词表words中的每个word进行遍历，**当chars中的某字符数量小于word的字符数量时**，则说明该单词不能被掌握，**标记后跳过**这个单词，遍历下一个。\n\n\n\n需要注意的是，在进行统计一个字符串中每个字符的数量的时候，要将字符串转为数组的形式，\n\n即**String.toCharArray()**，此时才可以对其进行挨个遍历。\n\n\n\n#### 代码\n\n```java\n\npublic int countCharacters(String[] words, String chars) {\n    if(chars == null || words == null)\n        return 0;\n    int []cnt_chars = new int[26];   //用于统计chars中字符的数量\n    int count = 0;  //单词长度计数\n    int flag = 1;   //标记，用于判断该单词是否能被掌握\n    //对chars进行遍历统计\n    for(char c : chars.toCharArray())\n        cnt_chars[c - 'a']++;\n    //对单词表中每个word进行单独操作\n    for(String word : words) {\n        int []cnt_word = new int[26];   \n        //统计每个单词字符的数量\n        for(char c : word.toCharArray())\n            cnt_word[c - 'a']++;\n        //再次对该单词进行遍历，判断是否能被掌握\n        for(char c : word.toCharArray()) {\n            //如果chars中的字符数量小于word中，则标记不能被掌握，跳过这个单词\n            if(cnt_chars[c - 'a'] < cnt_word[c - 'a']) {\n                flag = 0;\n                break;\n            }\n            flag = 1;  //需将标记更新\n        }\n        if(flag == 1)\n            count += word.length();  //将单词长度加起来\n    }\n    return count;\n}\n```\n\n"
  },
  {
    "id": 20,
    "title": "LeetCode学习笔记——单词搜索（回溯）",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "LeetCode",
      "回溯"
    ],
    "date": "2020-04-13",
    "abstract": "",
    "fileName": "LeetCode学习笔记——单词搜索（回溯）.md",
    "filePath": "/old_blogs/LeetCode学习笔记——单词搜索（回溯）.md",
    "mdContent": "\n今天来聊聊回溯思想，\n\n回溯，可以理解为后退或者返回上一层，\n\n通常用法是：对于每处都有多种方向选择前进，当选择一种方向前进后，发现不能再继续前进的时候，就返回该处继续选择剩下的方向前进，\n\n这样子的思想就称为回溯。\n\n\n比如给定一个二维表，求到达某处的的路径数量，\n\n如果该处不是在边界，那么对于该处来说，就有四个方向可选择，\n\n通常我们结合深度优先搜索（DFS）来做，\n\nDFS的好处就是**一条路走到黑，不撞南墙不回头**，\n\n选定一个方向一直进行下去，当发现没有再进行下去的条件的时候，就开始回溯回来，继续选择剩下的三个方向继续DFS前进，\n\n这个进行下去的条件一般会有两个，\n\n- 该处是否被访问过了，这个我们一般借用一个标记数组来辅助\n- 是否在边界，前进方向减少\n\n当然有时候题目还会有其他条件，比如说障碍物等等。\n\n<br>\n\n以上就是对回溯的大概介绍，如果能够理解了上面，说明你大概对回溯有一定的认识了，\n\n下面我们通过两道题目来认识一下回溯具体的实现，\n\n\n\n<br>\n\n### 单词搜索\n\n给定一个二维网格和一个单词，找出该单词是否存在于网格中。\n\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n\n**示例:**\n\n```\nboard =\n[\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n]\n\n给定 word = \"ABCCED\", 返回 true\n给定 word = \"SEE\", 返回 true\n给定 word = \"ABCB\", 返回 false\n```\n\n**提示：**\n\n- board 和 word 中只包含大写和小写英文字母。\n- 1 <= board.length <= 200\n- 1 <= board[i].length <= 200\n- 1 <= word.length <= 10^3\n\n\n\n<br>\n\n#### 解题思路\n\n这道题，我一开始没有看仔细，一拿到题目，就刷刷的开始写，用了两个HashTable，一个记录board中出现的字母数量，一个用来记录单词中字母的数量，主要判断两种数量是否一致就可以判断单词是存在在网格中。\n\n以上是错误示范，因为题目有个很苛刻的条件，\n\n单词必须按照字母的顺序，通过相邻的单元格内的字母构成，\n\n有人可能一下子对“相邻“这个概念有点懵，题目也给出解释了，通俗来讲就是当前的上下左右四个方向，其他的都不行，\n\n比如有一个测试案例\n\n> ['a', 'b'], ['c', 'd']\n>\n> 求“abcd”的时候返回的是false，\n\n这是因为，\n\n['a', 'b'], \n\n['c', 'd']\n\nb和c不在相邻位置，\n\n理解这个很重要，因为这就是涉及到我们的回溯的思想，\n\n回归到题目，\n\n我们从网格的左上角开始，与单词从左到右的字母进行比较，\n\n当该处符合的时候，就把这里标记成已访问，然后对四个方向进行进行dfs，\n\n这时候就涉及到了一个知识，**如何重置dfs的状态**，\n\n当对该点的四个方向都进行遍历后，发现并没有符合要求，那么此处的访问状态得**改回未访问状态**，为回溯做准备，\n\n当符合要求的时候，就返回true；\n\n**下面以题目的事例进行图解说明：**\n\n查找 `ABCCEE`\n\n搜索从左上角开始，\n\n ![](https://note.youdao.com/yws/api/personal/file/WEBbba96f87b2644d5687c2119130952f9f?method=download&shareKey=edc5368f5223be2edcd61b23561a5a17)\n\n将单词从左到右进行对比，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB237f9a3c1d2a9da756f91bd96db6ac4f?method=download&shareKey=18446dc8a95a18ba8c022135bb0af64e)\n\n\n\n此时匹配，但此时在边界，只有两个方向可以选择，先考虑右边，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB1725c6620285c0d57b81e27aaeeb97ba?method=download&shareKey=1e9cee5525dc9aaa381373418df8512f)\n\n右边匹配相等，此时还在边界，依旧只有两个方向，继续考虑右边，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB9836c9cff9ddc8d886d9ddbd8b02fa6b?method=download&shareKey=03b6bed98621be3726ecc5e35a5f8057)\n\n此时匹配，和上面一样，继续考虑右边，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB809bbd151694f8d47d536f1d179554b8?method=download&shareKey=8290c7ad2e767efcba3ace99171f2261)\n\n当前不匹配，此时回溯上一层，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB0733d842ed3d85f3fbfd3e3844962c87?method=download&shareKey=0714e1bac0f3d7247dcb437e20a583ed)\n\n从 “C” 处进行重新选择，之前在“C” 处选择了右边，此时只剩下下面，则往下面进行DFS，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB689e4c4a5adcf127816405c81007963f?method=download&shareKey=0a599ac4bbf75247dcf2c12ff8d6a973)\n\n此时匹配，上面已经标记被访问过，此时只剩下三个方向，先考虑右边，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB3adf53488627e44666a093542a94e3fe?method=download&shareKey=bc4fe09aa9da01fe4c5e2356a2679d38)\n\n当前不匹配，回溯上一层，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB3e8bf3fd9815a6304ba4d0827732899b?method=download&shareKey=cf7f59aac0aad1b49a0ce444b90cbfe2)\n\n从 “C” 处进行重新选择，之前在“C” 处选择了右边，而上边又被访问过，此时只剩下下边和左边，先考虑下边，则往下面进行DFS，当前匹配，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB7c57f82cf943dbc9e458a4212ebe8582?method=download&shareKey=e2a004e10f7751e3e5d1795068f5e590)\n\n此时在边界，只有两个方向选择，先考虑右边，此时匹配，则说明，从左上角（0,0）处出发，能找到一个单词，则返回true，如果不能，则从（0,1）开始继续DFS。\n\n![](https://note.youdao.com/yws/api/personal/file/WEB2b09d00595105551fd51c61f7f6ecaa3?method=download&shareKey=e75b280a8fed51e346ea47f769017119)\n\n\n\n<br>\n\n如果理解了上面，说明基本上已经搞定这道题了，\n\n通过分析，我们需要几个东西：\n\n- 四个方向的表示\n\n- 标记数组（用于标记是否被访问）\n- DFS方法（用于对四个方向分别进行dfs）\n- 判断边界的方法\n\n通过这些，我们就可以一步步搭建起我们的代码。\n\n\n\n<br>\n\n#### 代码\n\n```java\nclass Solution {\n    //用于跨方法使用\n    private String word;\n    private char[][] board;\n    //标记数组\n    private boolean[][] marked;\n    //四个方向表示\n    private int[][] direction ={{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    //网格的行和列\n    private int row;\n    private int column;\n    \n    public boolean exist(char[][] board, String word) {\n        row = board.length;\n        column = board[0].length;\n        if(row <= 0)\n            return false;\n        this.board = board;\n        this.word = word;\n\t\t//初始化标记数组\n        marked = new boolean[row][column];\n\t\t//遍历网格，对每个点都开始进行dfs，直到出结果\n        for(int i = 0; i < row; i++) {\n            for(int j = 0; j < column; j++) {\n                //如果在dfs中返回true，代表匹配到单词，则返回true\n                if(dfs(i, j, 0))\n                    return true;\n            }\n        }\n        return false;\n    }\n\t//DFS方法\n    public boolean dfs(int i, int j, int start) {\n        //start是指向单词字母的指针，一开始是0，指向首字母，然后++，代表从左往右遍历，在末尾要进行特判\n        if(start == word.length() - 1)\n            return board[i][j] == word.charAt(start);\n        //如果此处已经匹配，则往此处进行方向选择\n        if(board[i][j] == word.charAt(start)) {\n            //将该处的状态标记为已访问\n            marked[i][j] = true;\n            //进行四个方向选择\n            for(int k = 0; k < 4; k++) {\n                int newX = i + direction[k][0];\n                int newY = j + direction[k][1];\n                //如果下一处没有越界，且还未访问过，则前进\n                if(inArea(newX, newY) && !marked[newX][newY]) {\n                    //如果一直进行dfs直到最后一个单词的字母也匹配上，则返回true\n                    if(dfs(newX, newY, start + 1))\n                        return true;\n                }\n            }\n            //否则，将该处的状态标记为未访问，未下一轮做准备\n            marked[i][j] = false;\n        }\n        return false;\n    }\n\t//判断是否在边界，也是判断是否越界的方法\n    public boolean inArea(int newX, int newY) {\n        return newX >= 0 && newX <row && newY >= 0 && newY < column;\n    }\n}\n```\n\n\n\n<br>\n\n以上就是单词搜索的做法，采用回溯，一步一步的前进，遇到不对的，就回溯，返回上一层继续选择前进，直到把这条路走到黑，也就是把单词遍历完都没有找到，那就得重新选择开始点，直到把网格全部的点作为开始点尝试过，都没有的话，说明该网格中的字母找不到这个单词。\n\n\n\n<br>\n\n以上是单词搜索 I ，还有一个单词搜索 II，如果以上已经掌握了，下面这个就是加两句代码的事，来看看题，\n\n<br>\n\n### 单词搜索 II\n\n给定一个二维网格 board 和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。\n\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。\n\n**示例:**\n\n```\n输入: \nwords = [\"oath\",\"pea\",\"eat\",\"rain\"] and board =\n[\n  ['o','a','a','n'],\n  ['e','t','a','e'],\n  ['i','h','k','r'],\n  ['i','f','l','v']\n]\n\n输出: [\"eat\",\"oath\"]\n```\n\n\n\n<br>\n\n#### 解题思路\n\n相比于第一题，这道题寻找的不是一个单词，而是一组单词，\n\n那很简单啊，只要从单词表中一个一个的取出来进行比较就行了，\n\n这不就是第一题了吗？\n\n所以掌握了上一题，这一题就是复制粘贴，\n\n但这道题还是需要一个列表来保存结果的，\n\n直接上代码吧。\n\n\n\n<br>\n\n#### 代码\n\n```java\nclass Solution {\n    //用于跨方法使用\n    private String word;\n    private char[][] board;\n    //标记数组\n    private boolean[][] marked;\n    //四个方向表示\n    private int[][] direction ={{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    //网格的行和列\n    private int row;\n    private int column;\n    \n    public List<String> findWords(char[][] board, String[] words) {\n        //列表保存结果\n        List<String> res = new ArrayList<>();\n        //从单词表中一个一个取出单词比较\n        for(String word1 : words) {\n            //如果找到则加入到列表中\n            if(exist(board, word1))\n                res.add(word1);\n        }\n        return res;\n    }\n    \n    public boolean exist(char[][] board, String word) {\n        row = board.length;\n        column = board[0].length;\n        if(row <= 0)\n            return false;\n        this.board = board;\n        this.word = word;\n\t\t//初始化标记数组\n        marked = new boolean[row][column];\n\t\t//遍历网格，对每个点都开始进行dfs，直到出结果\n        for(int i = 0; i < row; i++) {\n            for(int j = 0; j < column; j++) {\n                //如果在dfs中返回true，代表匹配到单词，则返回true\n                if(dfs(i, j, 0))\n                    return true;\n            }\n        }\n        return false;\n    }\n\t//DFS方法\n    public boolean dfs(int i, int j, int start) {\n        //start是指向单词字母的指针，一开始是0，指向首字母，然后++，代表从左往右遍历，在末尾要进行特判\n        if(start == word.length() - 1)\n            return board[i][j] == word.charAt(start);\n        //如果此处已经匹配，则往此处进行方向选择\n        if(board[i][j] == word.charAt(start)) {\n            //将该处的状态标记为已访问\n            marked[i][j] = true;\n            //进行四个方向选择\n            for(int k = 0; k < 4; k++) {\n                int newX = i + direction[k][0];\n                int newY = j + direction[k][1];\n                //如果下一处没有越界，且还未访问过，则前进\n                if(inArea(newX, newY) && !marked[newX][newY]) {\n                    //如果一直进行dfs直到最后一个单词的字母也匹配上，则返回true\n                    if(dfs(newX, newY, start + 1))\n                        return true;\n                }\n            }\n            //否则，将该处的状态标记为未访问，未下一轮做准备\n            marked[i][j] = false;\n        }\n        return false;\n    }\n\t//判断是否在边界，也是判断是否越界的方法\n    public boolean inArea(int newX, int newY) {\n        return newX >= 0 && newX <row && newY >= 0 && newY < column;\n    }\n}\n```\n\n\n\n<br>\n\n------\n\n整理于2020.4.11，本文图片来源于[liweiwei1419的题解](https://leetcode-cn.com/u/liweiwei1419/)，只为学习而用，侵删。\n\n"
  },
  {
    "id": 21,
    "title": "LeetCode学习笔记——打家劫舍系列（动态规划）",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "LeetCode",
      "动态规划"
    ],
    "date": "2020-03-21",
    "abstract": "",
    "fileName": "LeetCode学习笔记——打家劫舍系列（动态规划）.md",
    "filePath": "/old_blogs/LeetCode学习笔记——打家劫舍系列（动态规划）.md",
    "mdContent": "\n\n今天，继续记录动态规划。\n\n相比于前两天对动态规划的理解，今天对动态规划的理解也可以说更进一步了，\n\n但离真正的掌握，运用于股掌之中还有很长的距离。\n\n总结：解决动态规划问题，就是要找**状态**和**选择**。\n\n我之前理解动态规划是在递归的过程中记录重复的值，其实这只是一种，可以说只是用动态规划来优化，\n\n解决动态规划问题的本质，就是找出**对象的状态**，然后写出**状态转移方程**。\n\n\n\n先看一道打家劫舍的问题，\n\n\n\n\n### 打家劫舍 I\n\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。\n\n\n**示例 1:**\n\n```\n输入: [1,2,3,1]\n输出: 4\n解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n```\n\n**示例 2:**\n\n```\n输入: [2,7,9,3,1]\n输出: 12\n解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n```\n\n#### 解题思路\n\n题目很好理解，也就是说如果你（没错，你先假装小偷）进入了第一间房子，\n\n现在的智能（人工）检测，你不能进入第二间房子，否则就凉凉，\n\n那你只能走到第三间房子了，这时候可以有两种**选择**：进入或者不进入。\n\n也就是说，对每一间房子，你都有两种选择，\n\n而选择的依据是你进入后偷的钱能否最大化。\n\n所以我们就总结出了**状态**和**选择**，\n\n**房子的索引就是状态，进入和不进入就是选择**。\n\n\n\n这时候我们需要转为状态方程，我们先模拟一下：\n\n假设有五间间房子，从第一间开始就可以做选择，下面就是全部状态（**0-不进去；1-进入**），只需要把每一种情况的值求出来，再求他们的最大值，就是我们想要的结果。\n\n\n\n![](https://note.youdao.com/yws/api/personal/file/WEB5e287b9aa7dae56d9539ef4a6413e7b7?method=download&shareKey=4fb754ba30d3e1c38115a65f30ef1bda)\n\n\n\n可以看出来，这个跟我们的递归一样，里面有很多重复的情况，\n\n比如 `rob(3)`，`rob(3)`的两种选择在上面的模拟过程中重复了很多次，\n\n我们需要有个东西来记录着我们每次选择的值，这样子就不需要重复运算。\n\n\n\n我们先将上面的模拟过程转为状态方程：\n\n```java\ndp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])\n```\n\n\n\n这个dp数组记录的就是**选择本次，并且选择了前前一次**，如果**前前一次加上本次的值**大于**上一个记录**的值，就保存新的值下来，否则维持之前的值。\n\n有点抽象？\n\n确实，我觉得动态规划就是难在这里。\n\n有时候觉得明白了是一瞬间的事情，但过后会忘，或者难以言表，这都是没有真正掌握的缘故。\n\n我们看一下下面的推演：\n\n|   编号    |  0   |  1   |  2   |  3   |\n| :-------: | :--: | :--: | :--: | :--: |\n| **价值**  |  1   |  2   |  3   |  1   |\n| **dp[i]** |  1   |  2   |  4   |  4   |\n\n\n\n有点眉目没？\n\ndp[0]，也就是在第一间房子的时候，假设进入了，则现在能获得的最大值是1，\n\ndp[1]，到了第二间房子，进入了第一间房子，当然就不能进入第二间了，但是进第一间没有进入第二间的价值大，那我当然选择进入第二间，就更新值为2，\n\ndp[2]，到了第三间房子，进不进呢？得看前两间的选择，如果进入了第二间房子，当然就不能进第三间，那这时候的价值依旧只是2，但如果我不进第二间，而是进第一间，然后这时候我就可以进第三间了，那价值就变成了4，\n\n第四间同理。\n\n\n\n\n\n如果明白了这个，那我们的代码就出来了。\n\n\n\n#### 代码\n\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        //判断特殊情况\n        if (nums.length <= 1) return nums.length == 0 ? 0 : nums[0];\n        int []dp = new int[nums.length];\n        //初始值\n        dp[0] = nums[0];\n        dp[1] = Math.max(dp[0], nums[1]);\n        //从第三间开始记录值\n        for(int i = 2; i < nums.length; i++) {\n            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\n        }\n        //dp数组最后一个值为最大价值\n        return dp[nums.length - 1];    \n    }\n}\n```\n\n呼……放松一下，准备进入我们的第二题……\n\n\n### 打家劫舍 II\n\n你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。\n\n<br>\n\n**示例 1:**\n\n```\n输入: [2,3,2]\n输出: 3\n解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\n```\n\n**示例 2:**\n\n```\n输入: [1,2,3,1]\n输出: 4\n解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n```\n\n\n\n<br>\n\n\n\n#### 解题思路\n\n这道题相比于第一题的不同点在于，你今天偷的客家土楼，是房子是围着一圈的，\n\n也就是说不能同时进入第一间房子和最后一间房子，\n\n那就可以分为三种情况：\n\n- 进第一间，不进最后一间\n- 不进第一间，进最后一间\n- 两间都不进\n\n\n\n那我们是不是要三种情况都需要进入讨论，不是的，我们只需要讨论前两种，\n\n因为前两种的选择范围都包括了第三种。\n\n那这个问题就可以转换成两个问题来解决，\n\n- 从第二间到第n间\n- 从第一间到第n - 1间\n\n只要求出这种情况的最大值就行，而每种情况，都是可以说是第一题，\n\n不过需要注意的是，并不是缩短`nums数组`的长度，而是将我们已知道不需要考虑的情况初始化，\n\n结合第一题的思路，我们就可以写出我们的代码了。\n\n\n\n<br>\n\n\n\n#### 代码\n\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        if(nums.length == 0) return 0;\n        if(nums.length == 1) return nums[0];\n        int []res1 = new int[nums.length];\n        int []res2 = new int[nums.length];\n        //第一种情况从第二间到第n间\n        res1[0] = 0; \n        res1[1] = nums[1];\n        //第二种情况是从第一间到第n - 1间\n        res2[0] = nums[0]; \n        res2[1] = Math.max(nums[0], nums[1]); \n        for(int i = 2; i < nums.length; i++) {\n            res1[i] = Math.max(res1[i - 1], res1[i - 2] + nums[i]);\n        }\n        for(int i = 2; i < nums.length; i++) {\n            res2[i] = Math.max(res2[i - 1], res2[i - 2] + nums[i]);\n        }\n        //返回两种情况的最大值\n        return Math.max(res1[nums.length - 1], res2[nums.length - 2]);\n    }\n}\n```\n\n\n\n<br>\n\n\n\n### 打家劫舍 III\n\n在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。\n\n计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。\n\n<br>\n\n\n\n**示例 1:**\n\n```\n输入: [3,2,3,null,3,null,1]\n\n\t 3\n    / \\\n   2   3\n    \\   \\ \n     3   1\n\n输出: 7 \n解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.\n```\n\n**示例 2:**\n\n```\n输入: [3,4,5,1,3,null,1]\n\n\t 3\n\t/ \\\n   4   5\n  / \\   \\ \n 1   3   1\n\n输出: 9\n解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.\n```\n\n\n\n<br>\n\n\n\n#### 解题思路\n\n终于来到最后一题了，这小偷开始不知道偷哪里的房子了。\n\n其实这道题也是万变不离其宗，\n\n虽然他是树，但是他每一个结点都有选择的情况，\n\n**选择了爷爷结点，自然不能选儿子结点了，得去到孙子结点那里做选择**，\n\n不过树给我的感觉就是，一看到树，八成会用到递归，\n\n这道题也确实应该用递归。\n\n<br>\n\n\n\n我们再来分析一下题，\n\n每个结点都有选和不选的情况，\n\n假设我们在选择根结点root，\n\n那我们只能从root的左右子树的左右子树中去选择了，\n\n那如果不选择根节点root，\n\n那就从root的左右子树中去选择。\n\n\n\n<br>\n\n一开始我是这样做的：\n\n```java\nclass Solution {\n    public int rob(TreeNode root) {\n        if(root == null)\n            return 0;\n        //选择结点root\n        int res1 = root.val;\n        //对root的的左右子树的左右子树进行选择\n        if(root.left != null)\n            res1 += rob(root.left.left) + rob(root.left.right);\n        if(root.right != null)\n            res1 += rob(root.right.left) + rob(root.right.right);\n        //不选择root的情况\n        int res2 = rob(root.left) + rob(root.right);\n        //返回两种情况的最大值\n        return Math.max(res2, res1);\n    }\n}\n```\n\n\n\n成功通过，但是时间复杂度很大，因为我们进行了多次重复计算，\n\n所以我们可以申请一个备忘录记录我们遍历过的值，\n\n经过改进后，代码如下：\n\n\n\n<br>\n\n\n\n#### 代码\n\n```java\nclass Solution {\n    //申请一个哈希表作为备忘录\n    Map<TreeNode, Integer> memo = new HashMap<>();\n    public int rob(TreeNode root) {\n        if(root == null)\n            return 0;\n        //如果备忘录中有root作为起始点的值了，就返回\n        if(memo.containsKey(root))\n            return memo.get(root);\n        //选择结点root\n        int res1 = root.val;\n        //对root的的左右子树的左右子树进行选择\n        if(root.left != null)\n            res1 += rob(root.left.left) + rob(root.left.right);\n        if(root.right != null)\n            res1 += rob(root.right.left) + rob(root.right.right);\n        //不选择root的情况\n        int res2 = rob(root.left) + rob(root.right);\n        //返回两种情况的最大值\n        int res = Math.max(res2, res1);\n        \n        //记录到备忘录里面\n        memo.put(root, res);\n        \n        return res;\n    }\n}\n```\n\n\n\n![](https://note.youdao.com/yws/api/personal/file/WEBe3b6e37e56616633b19a0f341587ad23?method=download&shareKey=50e24a5ea0b1303b32ddce156500fbb3)\n\n这样子就快了很多了。\n\n<br>\n\n\n\n> 这里记录一下我对递归看法，递归是个很好用的工具，很多难以解决的问题都可以丢给递归去运算，因为递归不会累，但是就很容易出现重复运算和错误，而错误又是很难找出来的，甚至还需Debug，所以递归好用，但勿滥用。\n\n\n\n<br>\n\n------\n\n整理于2020.3.21"
  },
  {
    "id": 22,
    "title": "LeetCode学习笔记——最小覆盖串/字母异位词（Sliding Window）",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "LeetCode",
      "滑动窗口"
    ],
    "date": "2020-04-05",
    "abstract": "",
    "fileName": "LeetCode学习笔记——最小覆盖串-字母异位词（Sliding-Window）.md",
    "filePath": "/old_blogs/LeetCode学习笔记——最小覆盖串-字母异位词（Sliding-Window）.md",
    "mdContent": "\n\n### 找子串，选滑动窗口\n\n从一个字符串中找出符合条件的字串，一般会想到滑动窗口，\n\n今天总结两道题，套路是差不多的，也算是滑动窗口的经典问题，\n\n一道是最小覆盖子串，一道是找到字符串中所有的字母异位词，\n\n具体等会我们再说。\n\n这两道题的思路是差不多的，\n\n大概就是窗口的右边界一直移动，直到要求的字符纳入到窗口中，\n\n然后开始移动左边界，左边界增加缩短窗口，等到该窗口不再符合要求，就是我们要求的结果，\n\n下面，我们具体看看。\n\n\n### 最小覆盖子串\n\n给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。\n\n**示例：**\n\n```\n输入: S = \"ADOBECODEBANC\", T = \"ABC\"\n输出: \"BANC\"\n```\n\n**说明：**\n\n- 如果 S 中不存这样的子串，则返回空字符串 `\"\"`。\n- 如果 S 中存在这样的子串，我们保证它是唯一的答案。\n\n\n\n<br>\n\n题目的意思是，从s中找出包含T的字串，然后这个字串得最小，\n\n毫无疑问，这个子串的两边都是来自T里面的字符，\n\n我们需要做的是确定这个这个子串的起始位置，还有这个字串的长度，这样子我们就可以直接从母串S中返回这个子串，\n\n已经知道我们要用滑动窗口来做，滑动窗口是这样的，\n\n我们需要两个指针，这**两个指针代表的是窗口的边界**，\n\n他们的**差值就是窗口的长度，也是子串的长度**，\n\n**这个窗口并不是一开始就固定不变的**，\n\n因为我们并不能一开始就确定长度，所以这个窗口的长度是慢慢变大的，\n\n**在变大的同时也将纳入字符，**\n\n这时候我们还需要**两个哈希表**，\n\n**一个哈希表用来记录T里面字符的数量，表示我们的需求**，\n\n**另一个哈希表记录的是我们窗口里面出现我们需求字符的数量**，\n\n如果两者一致了，则说明这个窗口已经将我们所需求的全部字符纳入了，\n\n**这是一个合格的窗口，但它不是一个最短窗口**，\n\n我们需要缩短这个窗口的长度，前面我们说了，最短字串的两边一定是T里面的字符，\n\n所以此时右边界的字符一定是我们需求里面的最后一个字符，也就是右边界已经达到最大了，\n\n**但左边界还不一定，**\n\n这时候就需要我们移动左边界，当移动到我们需求的第一个字符的时候，就表示左边界达到了最大，\n\n这时候右边界和左边界的差值就是我们的所要求的字串长度。\n\n**但此字串长度未必是我们结果，**\n\n因为也许还会有更短的，所以我们需要**不断重复以上操作，去求所有结果里面的最小值**，才是我们最终的结果。 \n\n以上就是这道题的思路，上面详细叙述了整个过程，如果你还不是很懂，就看下面的图文吧！\n\n**needs 和 window是我们两个计数的哈希表，**\n\n**needs统计T中的字符数量，也就是我们的需求，**\n\n**window 统计此时窗口中我们需求字符的数量，**\n\n初始状态：\n\n![](https://note.youdao.com/yws/api/personal/file/WEBcc1ee51f59e44b2d870d71deedc90916?method=download&shareKey=9fa3bb714bd1fa1ff2346628a6a29145)\n\n增加right，直到窗口[left, right]包含了T中所有的字符，右边界此时达到最大，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB149f248ae0e025eb5613bc7d288f99f8?method=download&shareKey=8edbbd74bb5eba923076febb56ba294b)\n\n现在开始增加left，缩小窗口[left, right]，直到窗口的两边边界都为T中的元素，且窗口内的字符数量与需求的数量一致，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB71ca66d0ddb8c2a2047e058562e381c9?method=download&shareKey=b427e61936b81b5a37683937725d6583)\n\n继续移动窗口左边界，直到窗口不再合格\n\n![](https://note.youdao.com/yws/api/personal/file/WEBe10940e8d09765912e807277bd803641?method=download&shareKey=76ea3072a34ed526e317706ba8b3124e)\n\n之后重复以上过程，直到right 达到字符串 S的右边界，此时返回所有窗口的最小值。\n\n如果能够明白这些，我们可以尝试来写一下我们的伪代码：\n\n```java\n//两个字符串\nString s,t;\n\n//左边界和右边界\nint left = 0, right = 0;\nString res = s;\n\nwhile(right < s.length()) {\n    window.put(窗口的右边界);\n    right++;\n    如果窗口符合要求，此时移动左边界缩小窗口\n    while(window 符合要求) {\n        res = min(res, window);\n        将window里左边界对应的符合要求的字符数量置为0;\n        left++;\n    }\n}\nreturn res;\n```\n\n\n\n哈希表window中存放的是字符串t中的对应的字符的数量，而不是窗口中所有出现的字符的数量，这点明确，再加上上面的伪代码可以理解了，我们就可以直接写出我们的最终代码了。\n\n\n\n<br>\n\n\n#### 代码\n\n```java\nclass Solution {\n    public String minWindow(String s, String t) {\n        //两个哈希表用于计数\n        HashMap<Character, Integer> window = new HashMap<>();\n        HashMap<Character, Integer> need = new HashMap<>();\n        //左右边界\n        int left = 0;   \n        int right = 0;\n        //count用于统计window中的字符数量是否已经符合需求了\n        int count = 0;\n        //记录找到符合要求开始的字符位置\n        int start = 0;\n        int minlen = Integer.MAX_VALUE;\n        //将字符串t的字符统计出来，作为我们的需求\n        for(char c : t.toCharArray())\n            need.put(c, need.getOrDefault(c, 0) + 1);\n        //开始扩大窗口\n        while(right < s.length()) {\n            char c1 = s.charAt(right);\n            //如果此字符串是我们需求的字符串\n            if(need.containsKey(c1)) {\n                //则加入到window中\n                window.put(c1, window.getOrDefault(c1, 0) + 1);\n                //对比两个哈希表中此字符的数量，如果相等，说明此字符满足我们需求了\n                if(window.get(c1).equals(need.get(c1)))\n                    count++;\n            }\n            right++;\n            //当我们的需求的字符数量全部出现再这个窗口时，开始移动左边界缩小窗口\n            while(count == need.size()){\n                //如果窗口的大小小于最小值，则更新，并记录此时的位置，即窗口的开始的位置，也是字符串的开始位置\n                if(right - left < minlen) {\n                    start = left;\n                    minlen = right - left;\n                }\n                //此时判断左边界的字符是否为我们的需求\n                char c2 = s.charAt(left);\n                if(need.containsKey(c2)) {\n                    //如果符合，则将window中对应字符的数量减少\n                    window.put(c2, window.getOrDefault(c2, 0) - 1);\n                    //如果window中的字符数量已经少于需求数量，则count减少\n                    if((int)window.get(c2) < (int)need.get(c2))\n                        count--;\n                }\n                left++;\n            }\n        }\n        //返回字符串\n        return minlen == Integer.MAX_VALUE ? \"\" : s.substring(start, start + minlen);\n    }\n}\n```\n\n\n\n对于代码中有几处比较巧妙的地方，\n\n一个是：\n\n```java\nminlen = right - left;\n```\n\n窗口的长度等于right - left，这点母庸质疑，但其实这不是严格意义上的窗口位置，也就是说，right其实不是窗口的右边界，left也不是窗口的左边界，但是这样是没有错的。\n\n**因为在移动窗口的的时候，right和left都相应的加一，其实指向的是我们所认为的窗口边界的下一个字符。**\n\n第二个是：\n\n```java\nif((int)window.get(c2) < (int)need.get(c2))  count--;\n```\n\n此时用了（int）进行强转，**这里涉及到Integer的装箱拆箱的知识**，\n\n在没有加（int）的之前，面对相对比较短的字符串，没有问题，\n\n但测试案例中有很长的字符串，当字符数量大于128时，此时java的Integer是自动装箱，\n\n而Integer此时不能拆箱，所以要用（int）拆箱才能进行比较。\n\n第三个是：\n\n```java\nreturn minlen == Integer.MAX_VALUE ? \"\" : s.substring(start, start + minlen);\n```\n\n这里主要对结果的处理，利用String类里面的substring()方法返回字符串中想要的开始位置和长度。\n\n\n\n<br>\n\n### 找到字符串中所有的字母异位词\n\n给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。\n\n字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。\n\n**说明：**\n\n- 字母异位词指字母相同，但排列不同的字符串。\n- 不考虑答案输出的顺序。\n\n**示例 1:**\n\n```\n输入:\ns: \"cbaebabacd\" p: \"abc\"\n\n输出:\n[0, 6]\n\n解释:\n起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的字母异位词。\n起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的字母异位词。\n```\n\n **示例 2:**\n\n```\n输入:\ns: \"abab\" p: \"ab\"\n\n输出:\n[0, 1, 2]\n\n解释:\n起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。\n起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的字母异位词。\n起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。\n```\n\n\n\n<br>\n\n这道题和上面那道题是很相似的，如果看懂了上面那道题，其实完全可以做这道题了，\n\n我们再来分析一下这道题，\n\n找字串问题，首先想滑动窗口，\n\n在s中找出对应p的子串，但字母的顺序可以不同，返回每个子串开始的位置，\n\n那我们照样可以用两个哈希表来记录窗口中需求的字符数量和我们需求的字符数量，\n\n这道题和上道题不同，上道题窗口中可以有不是我们需求的字符，但这道题中窗口的字符一定是我们需求的字符才可以，\n\n所以我们只需要找到字符数量相等了，此时的起点位置就是我们的结果，我们需要用一个列表来记录我们的结果，\n\n结合以上，直接上代码了，\n\n\n\n#### 代码\n\n```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        //用一个列表来记录我们的结果\n        List<Integer> res = new ArrayList<>();\n        //两个哈希表用于计数\n        HashMap<Character, Integer> window = new HashMap<>();\n        HashMap<Character, Integer> need = new HashMap<>();\n        //左右边界\n        int left = 0;   \n        int right = 0;\n        //count用于统计window中的字符数量是否已经符合需求了\n        int count = 0;\n        //记录找到符合要求开始的字符位置\n        int start = 0;\n        //将字符串t的字符统计出来，作为我们的需求\n        for(char c : t.toCharArray())\n            need.put(c, need.getOrDefault(c, 0) + 1);\n        //开始扩大窗口\n        while(right < s.length()) {\n            char c1 = s.charAt(right);\n            //如果此字符串是我们需求的字符串\n            if(need.containsKey(c1)) {\n                //则加入到window中\n                window.put(c1, window.getOrDefault(c1, 0) + 1);\n                //对比两个哈希表中此字符的数量，如果相等，说明此字符满足我们需求了\n                if(window.get(c1).equals(need.get(c1)))\n                    count++;\n            }\n            right++;\n            //当我们的需求的字符数量全部出现再这个窗口时，开始移动左边界缩小窗口\n            while(count == need.size()){\n                //此时窗口的长度等于p的长度，则说明该窗口符合，加入到结果中\n                if(right - left == p.length()) {\n                    res.add(left);\n                }\n                //此时判断左边界的字符是否为我们的需求\n                char c2 = s.charAt(left);\n                if(need.containsKey(c2)) {\n                    //如果符合，则将window中对应字符的数量减少\n                    window.put(c2, window.getOrDefault(c2, 0) - 1);\n                    //如果window中的字符数量已经少于需求数量，则count减少\n                    if((int)window.get(c2) < (int)need.get(c2))\n                        count--;\n                }\n                left++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n<br>\n\n------\n\n整理完于2020.4.7，本文参考于 labuladong 的文章，文中图片源自 [labuladong的算法小抄](https://labuladong.gitbook.io/algo/)，只为学习而用，侵删。"
  },
  {
    "id": 23,
    "title": "LeetCode学习笔记——最长回文子串",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "LeetCode",
      "动态规划"
    ],
    "date": "2020-05-21",
    "abstract": "",
    "fileName": "LeetCode学习笔记——最长回文子串.md",
    "filePath": "/old_blogs/LeetCode学习笔记——最长回文子串.md",
    "mdContent": "\n最长回文字串，首先要明白子串和子序列的区别，子串是连续的，子序列不一定是连续的，而回文就是从左到右读，或者从右到左读都是一样的。\n\n\n\n题目的要求是在一个字符串中找出最长的那个回文子串，比如：\n\ns = “babad”\n\n最长回文子串就是 “bab”，  “aba\" 也是一个有效答案。\n\n而这道题我们应该怎么分析呢？\n\n我们分析回文子串，发现它其实是关于中心对称的，\n\n那我们就可以这样想了，是不是可以确定一个字符，将其作为中心，然后向两边延展，\n\n如果该字符的左右两边字符相同，那就继续延展，如果不同，就记录下此时长度。\n\n比如像这样，当以a为中心时，对比其左右两端，发现其相等，那就继续延展，而左边已经到达字符串头部，不能再继续延展，此时就要记录现在的长度。\n\n![](https://note.youdao.com/yws/api/personal/file/WEB4c73df405db462ba397ad71f4017daa9?method=download&shareKey=bd012d80f128d5756d1117b49ca1b0c9)\n\n**这就是中心扩散算法**，\n\n但很快我们就会发现问题，如果**仅凭**判断某个字符左右两端的字符是否相等来决定扩展，你会发现下面这种情况会被抛弃，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB8d09772d19678e7c42a152b7bd26293a?method=download&shareKey=437a5a3433c6de064034f2a237dc5ca1)\n\n而我们可以看的出来，该字符串的最长回文子串应该是 “babbab”，\n\n没错，我们刚刚把中心看成是一个字符，却忽略了中心是可以为多个相同字符的，\n\n所以我们要对将这种特殊性考虑进去，把这个看成第二种情况，\n\n**需要在延展判断之前先确定中心的字符**，\n\n![](https://note.youdao.com/yws/api/personal/file/WEBa1faaca59ea6521da688fdd7ff93d2c6?method=download&shareKey=c4ac6e018b1ec99af74d95fe5993f7f5)\n\n![](https://note.youdao.com/yws/api/personal/file/WEBc1d030bc17770947c264dcb043d4beba?method=download&shareKey=6a7a3ea8f1db53fd3e2b2f3392f69aca)\n\n这样子，当我们确定了中心字符后，就可以往两边扩展，\n\n当不能继续扩展的时候就将当前的长度与以记录的最长回文子串长度进行比较，\n\n**更新最长的长度，并记录此时子串的起始位置**\n\n因为最后我们的结果是返回一个字符串，当我们知道子串的起始位置和长度之后，就可以使用 **substring(index, index + len)** 截取子串\n\n中心扩散的代码就可以写出来了：\n\n```java\npublic String longestPalindrome(String s) {\n    //特判特殊情况\n    if (s == null || s.length() == 0) {\n        return \"\";\n    }\n    //左右两端的指针\n    int left = 0;\n    int right = 0;\n    //最长子串的起始位置\n    int maxStart = 0;\n    //最长子串的长度\n    int maxLen = 0;\n    //当前子串的长度，至少为一个字符\n    int len = 1;\n    for(int i = 0; i < s.length(); i++) {\n        //i为当前位置，left，right指向左右两端\n        left = i - 1;\n        right = i + 1;\n        //进行上述的第二种情况进行判断，找出中心的字符，如果左边相等就往左边去找，反之同理，当指针变动，此时的长度也要增加\n        while(left >= 0 && s.charAt(left) == s.charAt(i)) {\n            len++;\n            left--;\n        }\n        while(right < s.length() && s.charAt(right) == s.charAt(i)) {\n            len++;\n            right++;\n        }\n        \n        //当确定了中间的子串后，开始判断两端，进行延展，每延展一次，长度加2\n        while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            len += 2;\n            left--;\n        }\n        //将当前的子串长度与已记录的最长长度进行比较\n        if(len > maxLen) {\n            maxLen = len;\n            maxStart = left;\n        }\n        //初始化当前的子串长度\n        len = 1;\n    }\n    //截取子串，返回，因为maxStart是等于left的，而left总是比实际的子串开始位置下标少1\n    return s.substring(maxStart + 1, maxStart + maxLen + 1);\n }\n```\n\n中心扩散方法其实还有一种写法，\n\n上面我们讨论了中心字符的两种情况，第一种是中心是单独的一个字符，第二种是中心有多个相等的字符，\n\n如果将第二种情况分为中心有**奇数个相等的字符和偶数个相等的字符**。\n\n现在我们就对这种情况进行讨论，但有奇数个时候，如果为 1，我们就取这个作为我们的中心，如果是大于 1 的奇数，我们取最中间那个，因为左右两端一定相等，而如果是偶数个，如果是2，我们就取这两个，如果是大于 2 的偶数，我们只取最中心的两个作为中心。\n\n结合起来其实就是：\n\n```java\n//palindrome(s, left, right)为延展判断回文串的函数\n//i是当前位置\n\n//第一种，如果中心是奇数个时，我们吧左右指针都指向当前位置，然后再延展\nString s1 = palindrome(s, i, i);\n\n//第二种，如果中心是偶数个，我们取中间两个，左右指针分别指向这两个，然后再延展\nString s2 = palindrome(s, i, i + 1);\n```\n\n完整代码就是：\n\n```java\npublic String longestPalindrome(String s) {\n    if(s == null || s.length() == 0) {\n        return \"\";\n    }\n    //记录最长的回文子串\n    String res = \"\";\n    for(int i = 0; i < s.length(); i++) {\n    \tString s1 = palindrome(s, i, i);\n    \tString s2 = palindrome(s, i, i + 1);\n\t\t\n        res = res.length() > s1.length() ? res : s1;\n        res = res.length() > s2.length() ? res : s2;\n    }\n    \n    return res;\n}\n\n//延展判断回文子串\npublic String palindrome(String s, int left, int right) {\n    while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n        left--;\n        right++;\n    }\n    \n    //返回该子串\n    return s.substring(left + 1, right);\n}\n```\n\n<br>\n\n解决最长回文子串的方法除了有中心扩散方法，还有动态规划，动态规划是对暴力解法的优化。\n\n回文子串，当去掉两头后，还是回文子串，所以，当我们要确定一个子串是否为回文子串时，就需要两个东西：\n\n- 此时两端是否相等\n- 去掉两端后是否还为回文子串\n\n如果满足以上两个条件，此时的字串就是回文子串\n\n这就是我们的状态。\n\n状态就是此时 [i, j] 的子串是否为回文子串，\n\n```java\n如果是：dp[i][j] = true\n如果不是：dp[i][j] = false\n```\n\n而结合上面，我们的状态转移方程就可以推导出来了：\n\n```java\ndp[i][j] = dp[i + 1][j - 1] && s.charAt(i) == s.charAt(j)\n    \n//dp[i + 1][j - 1]就是去掉两端后的回文子串的状态\n```\n\n还需要确定几个细节问题，\n\n- 对于单独一个字符来说，肯定是回文子串，所以在初始化dp数组时，应该将\n\n  ```java\n  dp[i][i] = true\n  ```\n\n- 因为要去掉两端判断，当只有两个字符时，去掉后无法再进行判断，所以[i + 1, j - 1]的长度要大于等于2，即 j - 1 - (i + 1)  > 1,即 j - i > 3\n\n完整代码：\n\n```java\n public String longestPalindrome(String s) {\n     if(s == null || s.length() == 0) {\n         return \"\";\n     }\n     //创建dp数组\n     boolean dp[][] = new boolean[s.length()][s.length()];\n     //初始化数组\n     for(int i = 0; i < s.length(); i++) {\n         dp[i][i] = true;\n     }\n     int maxLen = 1;\n     int maxStart = 0;\n     //从列先开始遍历，因为对于当前的状态要参考于斜下角的\n     for(int j = 1; j < s.length(); j++) {\n         for(int i = 0; i < j; i++) {\n             //如果两端不相等，则为false\n             if(s.charAt(i) != s.charAt(j)) {\n                 dp[i][j] = false;\n             }\n             else {\n                 //如果两端相等，且当前的长度是小于2的，则直接可以判断为回文子串\n                 if(j - i < 3) {\n                     dp[i][j] = true;\n                 }\n                 //否则参考去掉两端后子串的状态\n                 else {\n                     dp[i][j] = dp[i + 1][j - 1];\n                 }\n             }\n             //更新结果\n             if(dp[i][j] && j - i + 1 > maxLen) {\n                 maxLen = j - i + 1;\n                 maxStart = i;\n             }\n         }\n     }\n     //截取结果返回\n     return s.substring(maxStart, maxStart + maxLen);\n }\n```\n\n"
  },
  {
    "id": 24,
    "title": "LeetCode学习笔记——最长子串（Sliding Window）",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "LeetCode",
      "滑动窗口"
    ],
    "date": "2020-04-02",
    "abstract": "",
    "fileName": "LeetCode学习笔记——最长字串（Sliding-Window）.md",
    "filePath": "/old_blogs/LeetCode学习笔记——最长字串（Sliding-Window）.md",
    "mdContent": "\n\n### Sliding Window\n\nSliding Window 也就是”滑动窗口“，通常用来求解一个字符串的字串。\n\n滑动窗口一般配合**哈希表**来使用，\n\n哈希表用来记录字符出现的次数，然后根据我们的需求的来处理这个字符。\n\n为什么叫滑动窗口？\n\n\n因为做题的方法感觉是一个**一定长度的格子**窗口，\n\n比如像这样：\n\n![](https://note.youdao.com/yws/api/personal/file/WEB6798a59ac608ac9843126ea329f81839?method=download&shareKey=dd3bb4cb760e520b8f6d2b180d810a3a)\n\n每个格子对应一个字符，然后设置判断条件，整个窗口一起移动，寻找我们所需要的东西。\n\n**但往往窗口的长度并不是固定的**，我们在题目中慢慢体会。\n\n\n\n<br>\n\n\n\n### 无重复字符的最长字串\n\n给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。\n\n**示例 1:**\n\n```\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n**示例 2:**\n\n```\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n\n**示例 3:**\n\n```\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n题目不难理解，一个字符串s，在s中找出一个子字符串，在字符串中没有重复的字符，返回符合情况的最长子字符串的长度。\n\n看到求子字符串，就应该想到滑动窗口。\n\n那这道题，怎么利用滑动窗口来做呢？\n\n以事例一为例说明：\n\n我们需要两个指针，**left 和 right** ，表示窗口的左边界和右边界，\n\n因为我们是去寻找最长的字串，所以我们的窗口应该从最小开始，慢慢变大，在窗口里面的就是我们要找的子串，\n\n注意，也就是说，一旦纳入我们的窗口，就是符合条件的字串，如果字符重复就不能纳入进来，\n\n我们需要利用哈希表来记录窗口里面字符出现的次数，\n\n一开始，窗口的长度为0，左边界右边界都指向第一个数，\n\n窗口内的字符是a，这时候哈希表 window 存入a出现的次数，\n\n![](https://note.youdao.com/yws/api/personal/file/WEBe1faf4636e86d3c54af38454153cc46a?method=download&shareKey=4b8a9f4df8f2e94911f83b2eae1cb65c)\n\n![](https://note.youdao.com/yws/api/personal/file/WEB39c5757ac45c9b9bc202d32d000b9f02?method=download&shareKey=09b599f326fd3eb59ab03cc6cfb3ef1c)\n\n\n\n![](https://note.youdao.com/yws/api/personal/file/WEB47a72e9edc1dd462760e33a90be68543?method=download&shareKey=ba1b601110c346ae286600e4721590fe)\n\n此时，我们纳入了第二个字符a，那这个窗口是不符合要求的，所以前面那个窗口就是我们要找的最大的窗口，\n\n这时候我们需要记录前一个窗口大小，也就是子字符串的长度，\n\n res = right - left，此时 res = 3，\n\n但是此时的结果还不是最终的结果，窗口的右边界right，还没有达到字符串s的最右边，\n\n说明字符串s还没有被遍历完，那就可能还有更长的情况，\n\n但现在我们遇到一个问题，此时窗口的右边界不能移动了，因为重复的字符纳入到我们的窗口里面，我们的这个窗口不符合题目要求了，如果再移动右边界没有任何意义，\n\n这时候我们应该移动左边界了，\n\n左边界的应该**移动到重复的那个字符串右边的第一个字符**，这样我们的窗口才有继续扩大下去的条件，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB808aa2557258b8ad3925f3f7de052aa2?method=download&shareKey=41742a9b8aa8b017f4278a047bcd93e6)\n\n此时，右边界才有移动下去的条件，那只需要再重复我们上面的操作就行，每次都记录下res，然后取最大的res返回即可。\n\n\n\n<br>\n\n如果明白了上面，我们就可以先来写写我们的伪代码：\n\n```java\nString s;// 我们的字符串\n\n此时left 和 right 都在最开始的地方\nwhile(right < s.length()) {\n\t将右边界对应的字符存入到哈希表\n    右边界增加 1\n    如果此时遇到重复字符\n    则进入移动左边界的循环\n    while(window.get(i) > 1) {\n        取出左边界的字符\n        将左边界的字符从window中删去\n        将左边界++\n        直到将窗口内所有字符的个数都是 1\n\t}\n    记录此时的窗口长度\n    更新res\n    return res;\n}\n```\n\n如果明白了这些，我们的代码就可以很容易写出来，\n\n有一点还需要注意的是，窗口长度是 right - left，而不是 right - left +1，\n\n因为在每次记录字符的数量的同时，窗口右边界都指向了此时下一位，在我们将重复字符纳入窗口的那一刻，我们就记录下了字串的长度了。\n\n\n\n<br>\n\n#### 代码\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n    \t//建立哈希表window记录窗口中字符的数量\n        HashMap<Character, Integer> window = new HashMap<>();\n        //窗口的左右边界\n        int left = 0;\n        int right = 0;\n        //记录我们的结果\n        int res = 0;\n        //右边界还没有到字符串s的右边界，说明res的结果还不是最终结果\n        while(right < s.length()) {\n        \t//取出右边界的字符，将其记录在window中\n            char c1 = s.charAt(right);\n            window.put(c1, window.getOrDefault(c1,0) + 1);\n            //记录字符的同时右边界也增加l\n            right++;\n            //遇到重复的字符，则开始移动左边界\n            while(window.get(c1) > 1) {\n                char c2 = s.charAt(left);\n                int temp = window.get(c2);\n                temp--;\n                window.put(c2,temp);\n                left++;\n            }\n            //取出窗口的最大值java\n            res = Math.max(res, right - left);\n        }\n        return res;\n    }\n}\n```\n\n"
  },
  {
    "id": 25,
    "title": "LeetCode学习笔记——机器人的运动范围",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "LeetCode",
      "DFS"
    ],
    "date": "2020-04-08",
    "abstract": "",
    "fileName": "LeetCode学习笔记——机器人的运动范围.md",
    "filePath": "/old_blogs/LeetCode学习笔记——机器人的运动范围.md",
    "mdContent": "\n\n机械人运动这类问题在做题的过程中遇到过好几次，\n\n大概类型就是给定一个初始位置，可以往多个方向走（一般是2个，即右下），\n\n有时候是4个方向（上下左右），\n\n然后求到右下角的最小路径，这类问题一般是采用动态规划来做，\n\n有时候可能会出现阻碍物，\n\n但机器人这道题就简化了很多，直接看题吧。\n\n\n### 机器人的运动范围\n\n地上有一个`m`行`n`列的方格，从坐标 `[0,0]` 到坐标 `[m-1,n-1]` 。一个机器人从坐标 `[0, 0]` 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。\n\n例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n\n<br>\n\n**示例 1：**\n\n```\n输入：m = 2, n = 3, k = 1\n输出：3\n```\n\n**示例 2：**\n\n```\n输入：m = 3, n = 1, k = 0\n输出：1\n```\n\n**提示：**\n\n- `1 <= n,m <= 100`\n- `0 <= k <= 20`\n\n\n\n<br>\n\n#### 解题思路\n\n题目和我们一开始分析的那样，\n\n机器人的位置在m行n列方格的左上角开始，\n\n但目标不是右下角了，而是移动当坐标的数位之和大于k后就不能继续移动了，\n\n这道题有个隐藏的条件，\n\n题目说可以上下左右移动，我觉得有一定的误导，这道题只要两个方向就可以了，\n\n**因为机器人的初始位置在左上角，只要向右或者向下两个方向就行了，**\n\n对于每个点，只要满足三个条件，就可以继续进行两个方向的选择，\n\n- **该点还没被访问过**\n- **该点的数位之和小于等于k**\n- **该点不在边界**\n\n对于该点是否被访问，我们可以用一个boolean型的数组记录该点的访问状态，被访问后就变为true，\n\n对于该点的数位之和，我们可以写一个函数专门计算数位的和，\n\n```java\n//传入坐标信息\npublic int sums(int x, int y) {\n    //记录结果\n    int ans = 0;\n    //一直取x的个位数加到结果里面，直到x为0\n    while(x != 0) {\n        ans += x % 10;\n        x /= 10;\n    }\n    //一直取y的个位数加到结果里面，直到y为0\n    while(y != 0) {\n        ans += y % 10;\n        y /= 10;\n    }\n    return ans;\n}\n```\n\n对该点是否在边界，如果在右边界，就只能向下运动，如果在下边界，就只能向右运动，其他边界无需考虑，\n\n**本题可以使用深度优先搜索和广度优先搜索来做**，\n\n深度优先搜索就是对每一个方向都递归前进，\n\n广度优先搜索要采用队列来记录合格的点信息，还需要对方格进行抽象坐标化，\n\n具体我们看代码。\n\n\n\n<br>\n\n#### 代码\n\n- 深度优先搜索\n\n```java\nclass Solution {\n    int m, n, k;\n    public int movingCount(int m, int n, int k) {\n        this.m = m;\n        this.n = n;\n        this.k = k;\n        //每个方格的访问状态初始为false\n        boolean [][]visited = new boolean[m][n];\n        //从坐标（0,0）开始\n        return dfs(0, 0, 0, visited);\n    }\n    //深度优先搜索\n    public int dfs(int i, int j, int sum, boolean [][]visited) {\n        //如果此时i和j已经超过边界，或数位之和大于k，或者该方格已经被访问，递推回归\n        if(i == m || j == n || sum > k || visited[i][j])\n            return 0;\n        //将该方格（坐标）的访问状态改为已访问\n        visited[i][j] = true;\n        //从两个方向进行递推，i+1表示向下，j+1表示向右\n        return 1 + dfs(i + 1, j, sums(i + 1, j), visited) + dfs(i, j + 1, sums(i, j + 1), visited);\n    }\n    \n    //进行计算坐标的数位之和\n    public int sums(int x, int y) {\n        //记录结果\n        int ans = 0;\n        //一直取x的个位数加到结果里面，直到x为0\n        while(x != 0) {\n            ans += x % 10;\n            x /= 10;\n        }\n        //一直取y的个位数加到结果里面，直到y为0\n        while(y != 0) {\n            ans += y % 10;\n            y /= 10;\n        }\n        return ans;\n\t}\n}\n```\n\n\n\n<br>\n\n- 广度优先搜索\n\n```java\nclass Solution {\n    public int movingCount(int m, int n, int k) {\n        //用于储存坐标信息的队列，储存的都是符合要求的坐标\n        Queue<Point> queue = new ArrayDeque<>();\n        //每个方格的访问状态初始为false\n        boolean[][] visited = new boolean[m][n];\n        //队列先加入起点位置\n        queue.add(new Point(0, 0));\n        visited[0][0] = true;\n        //统计能访问点的数量\n        int count = 0;\n        while(!queue.isEmpty()) {\n            //取出队首的坐标\n            Point curPoint = queue.poll();\n            count++;\n            //如果下一个点不超过边界，且数位和不超过k，且该点未被访问过\n            if(curPoint.x + 1 < m && sums(curPoint.x + 1, curPoint.y) <= k && !visited[curPoint.x + 1][curPoint.y]) {\n                //将该点加入到队列中\n                queue.add(new Point(curPoint.x + 1, curPoint.y));\n                //访问状态改为已访问\n                visited[curPoint.x + 1][curPoint.y] = true;\n            }\n            if(curPoint.y + 1 < n && sums(curPoint.x, curPoint.y + 1) <= k && !visited[curPoint.x][curPoint.y + 1]) {\n                queue.add(new Point(curPoint.x, curPoint.y + 1));\n                visited[curPoint.x][curPoint.y + 1] = true;\n            }\n        }\n        return count;\n    }\n    \n    //进行计算坐标的数位之和\n    public int sums(int x, int y) {\n        //记录结果\n        int ans = 0;\n        //一直取x的个位数加到结果里面，直到x为0\n        while(x != 0) {\n            ans += x % 10;\n            x /= 10;\n        }\n        //一直取y的个位数加到结果里面，直到y为0\n        while(y != 0) {\n            ans += y % 10;\n            y /= 10;\n        }\n        return ans;\n\t}\n}\n\n//抽象坐标类\nclass Point {\n    int x;\n    int y;\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n```\n\n<br>\n\n------\n\n整理于2020.4.9"
  },
  {
    "id": 26,
    "title": "LeetCode学习笔记——水果成篮（Sliding-Window）",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "LeetCode",
      "滑动窗口"
    ],
    "date": "2020-04-17",
    "abstract": "",
    "fileName": "LeetCode学习笔记——水果成篮（Sliding-Window）.md",
    "filePath": "/old_blogs/LeetCode学习笔记——水果成篮（Sliding-Window）.md",
    "mdContent": "\n### 前言\n\n滑动窗口之前已经写过几篇笔记了，懂了滑动窗口的套路，以后就可以就着这个模板进行更改了，\n\n今天这一道题，可能一下子并不能想到使用滑动窗口来做，但接着分析一下，其实发现非常符合滑动窗口思想，\n\n如果想了解解决滑动窗口问题的套路，可以参考一下我这两篇笔记，大家一起学习交流，如果有错希望大佬不吝赐教！\n\n[LeetCode学习笔记——最长子串（Sliding Window）](https://waiterxiaoyy.github.io/2020/04/02/LeetCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2%EF%BC%88Sliding-Window%EF%BC%89/)\n\n[LeetCode学习笔记——最小覆盖串/字母异位词（Sliding Window)](https://waiterxiaoyy.github.io/2020/04/05/LeetCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E4%B8%B2-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%EF%BC%88Sliding-Window%EF%BC%89/)\n\n\n\n<br>\n\n<!--more-->\n\n### 水果成篮\n\n在一排树中，第 i 棵树产生 tree[i] 型的水果。\n你可以从你选择的任何树开始，然后重复执行以下步骤：\n\n1. 把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。\n2. 移动到当前树右侧的下一棵树。如果右边没有树，就停下来。\n\n请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。\n\n你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。\n用这个程序你能收集的水果总量是多少？\n\n**示例 1：**\n\n```\n输入：[1,2,1]\n输出：3\n解释：我们可以收集 [1,2,1]\n```\n\n**示例 2：**\n\n```\n输入：[0,1,2,2]\n输出：3\n解释：我们可以收集 [1,2,2].\n如果我们从第一棵树开始，我们将只能收集到 [0, 1]。\n```\n\n**示例 3：**\n\n```\n输入：[1,2,3,2,2]\n输出：4\n解释：我们可以收集 [2,3,2,2].\n如果我们从第一棵树开始，我们将只能收集到 [1, 2]。\n```\n\n**示例 4：**\n\n```\n输入：[3,3,3,1,2,1,1,2,3,3,4]\n输出：5\n解释：我们可以收集 [1,2,1,1,2].\n如果我们从第一棵树或第八棵树开始，我们将只能收集到 4 个水果。\n```\n\n\n\n<br>\n\n\n\n#### 解题思路\n\n这道题题目一看上去确实让人有点懵，其实他的意思是，\n\n给定一个数组，数组中存在着不同值的数字，每种数字代表一种类型的水果，注意，这里是类型，不是数量，比如tree[i] = {1, 2}, 1 代表 1 型水果，2代表2型 水果，数组中数字的频率代表该类型水果的数量，仅此而已。**水果类型的数量和某种水果类型的数量，这两者需要分清。**\n\n**可以从数组任何位置出发，且只能往右边走**，每走过一棵树，就把水果放进篮子，你只有两个篮子，也就是**最多只能装两种类型的水果**，**当你走到第三种类型的水果或者走到数组末尾时**，就要停下来，求从哪里开始能装最多的水果。\n\n为什么说这道题符合滑动窗口的思想呢？因为其实在搜索的过程中，就是一个变动窗口，**窗口的左边界就是开始的位置，右边界就是到达了临界条件**。\n\n临界条件是什么？\n\n- **当遇到第三种类型的水果**\n- **当到达数组末尾**\n\n此时右边界减去左边界，就是水果的总量。\n\n滑动窗口一般配合哈希表来做，哈希表用来记录窗口中出现的每种类型水果的数量（也就是每种数字的频率）。\n\n\n\n我们需要两个指针 left 和 right 作为窗口的边界，用**哈希表 window** 来记录窗口中的水果类型及其数量，用 **count** 来记录窗口中水果类型数量，**maxlen** 为窗口的最大长度，将作为结果返回。\n\n\n\n一开始，窗口的大小为 0， left 和 right 都指向数组首位，window 将right 指向的水果类型记录下来，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB8880999b8d68d7c4b4575b664c42bb6a?method=download&shareKey=b3f03fd4fa884f4a54b898513e94d8b2)\n\nright 移动，window 继续记录，如果之前window 中存在该类型的水果，就在原来的基础上增加，\n\n![](https://note.youdao.com/yws/api/personal/file/WEBb19e5433ea985e27a21e42f6020152fd?method=download&shareKey=d3a80fc4562ea942f60f243122b18354)\n\nright 继续移动，window 继续记录，当前窗口中水果的类型为 [1, 2], 所以count为2，因为窗口中水果的类型达到了2，为最大类型数量，此时可以更新窗口长度，\n\n![](https://note.youdao.com/yws/api/personal/file/WEBd0cb8cde8103041682474089fb172a81?method=download&shareKey=2ac56baaaa454c7dcd2b24f8a150f7f8)\n\nright 继续移动，此时窗口内水果类型的数量仍然为 2，则窗口的长度需要更新，\n\n![](https://note.youdao.com/yws/api/personal/file/WEBde258857f8cd21c0db44b889510bbbb4?method=download&shareKey=c42e0634a6fcff24872bc70da3711086)\n\n当right继续移动，此时遇到第三种类型的水果，但因为窗口中水果类型数量已经达到最大，那么这个类型的水果不能被装进窗口，但window会将其记录下来，此时需要移动左边界 left 缩小窗口，\n\n![](https://note.youdao.com/yws/api/personal/file/WEBe3545645623a7f62ce6616bc2efd56c0?method=download&shareKey=7368dfd02f35c59729d4bbcf54fff5e3)\n\n![](https://note.youdao.com/yws/api/personal/file/WEBe861828f7d29d8bf136aa828b339fdc7?method=download&shareKey=2dbdcd0bb404a92d85c13216cf4f4226)\n\n移动左边界的目的是为了寻找新的窗口，寻找新的窗口的前提，是要将窗口恢复到具有可扩大的状态，条件就是要窗口的水果类型小于等于 2，移动左边界，直到原窗口中的某一种类型的水果的数量为 0，则说明该窗口中没有这种类型的水果了，\n\n![](https://note.youdao.com/yws/api/personal/file/WEBa6696c3e24fd5e4ee81c089f8d42722a?method=download&shareKey=d314faa0abff0b96c210227351918119)\n\n此时新窗口开始了，将新窗口的长度和 maxlen 进行比较，如果更大，则更新窗口。\n\n直到 right 到达数组末尾前，以上过程都将继续。\n\n![](https://note.youdao.com/yws/api/personal/file/WEB43131bf3d425bb7624e0d1bed1285a57?method=download&shareKey=a995c82345603f131429d8359c27cc75)\n\n\n\n\n\n经过以上过程，如果能够理解，应该已经可以把这道题敲下来了，接下来总结一下伪代码，以便能把上面的过程转换成代码。\n\n```java\n# tree[]\n# window<Integer, Integer>\n# count = 0\n# maxlen = 0\n\nwhile(right < tree.length) {\n    if(window不存在当前类型)\n        count++;//类型加1\n    将right所指的类型存入window;\n    right++;\n    窗口比较，更新窗口;\n    while(count > 2) {\n        //缩小窗口\n        将left所指的移除window;\n        left++;\n    }\n}\n```\n\n\n\n<br>\n\n接下来就是转成代码了，有一个地方需要注意的是，在缩小窗口的时候，某种类型的水果的数量会减为0，但不代表该 Key 值被移除哈希表，所以在窗口扩大的时候，对right所指的水果类型进行判断时，要多判断其是否在window中为0的情况，如果为0，也看作是一种新类型的水果。\n\n\n\n<br>\n\n#### 代码\n\n```java\nclass Solution {\n    public int totalFruit(int[] tree) {\n        //创建哈希表记录水果类型及其数量\n        HashMap<Integer, Integer> window = new HashMap<>();\n        //水果类型数量\n        int count = 0;\n        //左右边界\n        int left = 0;\n        int right = 0;\n        //最大长度（也是水果总量的最大值）\n        int maxlen = 0;\n        //进入循环\n        while(right < tree.length) {\n            //如果这是一种新类型的水果，count+1\n            if(!window.containsKey(tree[right]) || window.get(tree[right]) == 0)\n                count++;\n            //将right所指记录在window中\n            window.put(tree[right], window.getOrDefault(tree[right], 0) + 1);\n            right++;\n            //实时更新长度\n            if(count <= 2) {\n                if(right - left > maxlen) {\n                    maxlen = right - left;\n                }\n            }\n            //遇到第三种类型，开始缩小窗口\n            while(count > 2) {\n                //将left所指的水果类型数量 - 1\n                window.put(tree[left], window.getOrDefault(tree[left], 0) - 1);\n                //如果某种水果类型的数量变为0，则水果类型数量count--\n                if(window.get(tree[left]) == 0)\n                    count--;\n                left++;\n            }\n        }\n        return maxlen;\n    }\n}\n```\n\n"
  },
  {
    "id": 27,
    "title": "LeetCode学习笔记——石子游戏（动态规划）",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "LeetCode",
      "动态规划"
    ],
    "date": "2020-03-15",
    "abstract": "",
    "fileName": "LeetCode学习笔记——石子游戏（动态规划）.md",
    "filePath": "/old_blogs/LeetCode学习笔记——石子游戏（动态规划）.md",
    "mdContent": "\n\n\n博弈类问题感觉也是一种脑脑急转弯的题，\n\n博弈类题目其实都有非常巧妙的解法，\n\n但我们学习还是以 **稳** 为准，不追求那些花里胡哨的做法，\n\n今天，我们从石子游戏入手，去探究一下博弈类问题的奥妙。\n\n\n\n<br>\n\n<!--more-->\n\n### 石子游戏\n\n亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。\n\n游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。\n\n亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。\n\n假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。\n\n\n\n**示例：**\n\n```\n输入：[5,3,4,5]\n输出：true\n解释：\n亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。\n假设他取了前 5 颗，这一行就变成了 [3,4,5] 。\n如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。\n如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。\n这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。\n```\n\n**提示：**\n\n1. `2 <= piles.length <= 500`\n2. `piles.length` 是偶数。\n3. `1 <= piles[i] <= 500`\n4. `sum(piles)` 是奇数。\n\n\n\n<br>\n\n#### 解题思路\n\n题目很长，你可以直接跳过上面，从这里开始读起，\n\n你和你的朋友在一起玩游戏，有若干堆石子在你们面前，每堆石子的数量用 piles[i] 表示，每次只能从石子堆的两侧拿，你们都很精明，每次只能拿两侧的石子，然后看谁多谁赢，题目要求如果亚历克斯赢就返回true。\n\n现在，我们为了能够获得博弈问题的解题套路，我们把这道题目进行变换一下，使的题目能够更具“一般性”，不用管题目中的亚历克斯和李，变换后其实就是一个**先手和后手**的问题，肯定有一个人先开始拿，有一个人后开始拿，这就是博弈问题的特点，变换后，我们也不管亚里斯赢不赢了，我们**求先手和后手的石子数量的差**，如果先手开始的到最后的石子数量大于后手的石子数量，就是先手赢，也是这道题的意思。\n\n好，现在我们明确了题目，我们这时候要开始来分析一下解题思路，这种题我们可以用**动态规划**来做，动态规划的解题方法是是什么？\n\n找出 **状态** 和 **选择**。动态规划的状态其实是很难判断的，判断出状态，然后列出状态转移方程，这也是动态规划中最难的部分。而选择就很简单了，因为不管先手还是后手，只能从上一个人选完剩下的石子堆的两侧进行选择，**选择左侧还是右侧的石子就是选择**。\n\n选择我们确定了，状态呢？状态一下子是看不出来的，我们要深入到题目里面去，我们知道动态规划还有一个特点，就是求 **最优解子问题**，我们把所有求的最后的结果分解到子问题中去求解，\n\n比如给一堆石子 ：piles = [5, 3, 7, 1]，索引从 1 到 4，\n\n我们要求这堆石子的两人的石子数差，就是看子问题的石子数差，那问题来了，子问题是什么呢？\n\n不急，我们再来思考一下，\n\n假如，先手取了第一堆石子，那石子堆就只剩下了 piles=[3, 7, 1]，这时就到了我们所谓的后手拿，后手也只能从两侧拿，如果拿了第二堆，那石子堆只剩下 piles=[7, 1]，这时候又到我们的先手了，选择第三堆，那剩下就是后手拿了，最后先手的石子数量时 5 + 7，后手的数量 3 + 1，这次是先手胜，可能有同学注意到了，先手之所以能 5 + 7，是因为一开始选择了第一堆，那如果一开始选择的是最后一堆呢，结果可能就会有所变化，\n\n所以通过这样具体分析后，子问题就出来了，当选手做出选择后，会出现两种情况，piles = [3, 7, 1], 或者是 piles = [5, 7, 3], 所以 每次选择都很重要，你一次糊涂选择会导致全盘皆输，但题目有要求，每个人都很精明，所以不可能会有糊涂选择，**每次选择都是最佳的选择**，而我们就是要找出这个最佳情况，那这个最佳是依靠什么判断出来呢？就是子问题，要看这次选择的是不是最佳，就看这次选择后的子问题的选择的情况，一直这样伸展下去，直到石子都被分完。\n\n所以，这时候我们的状态就出来了，**一个是石子堆的范围**，就是从第几堆到第几堆的最佳情况，在 piles = [5, 3, 7, 1]，要求第一堆到第四堆的最佳情况，就是求 选择完后的子问题，比如 [3, 7, 1]，也就是第二堆到第四堆的最佳状况，**第二个是当前选择的人**，这两个状态就是我们用动态规划所需要展示出来的。\n\n我们需要一个二维数组 `dp[i][j]`, 用来表示第 i 堆石子到第 j 堆石子的最佳情况，还需要一个表示当前选择的人，我们用 first 和second 表示，像这样 `dp[i][j].first`,`dp[i][j].second`,表示第 i 堆石子到第 j 堆石子谁先开始选择，注意这里说的是 先开始，上面我们说的先手开始选后，那剩下的石子堆对于后手来说也是先开始，要理解这里。\n\n接着讲状态和选择，转换成状态转移方程，\n\n```java\n# 对于先手来说\ndp[i][j].first = max(选择左侧的石子堆， 选择右侧的石子堆);\ndp[i][j].first = max(piles[i] + dp[i + 1][j].second, piles[j] + dp[i][j - 1].second);\n# 如果先手先选择了左侧的石子堆，那么剩下的石子堆范围就变成了[i+1, j]，由后手来先开始选择\n# 如果先手先选择了右侧的石子堆，那么剩下的石子堆范围就变成了[i, j + 1]，由后手来先开始选择\n# 最后取两者的最大值，也就是最佳情况\n    \n# 对于后手来说\nif 先手选择了左侧:\n    dp[i][j].second = dp[i+1][j].first;\nif 先手选择了右侧:\n\tdp[i][j].second = dp[i][j + 1].first;\n# 我是后手，我需要等先手先做出选择\n# 如果先手选择了左边，那剩下的石子堆范围就变成了[i+1, j]，这时候我变成了先手\n# 如果先手选择了右边，那剩下的石子堆范围就变成了[i, j + 1]，这时候我变成了先手\n```\n\n状态转移方程写出来了，接下来就是要确定我们的初始状态，\n\n初始状态是i 和 j 相等，也就是当面前只有piles[i]这一堆石头的时候，\n\n```\ndp[i][j].first = piles[i];\ndp[i][j].second = 0;\n# 当只有一堆石头的时候，先手拿了，后手就没有了\n```\n\n初始状态，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB588fcdb68e38d4e0ecebe9761d1aff4c?method=download&shareKey=8677e981960eb4f3931572632914c11a)\n\n\n\n在石子堆0~1中，（5,3）的子问题是（5,0）和（3,0），当先手选择了5，那后手只剩下了3，\n\n\n\n![](https://note.youdao.com/yws/api/personal/file/WEB898d7c6f4b1dfaa12af872517d5f6707?method=download&shareKey=0f494abececcd68deb89214c22cde4a5)\n\n对于石子堆0~2中，（10,5）的子问题是（5,3）和（7,3），根据状态转移方程，当先手选择了7，后手选择了5，只剩下3，所以先手是10，后手是5，\n\n对于石子堆0~3，（12,4）的子问题是（10,5）和（4，7）分别对应选择右边和左边，,在选择左右两边中判断，发现当先先选择左边的5，剩下中后手先选能达到的最大是7，所以加起来是12，后手选的是4，\n\n![](https://note.youdao.com/yws/api/personal/file/WEBb271d8c8b8ea1a83d6777bcd541d8632?method=download&shareKey=d415a6fa06d633c4c04bd05133440ec9)\n\n\n\n<br>\n\n相信经过上面一大串啰嗦的分析，应该能对石子游戏有一定的认识了，在看代码之前，先解释一下first和second如何定义，我们可以弄一个类将其封装起来，在后面只需要创建它的实例就可以了，\n\n```java\nclass Pair {\n  \t//代表先手\n    int first;\n    //代表后手\n    int second;\n    Pair(int fisrt, int second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n```\n\n接下来我们看看代码吧。\n\n\n\n<br>\n\n#### 代码\n\n```java\nclass Solution {\n    public boolean stoneGam\te(int[] piles) {\n        //石子堆的长度\n        int len = piles.length;\n        //创建pair的实例，同时初始化二维数组\n        Pair[][] dp = new Pair[len][len];\n        for(int i = 0; i < len; i++) {\n            for(int j = i; j < len; j++) {\n                dp[i][j] = new Pair(0, 0);\n            }\n        }\n        //将初始值填入\n        for(int i = 0; i < len; i++) {\n            dp[i][i].first = piles[i];\n            dp[i][i].second = 0;\n        }\n\t\t//l代表的是石子堆的数量，从两堆开始\n        for(int l = 2; l <= len; l++) {\n            //i代表的是石子堆范围的左侧索引\n            for(int i = 0; i <= len - l; i++) {\n                //j代表的是石子堆范围的右侧索引\n                int j = i + l - 1;\n                //left表示选择左侧石子能达到的最佳状态\n                int left = piles[i] + dp[i + 1][j].second;\n                //右侧表示选择右侧石子能达到的最佳状态\n                int right = piles[j] + dp[i][j - 1].first;\n                //如果选择左侧大于选择右侧，则将在该范围的情况下先手的值更新为left，且后手的数量时等于在[i+1,j]范围中作为先手所能获得的最佳数量，否则反之\n                if(left > right) {\n                    dp[i][j].first = left;\n                    dp[i][j].second = dp[i + 1][j].first;\n                }\n                else {\n                    dp[i][j].first = right;\n                    dp[i][j].second = dp[i][j - 1].first;\n                }\n            }\n        }\n        //返回两者的差值\n        return dp[0][n - 1].first - dp[0][n - 1].second;\n        //本题的结果，比较是否先手会大，否则返回false\n        //return dp[0][len - 1].first > dp[0][len - 1].second;\n    }\n}\n```\n\n\n\n<br>\n\n------\n\n整理于2020.4.15，有参考于labuladong大佬的讲解。"
  },
  {
    "id": 28,
    "title": "LeetCode学习笔记——统计优美子数组（Sliding Window）",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "LeetCode",
      "滑动窗口"
    ],
    "date": "2020-04-21",
    "abstract": "",
    "fileName": "LeetCode学习笔记——统计优美子数组（Sliding-Window.md",
    "filePath": "/old_blogs/LeetCode学习笔记——统计优美子数组（Sliding-Window.md",
    "mdContent": "\n### 前言\n\n已经在LeetCode刷了两百多道题了，带来的感受肯定跟一个多月前是不一样的，但做题能力实际上没增加多少。现在如果看到题目，读懂题了基本都能判断出属于哪种类型的题，然后应该用什么方法做，这一点我觉得也是一种进步吧。毕竟来LeetCode的初心并不是为了准备面试，而是为了培养自己的思维，然后熟悉各式各样的算法结构和应用，这点我觉得自己做到了。\n\n今天记录的是一道打卡题，一开始看到这道题，马上就能想到用滑动窗口来做，我本来是想用基本套路解决的，发现没那么简单，需要转换一下思想。\n\n\n### 统计优美子数组\n\n给你一个整数数组 `nums` 和一个整数 `k`。\n\n如果某个 **连续** 子数组中恰好有 `k` 个奇数数字，我们就认为这个子数组是「**优美子数组**」。\n\n请返回这个数组中「优美子数组」的数目。\n\n**示例 1：**\n\n```\n输入：nums = [1,1,2,1,1], k = 3\n输出：2\n解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [2,4,6], k = 1\n输出：0\n解释：数列中不包含任何奇数，所以不存在优美子数组。\n```\n\n**示例 3：**\n\n```\n输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2\n输出：16\n```\n\n\n\n<br>\n\n#### 解题思路\n\n对于`nums = [1,1,2,1,1]，k = 3`，我们一下子就可以判断出两个子数组是 [1,1,2,1] 和 [1,2,1,1] ，但对于 `[2,2,2,1,2,2,1,2,2,2]， k = 2` 这么长的数组来说，一下子看上去可不能很快得出答案。\n\n一般的，我们解决滑动窗口问题的套路是搞两个指针，一开始都指向首位，然后右指针开始移动扩大窗口，然后再左指针缩小窗口。\n\n但这道题不是，这道题应该先要确定窗口的大小，然后向两边扩展，那窗口的大小怎么确定呢？\n\n对于 `[2,2,2,1,2,2,1,2,2,2]， k = 2` ， 我们知道符合条件的最小长度的子数组是 [1,2,2,1]，往左边扩展可以扩展三位（还可以不扩展），所以一共是4种情况，右边扩展同样是四种情况，所以最后的总的子数组是 4 * 4 = 16。\n\n但实际上我们还是确定不了窗口的边界，我们做题毕竟不是看出来的，还是要深究其中的原理，我们可以这样子做，\n\n先取出数组中所有奇数值的下标，\n\n我们另取一个更具一般性的例子进行说明 `nums = [2, 1, 5, 6, 7, 3, 4, 9, 8], k = 3`,这个例子想一眼看出来还真的不那么容易，像我们上面所说，取出所有奇数值的下标，\n\n取出后是这样子的，橙色部分储存奇数值下标，你可能发现了，index数组的首尾和后面分别是 -1 和 数组的长度，你先不管这里，后面会进行说明，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB965986842b6be51a36506584b83f52c4?method=download&shareKey=52dd2e94ea82675341e6a17645eda335)\n\n当我们根据k进行划定窗口的时候，首先是在 index 里面划定边界，比如\n\n![](https://note.youdao.com/yws/api/personal/file/WEB71f1077404caf319e05c1635fba2063d?method=download&shareKey=f764fce0b33cb36e8cbcce140f7d6dc7)\n\n此时窗口边界就确定了，左右边界对应的下标是 [1, 4]，那在数组 nums 中对应的就如黄色区域，\n\n黄色区域就代表包括 `1,5,7`三个奇数在内的最小长度的子数组，也叫做最小窗口，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB3db2c6faae9a0d11a6b3687c8b572708?method=download&shareKey=e1d509d22b39e3e35637e8a55b9fb123)\n\n此时该窗口是可以扩展的，但扩展是有条件限制的，并不能无限扩展，当扩展到数组边界时，或者将要把第四个奇数纳入到窗口中，就应该停下来，所以对于该窗口，可以往左边扩展将 2 纳入，但右边不能再继续扩展，像这样\n\n![](https://note.youdao.com/yws/api/personal/file/WEBc4b9f652983b86fc342ffac4c7579baa?method=download&shareKey=e78db2373acd11432f6bd60776f36fcd)\n\n那么包括 `1,5,7`的子数组的数量应该是多少呢？\n\n应该为 2 * 1 = 2，一共是两个，往左边有两种选择，**扩展1位或者不扩展**，右边就只有选择不扩展一种情况。\n\n还记得index数组首位的 -1 吗，它的作用就是代表着不扩展这种情况，奇数 1 对应的下标 1 代表着是左边还有 1 个位置可以扩展，所以计算左边可以计算， `index[1] - index[0] = 2`，窗口最右边的奇数是 7，对应下标是4，处在`index[3]`，往右边直到遇到第四个奇数，都是可以继续扩展的，那第四个奇数的对应下标减去4就是窗口的数量，如 `index[4] - index[3] = 1`，就是右边可扩展的情况\n\n好，刚刚我们讨论的是包括`1,5,7`的情况，但我们奇数还没完，此时 index 数组中的窗口要继续移动，\n\n接着要讨论包括 `5,7,3`的情况，像这样\n\n![](https://note.youdao.com/yws/api/personal/file/WEB1f6630fee5cdfd4b7d8fd8e9e56eb7ae?method=download&shareKey=a4d326be53caad50e94224bbe2164768)\n\n包括`5,7,3`的情况按照以上的步骤进行讨论就行，\n\n但`7,3,9`处在边界就特殊一点，\n\n![](https://note.youdao.com/yws/api/personal/file/WEBf2f77c7db1e2d401b18641c2bbd945ce?method=download&shareKey=aa04894d63b05732869276c2fafeac6c)\n\n左边同理，扩展到不能扩展为止，往左边会扩展到奇数 5 处停下，所以左边的子数组数量是 4 - 2 = 2，而右边会遇到数组的边界，奇数 9 对应的数组下标是 7，数组长度减去 7，即 9 - 7= 2，当然，我们都是在index 数组中进行操作，所以在index数组中对应的就是 `index[6] - index[5] = 9 - 7 = 2`，所以index数组中最后面一个元素是数组的长度的原因就在这。\n\n\n\n<br>\n\n#### 代码\n\n```java\nclass Solution {\n    public int numberOfSubarrays(int[] nums, int k) {\n        //创建储存奇数下标的数组\n        int []index = new int[nums.length + 2];\n        //j作为移动的指针，因为index数组的首位等于 -1，所以从 1 开始\n        int j = 1;\n        //录入奇数在nums中的下标\n        for(int i = 0; i < nums.length; i++) {\n            if(nums[i] % 2 != 0) {\n                index[j++] = i;\n            }\n        }\n        //数组的首位为 -1，后面（不是末尾）为数组长度\n        index[0] = -1;\n        index[j++] = nums.length;\n        int res = 0;\n        //i 从index 下标 1 开始，j 是当前 index 里面存有值的长度， i + k代表窗口\n        for(int i = 1; i + k < j; i++) {\n            //计算当前包括k个奇数的子数组的数量\n            res += (index[i] - index[i - 1]) * (index[i + k] - index[i + k - 1]);\n        }\n        return res;\n    }\n}\n```\n\n​\t\n\n<br>\n\n------\n\n整理于2020.4.21"
  },
  {
    "id": 29,
    "title": "LeetCode学习笔记——编辑距离（动态规划）",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "LeetCode",
      "动态规划"
    ],
    "date": "2020-03-26",
    "abstract": "",
    "fileName": "LeetCode学习笔记——编辑距离（动态规划）.md",
    "filePath": "/old_blogs/LeetCode学习笔记——编辑距离（动态规划）.md",
    "mdContent": "\n\n\n被动态规划折磨了这么久，今天总算是可以说有点手感了，\n\n编辑距离也算是动态规划里面比较经典的，\n\n当拿到题目的时候，也是很懵的，不愧是困难程度，\n\n但如果按照动态规划的套路来分析问题，\n\n或许能清晰一点，\n\n动态规划的套路是什么？\n\n分清**状态**和**选择**。\n\n\n\n**我们先来看一下题目：**\n\n给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。\n\n你可以对一个单词进行如下三种操作：\n\n- 插入一个字符\n- 删除一个字符\n- 替换一个字符\n\n\n给定两个单词，比如`word1 = \"horse\"，word2= \"ros\"`，\n\n如果将 horse 转换成 ros ，怎么增/删/换的步骤是最少的，\n\n我们知道这道题最少的步骤是 3，\n\n具体是这样做的：\n\n```\nhorse -> rorse (将 'h' 替换为 'r')\nrorse -> rose (删除 'r')\nrose -> ros (删除 'e')\n```\n\n那怎么样才能计算出最少的步骤？\n\n穷举！\n\n穷举什么？\n\n对每一处都进行三次选择，\n\n再取能令总的操作数最小的操作。\n\n很抽象对不对。\n\n做这个笔记时，曾一度中止，主要是在脑子里面无法形成生动形象的言语在字面上表现出来，\n\n但如果理解了，现实中三言两语就可以说的清楚。\n\n先看回我们这道题，\n\n**对比两个字符串，我们一般采用双指针，**\n\n上面操作的第一步是将 h 替换成 r，这其实是我们判断完后才知道的操作，\n\n我们应该怎么判断？\n\n我们需要两个指针，**这两个指针分别指向两个字符串尾部**，如图：\n\n![](https://note.youdao.com/yws/api/personal/file/WEB4fa7acec03bcdcc3ad8c73316054da26?method=download&shareKey=bc2d9b8c1b77c48b935b02c1fa69217d)\n\n此时进行判断，\n\n如果此处字符对应相等，那么不做任何操作，p，q都往前移动，**操作数等于移动后对应的操作数**，\n\n这里不理解？先暂时跳过加粗的部分，你现在只需要知道如果相同，就一起前移。\n\n**但实际上这里的两个字符是不同的，**\n\n那就得进行选择，到底是**删掉e，还是将e替换成s，还是在后面补上s呢**？\n\n小孩子才做选择，我全部都试一遍，\n\n如果是删掉e，将变成这样：\n\n![](https://note.youdao.com/yws/api/personal/file/WEBcf85b919a2dadbf69c28f13933f4b575?method=download&shareKey=a6b0f773ffd9c1e718e6ae496afd482a)\n\n**p将迁移，q保持不动，**\n\n好，这是删掉的情况，如果是替换的情况呢？\n\n替换之后就相等了，**那么p，q都将往前迁移**，如图：\n\n![](https://note.youdao.com/yws/api/personal/file/WEB863cc4013d9cb170146083ac80bacc6b?method=download&shareKey=f13be864aad0190cef8d5902f5c0be23)\n\n如果是增加呢？\n\n那就是在 e 的后面加上 s，然后**p要保持不动，q所指已经有匹配了，所以 q 要向前移动**，如图：\n\n![](https://note.youdao.com/yws/api/personal/file/WEB2f5ca93889601aac22889c940a9b44f5?method=download&shareKey=fd2cab6fe0fe93b389159aab51e2ed8e)\n\n好，到这里，以上每种操作，操作数都是 1，执行完之后，我们的**操作数 + 1**，\n\n**咦？为什么是 1 不是 3 呢？**\n\n因为我们只需要上面的其中一种，**虽然我们进行了三次操作，但是只有一种操作能使总的操作数最少**，是谁呢？\n\n暂时还不清楚，得看谁？\n\n得看执行后的的位置上进行这样三次操作，一直到其中一个字符串被遍历完，\n\n所以这就转换成为我们熟悉的 **最优解子问题**，\n\n要看我这个操作是不是能使总的操作数达到最小，就得看我的子问题能不能使操作数达到最小，\n\n这就是我们的状态和选择，\n\n回到我刚刚说的先不理会的加粗部分，如果此时两个字符相等，就一起迁移，\n\n此时的问题就转成为子问题的求解，子问题最小，则其最小。\n\n所以状态和选择我们都搞清楚了，只需要再搞清楚结束条件和初始值，就可以列举出我们的状态转移方程了。\n\n- 结束条件是什么？\n\n**当 p 或者 q指向字符串的前面时候**，就代表结束了，以下展示的是同时到达最前面，也就是这个问题最优的情况，\n\n![](https://note.youdao.com/yws/api/personal/file/WEBa358f973a3ee71d5510013988f7ab9b9?method=download&shareKey=042293b40543e4d6a9b4007f2d96d9aa)\n\n如果是这样呢？\n\n**q走完了，但是p还没有走完**，那就用**删除操作**把p前面的全部删掉，\n\n![](https://note.youdao.com/yws/api/personal/file/WEBea58bedf61615afa668b8a3a8b9539fb?method=download&shareKey=b8b2c6425c0b5a16d79944b83cbc31e6)\n\n如果是 **p 走完了，但是 q 没走完**，那么就用**增加操作**将 q 前面的所有加到 p 所指的位置，\n\n![](https://note.youdao.com/yws/api/personal/file/WEBb00f82efc2c78920860c25ff04138197?method=download&shareKey=b844226e8b197b82c1de2fc0e808af49)\n\n\n\n- 那初始值是什么？\n\n当然就是一方字符串为空，操作数就是另一字符串的长度。\n\n\n\n到了这里，应该我们的状态转移方程就可以写出来了：\n\n```java\ndp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1)\n// i是指向word1的指针，j是指向word2的指针\n//dp[i][j]表示当前位置的操作所能达到的最小操作数\n//dp[i - 1][j - 1] + 1 表示替换，替换后的子问题加上1就是当前的最小操作数\n//dp[i - 1][j] + 1 表示删除，删除后的子问题加1就是当前的最小操作数\n//dp[i][j - 1] + 1 表示增加，增加后的子问题加1就是当前的最小操作数\n```\n\n\n\n<br>\n\n#### 代码\n\n```java\nclass Solution {\n    public int minDistance(String word1, String word2) {\n        //将字符串转为字符数组\n        char []s1 = word1.toCharArray();\n        char []s2 = word2.toCharArray();\n        //创建一个二维数组\n        int [][]dp = new int[s1.length + 1][s2.length + 1];\n        //初始值条件\n        for(int i = 1; i <= s1.length; i++)\n            dp[i][0] = i;\n        for(int j = 1; j <= s2.length; j++) \n            dp[0][j] = j;\n        \n        int temp;\n        //开始遍历两个字符串\n        for(int i = 1; i <= s1.length; i++) {\n            for(int j = 1; j <= s2.length; j++) {\n                //如果当前位置对应相等，则当前的最小操作数等于子问题的操作数\n                if(s1[i - 1] == s2[j - 1])\n                    dp[i][j] = dp[i - 1][j - 1];\n                else {\n                    //判断三种操作的最小操作数\n                    temp = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);\n                    dp[i][j] = Math.min(dp[i - 1][j - 1] + 1, temp);\n                }\n            }\n        }\n        return dp[s1.length][s2.length];\n    }\n}\n```\n"
  },
  {
    "id": 30,
    "title": "LeetCode学习笔记——路径之和（深度优先搜索）",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "LeetCode",
      "DFS"
    ],
    "date": "2020-03-15",
    "abstract": "",
    "fileName": "LeetCode学习笔记——路径之和（深度优先搜索）.md",
    "filePath": "/old_blogs/LeetCode学习笔记——路径之和（深度优先搜索）.md",
    "mdContent": "\n## 前言\n\n深度优先搜索算法（英语：Depth-First-Search，DFS）\n\n是一种用于遍历或搜索树或图的算法。\n\n沿着树的深度遍历树的节点，尽可能深的搜索树的分支。\n\n当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。\n\n这一过程一直进行到已发现从源节点可达的所有节点为止。\n\n如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，\n\n整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。\n\n\n### 1. 路径之和 I\n\n给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。\n\n**说明**: 叶子节点是指没有子节点的节点。\n\n\n\n**示例:** \n给定如下二叉树，以及目标和 sum = 22，\n\n```\n          5\n         / \\\n        4   8\n       /   / \\\n      11  13  4\n     /  \\      \\\n    7    2      1\n```\n\n返回 `true`, 因为存在目标和为 22 的根节点到叶子节点的路径 `5->4->11->2`。\n\n\n\n#### 解题思路\n\n注意这道题的要求，是从根节点到叶子结点，\n\n那么我们就可以采用深度优先搜索，**利用递归**，从根节点开始，一直搜索到叶子结点，\n\n每向下递归一次，**sum就减掉该结点的值**，\n\n如果到叶子结点，**sum的值等于叶子结点的值**，\n\n说明这条路径是正确的，就返回**true**。\n\n\n\n</br>\n\n\n\n#### 代码\n\n```java\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if(root == null)\n            return false;\n        if(root.left == null && root.right == null){\n            if(sum == root.val)   //sum等于叶子结点的值\n                return true;\n        }\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);  //这里是||，左子树或者右子树正确都可以\n    }\n}\n```\n\n\n\n</br>\n\n\n\n### 2. 路径之和 II\n\n给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。\n\n**说明:** 叶子节点是指没有子节点的节点。\n\n\n\n**示例:**\n给定如下二叉树，以及目标和 sum = 22，\n\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\    / \\\n        7    2  5   1\n\n返回:\n\n```\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n```\n\n\n\n</br>\n\n\n\n#### 解题思路\n\n这道题和路径总和I是类似的，\n\n但是这道题的难度在于，\n\n**一棵树中，不只有一条正确的路径，而且还要把所有正确的路径保存在列表中**，\n\n同样要注意的是，还是**从根节点到叶子结点**，所以我们还是用深度优先搜索，利用**递归**来完成，\n\n当我们从根节点搜索到叶子结点的过程中，我们**将每一个结点的值保存在一个数组中**，\n\n当到叶子结点的时候，判断这条路径是否正确，\n\n如果正确，则将数组记录的结点值放入到一个列表数组中，\n\n如果不正确，**返回上个结点时，将该数组删除**。\n\n\n\n</br>\n\n\n\n#### 代码\n\n```java\nclass Solution {\n    List<List<Integer>> list = new ArrayList<>();\n    ArrayList<Integer> res = new ArrayList<>();\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\n        if(root == null)\n            return list;\n        sum -= root.val;\n        res.add(root.val); //将结点值加入到数组中\n        if(root.left == null && root.right == null){\n            if(sum == 0)\n                 list.add(new  ArrayList<>(res)); //复制一份，将数组加入到列表中\n        }\n        if(root.left != null)\n            pathSum(root.left, sum);\n        if(root.right != null)\n            pathSum(root.right, sum);\n        res.remove(res.size()-1);   //返回上个结点前，要将数组删除\n        return list;\n    }\n}\n```\n\n\n\n</br>\n\n\n\n### 3. 路径之和 III\n\n给定一个二叉树，它的每个结点都存放着一个整数值。\n\n找出路径和等于给定数值的路径总数。\n\n路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\n\n二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。\n\n\n\n**示例：**\n\n```\nroot = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\n```\n\n```\n      10\n     /  \\\n    5   -3\n   / \\    \\\n  3   2   11\n / \\   \\\n3  -2   1\n```\n\n```\n返回 3。和等于 8 的路径有:\n```\n\n```\n1.  5 -> 3\n2.  5 -> 2 -> 1\n3.  -3 -> 11\n```\n\n\n\n</br>\n\n\n\n#### 解题思路\n\n这道题相比前面两道题，难点在于，不一定是从根节点开始，也不一定是叶子结点结束，\n\n所以哪个结点都有可能是路径的起始点，\n\n这里就涉及到**双重递归**， 双重递归就是，**先对结点进行递归遍历**，这里也是采用深度优先搜索，\n\n这样子，**每一个结点都作为根节点**去深度搜索判断该路径是否正确，\n\n现在的问题就是，在不到叶子结点的情况下，如何判断是否正确，\n\n我们可以和之前一样，每递归一次，就将**sum值减去结点值**，\n\n当sum==0时，就说明正确，计数count++，到最后的时候，返回count；\n\n\n\n</br>\n\n\n\n#### 代码\n\n```java\nclass Solution {\n    int count = 0;\n    public int pathSum(TreeNode root, int sum) {\n        if(root == null)\n            return 0;\n        dfs(root,sum);\n        //先对结点进行遍历 ，让每一个结点都作为根节点\n        pathSum(root.left,sum);\n        pathSum(root.right,sum);\n        return count;\n    }\n\n    public void dfs(TreeNode root, int sum){\n        if(root == null)\n            return ;\n        sum -= root.val;\n        if(sum == 0)   //sum==0，则说明路径正确\n            count++;\n        dfs(root.left,sum);\n        dfs(root.right,sum);\n\n    }\n}\n```\n\n\n\n------\n\n整理于2020.3.15\n\n<center>END</center>"
  },
  {
    "id": 31,
    "title": "LeetCode学习笔记——链表",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "LeetCode",
      "双指针"
    ],
    "date": "2020-04-08",
    "abstract": "",
    "fileName": "LeetCode学习笔记——链表.md",
    "filePath": "/old_blogs/LeetCode学习笔记——链表.md",
    "mdContent": "\n### 什么是链表\n\n链表是数据结构的一种，它是一种线性数据结构，与数组相似，但与数组不同，在于它储存数据不一定需要一块完整连续的内存，它的每一个结点除了记录本身的数据之外，还记录着下一个结点的位置（指向下一个结点）。\n\n![单链表示例](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/12/screen-shot-2018-04-12-at-152754.png \"单链表示例\")\n<center>单链表 [From：leetcode-cn.com]</center>\n\n\n链表有两种类型：单链表和双链表。\n\n双链表与单链表的不同之处，在于双链表比单链表多了一个指向前一个结点的指针域。\n\n![双链表示例](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/17/screen-shot-2018-04-17-at-161130.png \"双链表示例\")\n<center>双链表 [From：leetcode-cn.com]</center>\n\n<br/>\n\n#### - 链表结构表示\n\n```c\n//单链表\n\nstruct Node{\n\tElemType val;\n\tstruct Node *next;\n}ListNode;\n```\n\n```c\n//双链表\n\nstruct Node{\n\tElemType val;\n\tstruct Node *next;\n\tstruct Node *pre;\n}ListNode;\n```\n\n</br>\n\n### 双指针技巧\n\n顾名思义，双指针就是生成两个指针，利用两个指针对链表进行操作，经典问题是**判断链表是否有环**，**相交链表**。\n\n</br>\n\n#### - 题目：141.环形链表\n\n给定一个链表，判断链表中是否有环。\n\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\n\n**示例1：**\n\n> 输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。*\n\n![](https://note.youdao.com/yws/api/personal/file/WEBba143a7a7977f25762ffc023fef70aac?method=download&shareKey=da1a5842ce4f53d389812acaa13a6331)\n\n**示例2：**\n\n> 输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n![](https://note.youdao.com/yws/api/personal/file/WEB0ab87a9d9558dac600bc5bd113f347a1?method=download&shareKey=9e75e0ee5b30c088a3b38f6036a2a665)\n\n</br>\n\n##### 解题思路\n\n链表有环也就意味着如果一直遍历这个链表，那么是不会停止的，如果用两个指针，一个指针跑得快，一个跑的慢，快的那一个就可以追上前面那一个，当他们相等的时候，就说明该链表有环。\n\n但要注意空链表和链表中只有一个结点的时候，如果只有一个结点，就不是环形链表，返回fasle。\n\n##### 代码\n\n```c\nbool hasCycle(struct ListNode *head) {\n\t//空链表时则直接返回false\n    if(!head)\n        return false;\n\t//两个指针，且他们都指向链表的头指针\n    struct ListNode* slow = head;\n    struct ListNode* fast = head;\n\t//当快指针的下一个和下下个都不为空时，进入循环，这里就可以判断链表只有一个结点的情况\n    while(fast->next && fast->next->next){\n        fast = fast->next->next;     //快指针走两位\n        if(fast == slow){\n            return true;\n        }\n        else\n            slow = slow->next;\n    }\n    return false;\n}\n```\n\n</br>\n\n#### - 题目：160.相交链表\n\n编写一个程序，找到两个单链表相交的起始节点。\n\n如下面的两个链表：\n\n![](https://note.youdao.com/yws/api/personal/file/WEBa518393ea64974fa9437832acc1e024d?method=download&shareKey=3d234f880b204dba85c7ea77008a597e)\n\n在节点 c1 开始相交。\n\n**示例1：**\n\n> 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Reference of the node with value = 8\n输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n![](https://note.youdao.com/yws/api/personal/file/WEB9785bda6690e872fcb3a4a96f977593d?method=download&shareKey=f942b3abbdc9d4a577cce6523784d7dc)\n\n**示例2：**\n\n> 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n解释：这两个链表不相交，因此返回 null\n\n![](https://note.youdao.com/yws/api/personal/file/WEB86bf92e5ba6f523fc9249dfa76415cc1?method=download&shareKey=875f1e1e2d1544888e2666e979baf394)\n\n</br>\n\n##### 解题思路\n\n还是采用双指针的做法，但这次却不是快慢指针，而是两个指针同时进行，pA指向headA，pB指向headB，链表短的一方肯定先到达末尾，而到达末尾后，则改变指向长链表的头指针，继续遍历，当长的那方到达末尾后则指向短的一方头指针，如果相交，他们一定会在相交处相遇。\n\n这里借用题解的一份图参考一下\n\n![](https://note.youdao.com/yws/api/personal/file/WEBe63bd6d4d0b34b6295c48603383b19cb?method=download&shareKey=e18efde39a9f81ea68c6e3ba11bd76d4)\n\n其原理是一个数学差值问题，假设A链表有8个结点，B链表有6个结点，如果在A链表的第5个结点相交，也就是在B链表的第三个结点相交，在走到相交点处时，走的步数是一样的。\n\n![note](https://note.youdao.com/yws/api/personal/file/WEBdbb5d5b7195a26fdc732491f51f2c911?method=download&shareKey=c0aac8a3fe1c68a8808dcb85b424ae2b \"note\")\n<center>字丑请忽略</center>\n\n当相等的时候，返回即可。\n\n##### 代码\n```c\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\n\t//有一个为空链表都返回NULL\n\tif(!headA || !headB)\n        return NULL;\n    struct ListNode* pA = headA;\n    struct ListNode* pB = headB;\n    while(pA != pB){\n        pA = pA == NULL?headB : pA->next;   //先判断pA是否到达了末尾，如果到了则pA=headB，否则pA指向下一个\n        pB = pB == NULL?headA : pB->next;\n    }\n    return pA;\n}\n```\n\n</br>\n\n------------\n整理于（2020.3.8）\n"
  },
  {
    "id": 32,
    "title": "LeetCode学习笔记——除数博弈",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "LeetCode",
      "动态规划"
    ],
    "date": "2020-04-13",
    "abstract": "",
    "fileName": "LeetCode学习笔记——除数博弈.md",
    "filePath": "/old_blogs/LeetCode学习笔记——除数博弈.md",
    "mdContent": "\n有这么一道题，\n\n让我懂得了数学不够好，算法很难学好，\n\n而数学有多好，\n\n做题时就可以有多秀。\n\n\n\n### 除数博弈\n\n爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。\n\n最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：\n\n- 选出任一 x，满足 `0 < x < N` 且 `N % x == 0` 。\n\n- 用 `N - x` 替换黑板上的数字 N 。\n\n  如果玩家无法执行这些操作，就会输掉游戏。\n\n只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。\n\n\n**示例 1：**\n\n```\n输入：2\n输出：true\n解释：爱丽丝选择 1，鲍勃无法进行操作。\n```\n\n**示例 2：**\n\n```\n输入：3\n输出：false\n解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。\n```\n\n**提示：**\n\n1. `1 <= N <= 1000`\n\n\n\n#### 解题思路\n\n先来分析一下题目，\n\n给出一个数 N，爱丽丝先在 (0,N) 中选出一个数 x，这个数需满足 N % x == 0，\n\n这时候数的范围缩小了，到了鲍勃选的时候，是从 （0，N - x）中选择，\n\n看看谁是最后一个选，也就是谁赢，如果是爱丽丝，就返回true，否则返回false；\n\n这道题的标签是动态规划，所以不看大佬秀，还是扎扎实实的选择动态规划的思路来做题，\n\n找出**状态**和**选择**，\n\nN的大小是选择的范围，而在这个范围里面选择一个数是选择，而选择这个之后是输是赢是状态，\n\n同样的，我们需要找出子问题的最优解，也就是我们能够初始的值，\n\n- 当 n == 1时，肯定是false\n- 当 n == 2时，为true；\n\n那再来看看什么情况下，爱丽丝会赢，\n\n我们说如果 n为2，是true，是针对先选择来说的，\n\n因为当n == 2时，爱丽丝先选，选完后鲍勃就没得选，肯定是先选择的赢，后选择的输，\n\n那如果说，当爱丽丝选择后，如果剩下的范围是false，那在剩下的范围里面先选择的也就是鲍勃，肯定输，\n\n所以，申请一个dp数组，储存的是先选择的状态，\n\n转为状态方程就是：\n\n```java\ndp[N] =  !dp[N - x]\n```\n\n**在N时候做选择的输赢是基于我做了选择之后的输赢**\n\n而怎么样才能确定 N - x呢，就看 N % x == 0？\n\n\n\n#### 代码\n\n```java\nclass Solution {\n    public boolean divisorGame(int N) {\n        //特殊值\n        if(N <= 1)\n            return false;\n        if(N == 2)\n            return true;\n        //dp数组，记录选择后的状态\n        boolean []dp = new boolean[N + 1];\n        //初始值\n        dp[1] = false;\n        dp[2] = true;\n        //从3开始，对每种选择都记录下来\n        for(int i = 3; i <= N; i++) {\n            dp[i] = false;\n            for(int j = 1; j < i/2; j++) {\n                //只有让后面进行选择的人输，先选择的才能赢\n                if(i % j == 0 && dp[i - j] == false)\n                    dp[i] = true;\n            }\n        }\n        return dp[N];\n    }\n}\n```\n\n\n\n这时候回到我开篇的第一句话，\n\n为什么说数学好的人可以很秀，\n\n我们再来看看这道题，\n\n其实现在看来这道题就是一个正反面，奇偶性的问题，\n\n假如N是奇数，\n\n要使得 N % x == 0，\n\n那 x 只能是奇数，所以先选择的人，只能一直选择奇数，选择后变为偶数，\n\n后选择的人选择后，就变回了奇数，\n\n这时候范围一直缩小，最后给先选择的人是 （0,3）的范围，所以先选择的人必输；\n\n而如果N是偶数，\n\n同理，\n\n先选择的人只要不将变为偶数，把自己置于死地，就可以赢。\n\n所以，这道题还可以这样做：\n\n```java\nclass Solution {\n    public boolean divisorGame(int N) {\n        return N % 2 == 0;\n    }\n}\n```\n\n"
  },
  {
    "id": 33,
    "title": "LeetCode学习笔记——零钱兑换（动态规划）",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "LeetCode",
      "动态规划"
    ],
    "date": "2020-03-24",
    "abstract": "",
    "fileName": "LeetCode学习笔记——零钱凑数（动态规划）.md",
    "filePath": "/old_blogs/LeetCode学习笔记——零钱凑数（动态规划）.md",
    "mdContent": "\n\n今天，动态规划又来了，\n\n动态规划问题无非就是找出**状态**和**选择**，\n\n对状态的定义不同，定义的dp数组不同，对应的状态转移方程也是不一样的。\n\n今天，我整理了零钱兑换系列的问题，分享一下。\n\n\n### 零钱兑换\n\n题目给出一组硬币的数额，然后给出一个amount，叫你求出凑成这个目标数所需要的最小硬币数，\n\n当我一眼看完题目，我判断出这道题应该要用动态规划的思维来做，\n\n主要有两个原因：\n\n- 有可选择的东西（硬币）\n- 求到达一个目标数（amount）的最小硬币数（也就是最优解）\n\n其实这道题和**背包问题**是一样的，\n\n背包问题应该可以说是动态规划最典型的案例了，\n\n我在很多算法书里面看到对动态规划的讲解都先是用背包问题，\n\n前一段时间，当我刚接触到动态规划的时候，对背包问题是真的一头雾水，\n\n花了一整天的时间也没弄出个所以然，说多了都是泪。\n\n**背包问题是这样子的，**\n\n给出一组物品的价值和对应的重量，然后给出背包所能装载的最大重量，然后求背包所能装载的最大价值，\n\n同样的，他也有两大特征，\n\n- 有物品可供选择（包括重量和价值）\n- 求到达目标数所能装载的最大价值\n\n是不是很相似？\n\n但今天主要还是来讲零钱兑换的问题，\n\n解决动态规划问题，就是一个求**最优解**的问题，同时也是一个求最优**子**解的问题，\n\n动态规划中的另一个典型问题——爬楼梯，求跳到这一级阶梯的方式有多少种，\n\n就是看跳到这一级的上一级的位置在哪里，确定上一级的位置，就是确定子问题，\n\n同样的，在零钱问题中，求到amount的最小硬币数，就是求到amount前子问题的最小硬币数，\n\n前子问题是什么？\n\n我们先举个例子，\n\n```\n输入: coins = [1, 2, 5], amount = 11\n输出: 3 \n```\n\n硬币的面额有1，2，5三种，目标数是11，那目标数的子问题是什么？\n\n没错，就是 `amount - coins`，在这道题中就是`10, 9, 6`\n\n那题就转换成了去求到达目标数10，到达目标数9，到达目标数6的最小硬币数，\n\n继续这样缩小范围，直到最基本的问题，也就是`amount == 1`的时候。\n\n前面我们说了，动态规划问题要找出**状态**和**选择**，\n\n状态是什么？状态就是到达这个目标数的最小硬币数，\n\n选择是什么？选择就是这个硬币我选还是不选？\n\n依据是什么？依据是能不能让我硬币数达到最小，\n\n比如到达目标数8，是让 5 + 1 + 1 + 1呢？ 还是5 + 2 + 1呢？\n\n当然就是后者，这就是选择。\n\ndp数组记录的是什么？是状态。\n\n那可以转换成我们的状态转移方程了，\n\n```java\n// dp[i] 初始化为最大值\ndp[i] = MAX_VALUE\n    \ndp[i] = min(dp[i - coins] + 1, dp[i])\n// i 代表当前目标数\n// coins代表硬币数额\n// +1，表示加上一个硬币数\n```\n\n<br>\n\n状态转移方程的问题解决了，这道题也就解决了一半了，\n\n但还有一些细节问题需要考虑，\n\n- 数组长度为多少。\n\n数组长度应该为 amount + 1，因为我们的目标数是从 0 开始到 amount ，\n\ndp[0] 当然就是 0 ，\n\n- dp[amount] 最大可能为多少？\n\n最大为amount，硬币数额不可能为0，最小数额为1，所以是amount，判断这个有什么用呢？\n\n有用，因为这是一个临界条件（极端条件），\n\n如果dp[i] > amount, 说明就没有一组硬币组合符合。\n\n<br>\n\n应该都比较清楚了，我们直接上代码：\n\n<br>\n\n#### 代码\n\n```java\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        // 初始一个比较大的值\n        int max = amount + 1;\n        int []dp = new int[amount + 1];\n        //将dp数组填充最大值，因为我们求的是最小硬币数\n        Arrays.fill(dp, max);\n        //初始值\n        dp[0] = 0;\n        //穷举每一个目标数的最小硬币数\n        for(int i = 1; i <= amount; i++) {\n            //对每种子问题都穷举\n            for(int j = 0; j < coins.length; j++) {\n                if(coins[j] <= i)\n                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\n            }\n        }\n        //没有符合的情况就返回 - 1\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n}\n```\n\n\n\n<br>\n\n刚刚我们讨论的是零钱兑换系列的一个问题，是求最小硬币数，\n\n**还有一种问法，问你有多少种组合数**，\n\n就是到达这个目标数有多少种组合，\n\n一样的，我们举个例子，\n\n```\n输入: amount = 5, coins = [1, 2, 5]\n输出: 4\n解释: 有四种方式可以凑成总金额:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n```\n\n这时候我们再来问问，\n\n状态是什么？状态是到达目标数的组合数。\n\n选择是什么？一样的，是这个硬币我选不选呢？\n\n依据是什么？选了能否到达我的目标数。\n\ndp数组记录的就是组合数。\n\n和上面一样，也是利用穷举的方法，穷举从 1 到 amount 每种情况的组合数，\n\n因为要求amount的组合数，其实就是求子问题的组合数，\n\n子问题怎么判断呢？\n\n当然还是 **目标数 - coins**，\n\n**当前的组合数 = 上一种情况到这里的组合数  + 子问题的组合数。**\n\n这就是我们的状态转移方程，\n\n```java\ndp[i] = dp[i] + dp[i - coins];\n// i 表示目标数\n```\n\n列举一下，就很明白了：\n\n首先我们要知道 `dp[0] = 1`, 也就是说当目标数等于0 的时候，是1种组合。\t\n\n- 没有使用硬币的情况\n\n|  目标数  |  0   |  1   |  2   |  3   |  4   |  5   |\n| :------: | :--: | :--: | :--: | :--: | :--: | :--: |\n| no coins |  1   |  0   |  0   |  0   |  0   |  0   |\n\n- 使用数额为1的硬币\n\n- 使用数额为 1 的情况\n\n数额为1，只有amount >= 1的时候才有考虑的意义，\n\n|  目标数  |  0   |  1   |  2   |  3   |  4   |  5   |\n| :------: | :--: | :--: | :--: | :--: | :--: | :--: |\n| no coins |  1   |  0   |  0   |  0   |  0   |  0   |\n| coins 1  |  1   |  1   |  1   |  1   |  1   |  1   |\n\n- 使用数额为 2 的情况\n\n|  目标数  |  0   |  1   |  2   |  3   |  4   |  5   |\n| :------: | :--: | :--: | :--: | :--: | :--: | :--: |\n| no coins |  1   |  0   |  0   |  0   |  0   |  0   |\n| coins 1  |  1   |  1   |  1   |  1   |  1   |  1   |\n| coins 2  |  1   |  1   |  2   |  2   |  3   |  3   |\n\n- 使用数额为 5 的情况\n\n|  目标数  |  0   |  1   |  2   |  3   |  4   |  5   |\n| :------: | :--: | :--: | :--: | :--: | :--: | :--: |\n| no coins |  1   |  0   |  0   |  0   |  0   |  0   |\n| coins 1  |  1   |  1   |  1   |  1   |  1   |  1   |\n| coins 2  |  1   |  1   |  2   |  2   |  3   |  3   |\n| coins 5  |  1   |  1   |  2   |  2   |  3   |  4   |\n\n所以最终结果是4,。\n\n\n\n搞定！！\n\n\n\n上代码！\n\n\n\n<br>\n\n#### 代码\n\n```java\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int []dp = new int[amount + 1];\n        //当目标数为 0 的时候，组合数为1\n        dp[0] = 1;\n        //对硬币种类进行穷举\n        for(int co : coins) {\n            //穷举每个目标数的情况，直至所有硬币种类都列举完，最后更新的就是最终的组合数\n            for(int i = co; i <= amount; i++) {\n                if(i >= co) {\n                    //组合数等于当前的组合数加上子问题的组合数\n                    dp[i] += dp[i - co];\n                }\n            }\n        }\n        return dp[amount];\n    }\n}\n```\n\n\n\n<br>\n\n------\n\n整理于 2020.3.24"
  },
  {
    "id": 34,
    "title": "Python爬虫学习笔记——爬取壁纸实战",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "笔记",
    "tags": [
      "python"
    ],
    "date": "2020-03-03",
    "abstract": "",
    "fileName": "Python爬虫学习笔记——爬取壁纸实战.md",
    "filePath": "/old_blogs/Python爬虫学习笔记——爬取壁纸实战.md",
    "mdContent": "\n\n## 前言\n\n\n最近心血来潮，\n\n想把前段时间进坑python的学习心得整理出来，\n\n这个过程，一个是可以和大家分享交流，\n\n但更重要的是可以理清自己的思路，以便更好的学习。\n\n今天想介绍的是一个爬虫实战项目，\n\n爬取必应高清壁纸（https://bing.ioliu.cn/）\n\n\n### 1. 分析我们要做的事情\n\n首先，当然是要明确我们需要做的事情，\n\n按照正常的做法，\n\n我们下载壁纸的时候需要一张一张的下载，\n\n而通常情况下，\n\n这种网站的加载速度又是比较慢的，\n\n这就导致我们不佳的体验**（原因）**，\n\n所以，我们想要把他们都下载下来，\n\n并把它们放在一个文件夹中，\n\n以便我们更好的寻找，\n\n但前提我们要保证人家的网站不崩溃**（很重要）**。\n\n**本次使用的的编辑器是——pycharm，**\n\n**导入的第三方库有requests，os，lxml中的etree，time，urllib3。**\n\n</br>\n\n### 2. 检查网页规律\n作为一个的“入侵者”，我们当然要去“阵地上”探查一下军情。\n\n进入到必应壁纸网页（https://bing.ioliu.cn/）\n\n![必应壁纸首页](https://note.youdao.com/yws/api/personal/file/WEB30edd4dce1a32bbf173ab9cd43a0cbc5?method=download&shareKey=0f5c134712c5e8cb6695be5183dbfb8b)\n\n我们需要掌握网页的信息，并摸清图片链接的规律，\n\n按下**F12**进入到网页检查页面\n\n![网页检查页面](https://note.youdao.com/yws/api/personal/file/WEBda472b1c0cc3455da225ba49fd3661bf?method=download&shareKey=ed7d7259ad99fc22f7abc92c110a2f6c \"网页检查页面\")\n\n通过查找图片的规律，我们发现图片都是在**<img>**标签中的**data-progressive**属性中，找出这个规律后，就可以来编写我们的代码了。\n\n</br>\n\n### 3. 编写我们的代码\n\n#### - 导入我们所需要的库\n``` bash\n# 导入\nimport requests\nfrom lxml import etree\nimport time\nimport os`\n```\n1. requests库可以用来获取网页的信息，\n\n2. os库用来创建目录和判断目录是否存在，\n\n3. lxml库中的etree.HTML()可以用来解析字符串格式的HTML 文档对象，将传进去的字符串转变成_Element对象。\n作为_Element对象，可以方便我们接下来使用的xpath()方法。\n\n</br>\n\n#### - 把自己伪装成浏览器\n\n毕竟我们是“入侵者”，一些网址会反爬虫，所以我们要伪装成浏览器，这样我们才能畅通无阻的访问。\n``` bash\n# 伪装浏览器\nheaders = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) \\AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36'}\n```\n有多种途径可以获得User-Agent，\n\n可以通过你使用的浏览器，\n\n检查-->network-->在name栏里面选取一张jpg图片-->在右边的Request-Headers中可以找到\n\n![网页检查页面——name](https://note.youdao.com/yws/api/personal/file/WEB93df029cd435f23e3cabe2e9d8f2cb54?method=download&shareKey=75f42ae9c4a0ca365e72aaa600bd0b25 \"网页检查页面——name\")\n\n![网页检查页面——header](https://note.youdao.com/yws/api/personal/file/WEB147c25a495ca75eb3b62e4a374c0af7d?method=download&shareKey=820c17daaa341d030e3061976d016fec \"网页检查页面——header\")\n\n还可以直接上网查找 \n\nhttps://blog.csdn.net/wangqing84411433/article/details/89600335\n\n</br>\n\n#### - 获取网页信息\n\n```python\n# 获取网页信息\ndef get_html(url):\n    html = requests.get(url, headers = headers, verify=False).content.decode(\"utf-8\")\n    return html`\n```\nrequest.get(url)将返回一个对象，\n\n对象储存该网页所有信息，\n\ncontent是将对象转为字节码保存，\n\n经过decode('utf-8')解码成字符串数据保存在html中，返回html。\n\n</br>\n\n#### - 获取图片路径\n\n``` bash\n# 分析网页信息，获取图片路径\ndef get_img_addrs(html):\n    # 使用lxml中的etree解析获取的网页信息\n    etree_html = etree.HTML(html)\n    # 创建一个列表保存图片路径\n    img_addrs = etree_html.xpath('..//img/@data-progressive')\n    return img_addrs\n```\n\netree.HTML()解析网址，返回一个XPath解析对象，然后使用xpath()方法寻找路径\n\n</br>\n<center>xpath方法路径表达式极其结果>xpath方法路径表达式极其结果</center>\n```html\n# 演示代码\n<div>\n    <picture>\n        <img class=\"abcde\" img_addr=\"http://.....\">\n    </picture>\n</div>\n```\n\n\n| 路径表达式  |  结果 |\n| :------------: | :------------: |\n| div  | 选取div元素所有的子节点  |\n| /div  | 选取根元素div  |\n|  /div/picture | 选取div子元素的所有book元素  |\n| //book  |  选取book元素，无论它在哪里 |\n| //@img  |  选取所有名为img_addr的属性，则可以选出“http://......” |\n\n</br>\n\n#### - 保存图片\n\n```python\n# 保存图片\ndef save_imgs(folders, img_addrs):\n    # 使用全局变量name\n    global name\n    for each in img_addrs:\n        # 缓冲时间\n        time.sleep(2)\n​\n        print(\"正在下载第{}张\".format(name))\n​\n        # 图片名格式\n        filename = str(name) + '.jpg'\n​\n        # 抓取图片路径缓存图片\n        response = requests.get(each, headers=headers).content\n​\n        # 保存图片\n        with open(filename, 'wb') as f:\n            f.write(response)\n​\n        name += 1\n```\n\ntime.sleep()是为了保证网站的稳定，每保存一张图片将会休眠2s，以防网站崩溃（虽然不会那么容易崩溃，但安全防护措施要做好。）\n\nwith open(filename, 'wb') as f，可以在文件打开异常的情况下关闭文件，即便是运行到最后出错也可以保证文件会关闭。\n\n</br>\n\n#### - 完整代码\n\n```python\nimport requests\nfrom lxml import etree\nimport time\nimport os\n​\n# 伪装浏览器\nheaders = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) \\AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36'}\n​\n# 获取网页信息\ndef get_html(url):\n    html = requests.get(url, headers = headers, verify=False).content.decode(\"utf-8\")\n    return html\n​\n# 分析网页信息，获取图片路径\ndef get_img_addrs(html):\n​\n    # 使用lxml中的etree解析获取的网页信息\n    etree_html = etree.HTML(html)\n​\n    # 创建一个列表保存图片路径\n    img_addrs = etree_html.xpath('..//img/@data-progressive')\n    return img_addrs\n​\n# 保存图片\ndef save_imgs(folders, img_addrs):\n    # 使用全局变量name\n    global name\n    for each in img_addrs:\n        # 缓冲时间\n        time.sleep(2)\n​\n        print(\"正在下载第{}张\".format(name))\n​\n        # 图片名格式\n        filename = str(name) + '.jpg'\n​\n        # 抓取图片路径缓存图片\n        response = requests.get(each, headers=headers).content\n​\n        # 保存图片\n        with open(filename, 'wb') as f:\n            f.write(response)\n​\n        name += 1\n​\n# 主函数\nif __name__ == \"__main__\":\n​\n    # 创建目录\n    folder = 'picture'\n    os.mkdir(folder)\n    os.chdir(folder)\n​\n    # 用作保存文件的名字\n    name = 1\n​\n    pages = int(input(\"请输入你想要爬取的页数：\"))\n    for i in range(1, pages+1):\n        url = \"https://bing.ioliu.cn/?p={}\".format(i)\n​\n        html = get_html(url)\n        img_addrs = get_img_addrs(html)\n        save_imgs(folder, img_addrs)\n```\n</br>\n以上代码是有一个小小的问题的，就是最后每加载一页会出现InsecureRequestWarning警告，这是因为使用requests库请求HTTPS时，忽略证书验证，会爆出错误，但不影响正常运行。\n\n##### 解决方法：\n```python\n# 在前面加入两条代码即可完美解决\nimport urllib3\nurllib3.disable_warnings()\n```\n\n</br>\n\n最后，查看.py所在的目录下的picture目录，就能看到下载好的壁纸，不要贪多喔......\n\n![已下载图片](https://note.youdao.com/yws/api/personal/file/WEBf1fce58aa941ec132b5c0c70395b0ce2?method=download&shareKey=1a74fc10d7960a4515f7b86dafbc9f73 \"已下载图片\")\n"
  },
  {
    "id": 35,
    "title": "Vim使用及账号用户管理",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "笔记",
    "tags": [
      "Linux"
    ],
    "date": "2020-09-09 ",
    "abstract": "",
    "fileName": "Vim使用及账号用户管理.md",
    "filePath": "/old_blogs/Vim使用及账号用户管理.md",
    "mdContent": "\n\n> 什么是Vim编辑器\n\nVim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。\n\n简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。\n\nvim 则可以说是程序开发者的一项很好用的工具。\n\n所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。\n\n连 vim 的官方网站 (http://www.vim.org) 自己也说 vim 是一个程序开发工具而不是文字处理软件。\n\n\n> 三种使用模式\n\n基本上 vi/vim 共分为三种模式，分别是**命令模式（Command mode）**，**输入模式（Insert mode）**和**底线命令模式（Last line mode）**。这三种模式的作用分别是：\n\n**命令模式：**\n\n用户刚刚启动 vi/vim，便进入了命令模式。\n\n此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。\n\n以下是常用的几个命令：\n\n- **i** 切换到输入模式，以输入字符。\n- **x** 删除当前光标所在处的字符。\n- **:** 切换到底线命令模式，以在最底一行输入命令。\n\n若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。\n\n命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。\n\n**输入模式：**\n\n在命令模式下按下i就进入了输入模式。\n\n在输入模式中，可以使用以下按键：\n\n- **字符按键以及Shift组合**，输入字符\n- **ENTER**，回车键，换行\n- **BACK SPACE**，退格键，删除光标前一个字符\n- **DEL**，删除键，删除光标后一个字符\n- **方向键**，在文本中移动光标\n- **HOME**/**END**，移动光标到行首/行尾\n- **Page Up**/**Page Down**，上/下翻页\n- **Insert**，切换光标为输入/替换模式，光标将变成竖线/下划线\n- **ESC**，退出输入模式，切换到命令模式\n\n**底线命令模式**\n\n在命令模式下按下:（英文冒号）就进入了底线命令模式。\n\n底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。\n\n在底线命令模式中，基本的命令有（已经省略了冒号）：\n\n- q 退出程序\n- w 保存文件\n\n按ESC键可随时退出底线命令模式。\n\n简单的说，我们可以将这三个模式想成底下的图标来表示：\n\n\n\n> 上手体验一下，在home目录下测试\n\n如果你想要使用 vi 来建立一个名为 kuangstudy.txt 的文件时，你可以这样做：\n\n```\n[root@kuangshen home]# vim kuangstudy.txt\n```\n\n然后就会进入文件\n\n\n\n**按下 i 进入输入模式(也称为编辑模式)，开始编辑文字**\n\n在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！\n\n在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。\n\n这个时候，键盘上除了 **Esc** 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。\n\n\n\n**按下 ESC 按钮回到一般模式**\n\n好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 **Esc** 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！\n\n在一般模式中按下 **:wq** 储存后离开 vim！\n\n\n\nOK! 这样我们就成功创建了一个 kuangstudy.txt 的文件。\n\n> Vim 按键说明\n\n除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。\n\n**第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等**\n\n| 移动光标的方法     |                                                              |\n| :----------------- | ------------------------------------------------------------ |\n| h 或 向左箭头键(←) | 光标向左移动一个字符                                         |\n| j 或 向下箭头键(↓) | 光标向下移动一个字符                                         |\n| k 或 向上箭头键(↑) | 光标向上移动一个字符                                         |\n| l 或 向右箭头键(→) | 光标向右移动一个字符                                         |\n| [Ctrl] + [f]       | 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)          |\n| [Ctrl] + [b]       | 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)           |\n| [Ctrl] + [d]       | 屏幕『向下』移动半页                                         |\n| [Ctrl] + [u]       | 屏幕『向上』移动半页                                         |\n| +                  | 光标移动到非空格符的下一行                                   |\n| -                  | 光标移动到非空格符的上一行                                   |\n| n< space>          | 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。 |\n| 0 或功能键[Home]   | 这是数字『 0 』：移动到这一行的最前面字符处 (常用)           |\n| $ 或功能键[End]    | 移动到这一行的最后面字符处(常用)                             |\n| H                  | 光标移动到这个屏幕的最上方那一行的第一个字符                 |\n| M                  | 光标移动到这个屏幕的中央那一行的第一个字符                   |\n| L                  | 光标移动到这个屏幕的最下方那一行的第一个字符                 |\n| G                  | 移动到这个档案的最后一行(常用)                               |\n| nG                 | n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) |\n| gg                 | 移动到这个档案的第一行，相当于 1G 啊！(常用)                 |\n| n< Enter>          | n 为数字。光标向下移动 n 行(常用)                            |\n\n| 搜索替换 |                                                              |\n| :------- | ------------------------------------------------------------ |\n| /word    | 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！(常用) |\n| ?word    | 向光标之上寻找一个字符串名称为 word 的字符串。               |\n| n        | 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ |\n| N        | 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 |\n\n| 删除、复制与粘贴 |                                                              |\n| :--------------- | ------------------------------------------------------------ |\n| x, X             | 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) |\n| nx               | n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 |\n| dd               | 删除游标所在的那一整行(常用)                                 |\n| ndd              | n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用) |\n| d1G              | 删除光标所在到第一行的所有数据                               |\n| dG               | 删除光标所在到最后一行的所有数据                             |\n| d$               | 删除游标所在处，到该行的最后一个字符                         |\n| d0               | 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符      |\n| yy               | 复制游标所在的那一行(常用)                                   |\n| nyy              | n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) |\n| y1G              | 复制游标所在行到第一行的所有数据                             |\n| yG               | 复制游标所在行到最后一行的所有数据                           |\n| y0               | 复制光标所在的那个字符到该行行首的所有数据                   |\n| y$               | 复制光标所在的那个字符到该行行尾的所有数据                   |\n| p, P             | p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用) |\n| J                | 将光标所在行与下一行的数据结合成同一行                       |\n| c                | 重复删除多个数据，例如向下删除 10 行，[ 10cj ]               |\n| u                | 复原前一个动作。(常用)                                       |\n| [Ctrl]+r         | 重做上一个动作。(常用)                                       |\n\n**第二部分：一般模式切换到编辑模式的可用的按钮说明**\n\n| 进入输入或取代的编辑模式 |                                                              |\n| :----------------------- | ------------------------------------------------------------ |\n| i, I                     | 进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用) |\n| a, A                     | 进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用) |\n| o, O                     | 进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用) |\n| r, R                     | 进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用) |\n| [Esc]                    | 退出编辑模式，回到一般模式中(常用)                           |\n\n**第三部分：一般模式切换到指令行模式的可用的按钮说明**\n\n| 指令行的储存、离开等指令                                     |                                                              |\n| :----------------------------------------------------------- | ------------------------------------------------------------ |\n| :w                                                           | 将编辑的数据写入硬盘档案中(常用)                             |\n| :w!                                                          | 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ |\n| :q                                                           | 离开 vi (常用)                                               |\n| :q!                                                          | 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。    |\n| 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ |                                                              |\n| :wq                                                          | 储存后离开，若为 :wq! 则为强制储存后离开 (常用)              |\n| ZZ                                                           | 这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！ |\n| :w [filename]                                                | 将编辑的数据储存成另一个档案（类似另存新档）                 |\n| :r [filename]                                                | 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 |\n| :n1,n2 w [filename]                                          | 将 n1 到 n2 的内容储存成 filename 这个档案。                 |\n| :! command                                                   | 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中看 /home 底下以 ls 输出的档案信息！ |\n| :set nu                                                      | 显示行号，设定之后，会在每一行的前缀显示该行的行号           |\n| :set nonu                                                    | 与 set nu 相反，为取消行号！                                 |\n\n### 账号管理\n\n> 简介\n\nLinux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。\n\n用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。\n\n每个用户账号都拥有一个唯一的用户名和各自的口令。\n\n用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。\n\n实现用户账号的管理，要完成的工作主要有如下几个方面：\n\n- 用户账号的添加、删除与修改。\n- 用户口令的管理。\n- 用户组的管理。\n\n\n\n> 用户账号的管理\n\n用户账号的管理工作主要涉及到用户账号的添加、修改和删除。\n\n添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。\n\n> 添加账号 useradd\n\n```\nuseradd 选项 用户名\n```\n\n参数说明：\n\n- 选项 :\n\n- - -c comment 指定一段注释性描述。\n  - -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。\n  - -g 用户组 指定用户所属的用户组。\n  - -G 用户组，用户组 指定用户所属的附加组。\n  - -m　使用者目录如不存在则自动建立。\n  - -s Shell文件 指定用户的登录Shell。\n  - -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。\n\n- 用户名 :\n\n- - 指定新账号的登录名。\n\n测试：\n\n```\n# 此命令创建了一个用户kuangshen，其中-m选项用来为登录名kuangshen产生一个主目录 /home/kuangshen\n[root@kuangshen home]# useradd -m kuangshen\n```\n\n增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。\n\n\n\n> Linux下如何切换用户\n\n1.切换用户的命令为：su username 【username是你的用户名哦】\n\n2.从普通用户切换到root用户，还可以使用命令：sudo su\n\n3.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令\n\n4.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：【su - root】\n\n$表示普通用户\n\n\\#表示超级用户，也就是root用户\n\n\n\n> 删除帐号\n\n如果一个用户的账号不再使用，可以从系统中删除。\n\n删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。\n\n删除一个已有的用户账号使用userdel命令，其格式如下：\n\n```\nuserdel 选项 用户名\n```\n\n常用的选项是 **-r**，它的作用是把用户的主目录一起删除。\n\n```\n[root@kuangshen home]# userdel -r kuangshen\n```\n\n此命令删除用户kuangshen在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。\n\n\n\n> 修改帐号\n\n修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。\n\n修改已有用户的信息使用usermod命令，其格式如下：\n\n```\nusermod 选项 用户名\n```\n\n常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。\n\n例如：\n\n```\n# usermod -s /bin/ksh -d /home/z –g developer kuangshen\n```\n\n此命令将用户kuangshen的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。\n\n\n\n> 用户口令的管理\n\n用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。\n\n指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。\n\n命令的格式为：\n\n```\npasswd 选项 用户名\n```\n\n可使用的选项：\n\n- -l 锁定口令，即禁用账号。\n- -u 口令解锁。\n- -d 使账号无口令。\n- -f 强迫用户下次登录时修改口令。\n\n如果默认用户名，则修改当前用户的口令。\n\n例如，假设当前用户是kuangshen，则下面的命令修改该用户自己的口令：\n\n```\n$ passwd\nOld password:******\nNew password:*******\nRe-enter new password:*******\n```\n\n如果是超级用户，可以用下列形式指定任何用户的口令：\n\n```\n# passwd kuangshen\nNew password:*******\nRe-enter new password:*******\n```\n\n普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。\n\n为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。\n\n为用户指定空口令时，执行下列形式的命令：\n\n```\n# passwd -d kuangshen\n```\n\n此命令将用户 kuangshen的口令删除，这样用户 kuangshen下一次登录时，系统就不再允许该用户登录了。\n\npasswd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：\n\n```\n# passwd -l kuangshen\n```\n\n\n\n### 用户组管理\n\n每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。\n\n用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。\n\n> 增加一个新的用户组使用groupadd命令\n\n```\ngroupadd 选项 用户组\n```\n\n可以使用的选项有：\n\n- -g GID 指定新用户组的组标识号（GID）。\n- -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。\n\n实例1：\n\n```\n# groupadd group1\n```\n\n此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。\n\n实例2：\n\n```\n# groupadd -g 101 group2\n```\n\n此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。\n\n\n\n> 如果要删除一个已有的用户组，使用groupdel命令\n\n```\ngroupdel 用户组\n```\n\n例如：\n\n```\n# groupdel group1\n```\n\n此命令从系统中删除组group1。\n\n\n\n> 修改用户组的属性使用groupmod命令\n\n```\ngroupmod 选项 用户组\n```\n\n常用的选项有：\n\n- -g GID 为用户组指定新的组标识号。\n- -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。\n- -n新用户组 将用户组的名字改为新名字\n\n```\n# 此命令将组group2的组标识号修改为102。\ngroupmod -g 102 group2\n\n# 将组group2的标识号改为10000，组名修改为group3。\ngroupmod –g 10000 -n group3 group2\n```\n\n\n\n> 切换组\n\n如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。\n\n用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：\n\n```\n$ newgrp root\n```\n\n这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。\n\n\n\n> /etc/passwd\n\n完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。\n\n与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。\n\n下面分别介绍这些文件的内容。\n\n**/etc/passwd文件是用户管理工作涉及的最重要的一个文件。**\n\nLinux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。\n\n这个文件对所有用户都是可读的。它的内容类似下面的例子：\n\n```\n＃ cat /etc/passwd\n\nroot:x:0:0:Superuser:/:\ndaemon:x:1:1:System daemons:/etc:\nbin:x:2:2:Owner of system commands:/bin:\nsys:x:3:3:Owner of system files:/usr/sys:\nadm:x:4:4:System accounting:/usr/adm:\nuucp:x:5:5:UUCP administrator:/usr/lib/uucp:\nauth:x:7:21:Authentication administrator:/tcb/files/auth:\ncron:x:9:16:Cron daemon:/usr/spool/cron:\nlisten:x:37:4:Network daemon:/usr/net/nls:\nlp:x:71:18:Printer administrator:/usr/spool/lp:\n```\n\n从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：\n\n```\n用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell\n```\n\n1）\"用户名\"是代表用户账号的字符串。\n\n通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。\n\n为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。\n\n2）“口令”一些系统中，存放着加密后的用户口令字。\n\n虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。\n\n3）“用户标识号”是一个整数，系统内部用它来标识用户。\n\n一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。\n\n通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。\n\n4）“组标识号”字段记录的是用户所属的用户组。\n\n它对应着/etc/group文件中的一条记录。\n\n5)“注释性描述”字段记录着用户的一些个人情况。\n\n例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用作finger命令的输出。\n\n6)“主目录”，也就是用户的起始工作目录。\n\n它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。\n\n7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。\n\nShell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。\n\n系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。\n\n用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。\n\n利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。\n\n8)系统中有一类用户称为伪用户（pseudo users）。\n\n这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。\n\n常见的伪用户如下所示：\n\n```\n伪 用 户 含 义\nbin 拥有可执行的用户命令文件\nsys 拥有系统文件\nadm 拥有帐户文件\nuucp UUCP使用\nlp lp或lpd子系统使用\nnobody NFS使用\n```\n\n> /etc/shadow\n\n**1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。**\n\n由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。\n\n**2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生**\n\n它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用\":\"隔开。这些字段是：\n\n```\n登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志\n```\n\n1. \"登录名\"是与/etc/passwd文件中的登录名相一致的用户账号\n2. \"口令\"字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。\n3. \"最后一次修改时间\"表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。\n4. \"最小时间间隔\"指的是两次修改口令之间所需的最小天数。\n5. \"最大时间间隔\"指的是口令保持有效的最大天数。\n6. \"警告时间\"字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。\n7. \"不活动时间\"表示的是用户没有登录活动但账号仍能保持有效的最大天数。\n8. \"失效时间\"字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。\n\n> /etc/group\n\n用户组的所有信息都存放在/etc/group文件中。\n\n将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。\n\n每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。\n\n当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。\n\n用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。\n\n用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：\n\n```\n组名:口令:组标识号:组内用户列表\n```\n\n1. \"组名\"是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。\n\n2. \"口令\"字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。\n\n3. \"组标识号\"与用户标识号类似，也是一个整数，被系统内部用来标识组。\n\n4. \"组内用户列表\"是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。\n\n   \n\n### 磁盘管理\n\n> 概述\n\nLinux磁盘管理好坏直接关系到整个系统的性能问题。\n\nLinux磁盘管理常用命令为 df、du。\n\n- df ：列出文件系统的整体磁盘使用量\n- du：检查磁盘空间使用量\n\n\n\n> df\n\ndf命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。\n\n语法：\n\n```\ndf [-ahikHTm] [目录或文件名]\n```\n\n选项与参数：\n\n- -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；\n- -k ：以 KBytes 的容量显示各文件系统；\n- -m ：以 MBytes 的容量显示各文件系统；\n- -h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；\n- -H ：以 M=1000K 取代 M=1024K 的进位方式；\n- -T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；\n- -i ：不用硬盘容量，而以 inode 的数量来显示\n\n测试：\n\n```\n# 将系统内所有的文件系统列出来！\n# 在 Linux 底下如果 df 没有加任何选项\n# 那么默认会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！\n[root@kuangshen /]# df\nFilesystem     1K-blocks   Used Available Use% Mounted on\ndevtmpfs          889100       0    889100   0% /dev\ntmpfs             899460     704    898756   1% /dev/shm\ntmpfs             899460     496    898964   1% /run\ntmpfs             899460       0    899460   0% /sys/fs/cgroup\n/dev/vda1       41152812 6586736  32662368  17% /\ntmpfs             179896       0    179896   0% /run/user/0\n# 将容量结果以易读的容量格式显示出来\n[root@kuangshen /]# df -h\nFilesystem     Size Used Avail Use% Mounted on\ndevtmpfs       869M     0 869M   0% /dev\ntmpfs           879M 708K 878M   1% /dev/shm\ntmpfs           879M 496K 878M   1% /run\ntmpfs           879M     0 879M   0% /sys/fs/cgroup\n/dev/vda1       40G  6.3G   32G  17% /\ntmpfs           176M     0 176M   0% /run/user/0\n# 将系统内的所有特殊文件格式及名称都列出来\n[root@kuangshen /]# df -aT\nFilesystem     Type       1K-blocks   Used Available Use% Mounted on\nsysfs         sysfs               0       0         0    - /sys\nproc           proc                0       0         0    - /proc\ndevtmpfs       devtmpfs       889100       0    889100   0% /dev\nsecurityfs     securityfs          0       0         0    - /sys/kernel/security\ntmpfs         tmpfs          899460     708    898752   1% /dev/shm\ndevpts         devpts              0       0         0    - /dev/pts\ntmpfs         tmpfs          899460     496    898964   1% /run\ntmpfs         tmpfs          899460       0    899460   0% /sys/fs/cgroup\ncgroup         cgroup              0       0         0    - /sys/fs/cgroup/systemd\npstore         pstore              0       0         0    - /sys/fs/pstore\ncgroup         cgroup              0       0         0    - /sys/fs/cgroup/freezer\ncgroup         cgroup              0       0         0    - /sys/fs/cgroup/cpuset\ncgroup         cgroup              0       0         0    - /sys/fs/cgroup/hugetlb\ncgroup         cgroup              0       0         0    - /sys/fs/cgroup/blkio\ncgroup         cgroup              0       0         0    - /sys/fs/cgroup/net_cls,net_prio\ncgroup         cgroup              0       0         0    - /sys/fs/cgroup/memory\ncgroup         cgroup              0       0         0    - /sys/fs/cgroup/pids\ncgroup         cgroup              0       0         0    - /sys/fs/cgroup/cpu,cpuacct\ncgroup         cgroup              0       0         0    - /sys/fs/cgroup/devices\ncgroup         cgroup              0       0         0    - /sys/fs/cgroup/perf_event\nconfigfs       configfs            0       0         0    - /sys/kernel/config\n/dev/vda1     ext4         41152812 6586748  32662356  17% /\nsystemd-1      -                   -       -         -    - /proc/sys/fs/binfmt_misc\nmqueue         mqueue              0       0         0    - /dev/mqueue\ndebugfs       debugfs             0       0         0    - /sys/kernel/debug\nhugetlbfs     hugetlbfs           0       0         0    - /dev/hugepages\ntmpfs         tmpfs          179896       0    179896   0% /run/user/0\nbinfmt_misc   binfmt_misc         0       0         0    - /proc/sys/fs/binfmt_misc\n# 将 /etc 底下的可用的磁盘容量以易读的容量格式显示\n\n[root@kuangshen /]# df -h /etc\nFilesystem     Size Used Avail Use% Mounted on\n/dev/vda1       40G  6.3G   32G  17% /\n```\n\n\n\n> du\n\nLinux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。\n\n语法：\n\n```\ndu [-ahskm] 文件或目录名称\n```\n\n选项与参数：\n\n- -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。\n- -h ：以人们较易读的容量格式 (G/M) 显示；\n- -s ：列出总量而已，而不列出每个各别的目录占用容量；\n- -S ：不包括子目录下的总计，与 -s 有点差别。\n- -k ：以 KBytes 列出容量显示；\n- -m ：以 MBytes 列出容量显示；\n\n测试：\n\n```\n# 只列出当前目录下的所有文件夹容量（包括隐藏文件夹）:\n# 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。\n[root@kuangshen home]# du\n16./redis\n8./www/.oracle_jre_usage  # 包括隐藏文件的目录\n24./www\n48.                        # 这个目录(.)所占用的总量\n# 将文件的容量也列出来\n[root@kuangshen home]# du -a\n4./redis/.bash_profile\n4./redis/.bash_logout    \n....中间省略....\n4./kuangstudy.txt # 有文件的列表了\n48.\n# 检查根目录底下每个目录所占用的容量\n[root@kuangshen home]# du -sm /*\n0/bin\n146/boot\n.....中间省略....\n0/proc\n.....中间省略....\n1/tmp\n3026/usr  # 系统初期最大就是他了啦！\n513/var\n2666/www\n```\n\n通配符 * 来代表每个目录。\n\n与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据。\n\n\n\n> 磁盘挂载与卸除\n\n根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载”\n\nLinux 的磁盘挂载使用mount命令，卸载使用umount命令。\n\n磁盘挂载语法：\n\n```\nmount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点\n```\n\n测试：\n\n```\n# 将 /dev/hdc6 挂载到 /mnt/hdc6 上面！\n[root@www ~]# mkdir /mnt/hdc6\n[root@www ~]# mount /dev/hdc6 /mnt/hdc6\n[root@www ~]# df\nFilesystem           1K-blocks     Used Available Use% Mounted on\n/dev/hdc6              1976312     42072   1833836   3% /mnt/hdc6\n```\n\n磁盘卸载命令 umount 语法：\n\n```\numount [-fn] 装置文件名或挂载点\n```\n\n选项与参数：\n\n- -f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；\n- -n ：不升级 /etc/mtab 情况下卸除。\n\n卸载/dev/hdc6\n\n```\n[root@www ~]# umount /dev/hdc6\n```\n\n"
  },
  {
    "id": 36,
    "title": "借助gitee提高从github克隆项目的速度",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "笔记",
    "tags": [
      ""
    ],
    "date": "2020-03-08",
    "abstract": "我们知道github是一个开源的大宝库，而gitee（码云）是国内一个类似github保管代码的平台，但因为github在国外，国内没有开代理的话，访问速度是很慢的，但是就算你开代理了，即使是200M的宽带，在克隆项目的时候，还是逃不过百度云速度。",
    "fileName": "借助gitee提高从github克隆项目的速度.md",
    "filePath": "/old_blogs/借助gitee提高从github克隆项目的速度.md",
    "mdContent": "\n\n### 前言\n\n我们知道github是一个开源的大宝库，而gitee（码云）是国内一个类似github保管代码的平台，但因为github在国外，国内没有开代理的话，访问速度是很慢的，但是就算你开代理了，即使是200M的宽带，在克隆项目的时候，还是逃不过百度云速度。\n\n\n![github](https://note.youdao.com/yws/api/personal/file/WEBb2c8dab887839f8e6fbbe068c1b29680?method=download&shareKey=3af91ecb429e07f0b227736a3232ea01 \"github\")\n\n我们可以看到速度只有几K每秒，所以当我们在克隆一些大的项目的时候，就很崩溃。\n\n最近我学习到一个可以提高克隆速度的方法，现在跟大家分享。\n\n\n\n### 将项目克隆到gitee\n\n我们注册一个gitee平台的账户，然后点击右上方**“+”**->**从GitHub/GitLab导入仓库**\n\n![1gitee](https://note.youdao.com/yws/api/personal/file/WEBd9d6fbfeae416d44689bb7f7a4e2a331?method=download&shareKey=377bfd15c6ce24b71e4bfde6417565f3 \"1\")\n\n我们去到github想要克隆的项目里面，复制url地址，**注意，是url地址，不是git clone地址**\n\n![github](https://note.youdao.com/yws/api/personal/file/WEBa207379b50d74d5a8a1b0bd63552dce9?method=download&shareKey=d523c9232b87fa6b42830b096647eaf2 \"github\")\n\n然后到我们刚刚打开的gitee页面，将我们的项目url粘贴进去，项目名字会自动识别，之后点击保存就行。\n\n![gitee](https://note.youdao.com/yws/api/personal/file/WEB8260bcd0aae079ce8971a5c67e8a5618?method=download&shareKey=bb8dd98fabdcd65cefdc45ecd8eb0cf5 \"gitee\")\n\n这个过程挺快的，我们之所以能够提高克隆速度就在于此，gitee已经帮我们把速度最慢的那一部分给解决了。\n\n<br/>\n\n### 从gitee上将项目克隆到本地\n\n我们完成将项目从github克隆到gitee后，就可以直接从gitee上将我们的项目克隆到本地了。\n\n![gitee](https://note.youdao.com/yws/api/personal/file/WEBfa8a38b3bb29f718db356e4677f72dff?method=download&shareKey=612d623967163e8a07f396e97364b043 \"gitee\")\n\n还没来得及我截图，项目就克隆完了，因为我这个是小项目，就挺快，更大的项目的话，操作起来就更加舒服了，可以看到速度都有一点多兆每秒。\n\n### 修改config文件可以将项目直接推送到github\n\n我们将项目克隆到本地后，以后的修改其实都是与gitee挂钩的，而如果你想要将修改后的文件直接保存到github的话，就可以**修改config文件**。\n\nconfig文件在项目目录里面一个名叫.git的隐藏目录。\n\n![config](https://note.youdao.com/yws/api/personal/file/WEB29c193e28bf411e4ab02884bba4fdfa7?method=download&shareKey=289b6744158d5ed725c541fa8cdd5cca \"config\")\n\n修改config文件里面的url，将gitee修改为github。\n\n![config](https://note.youdao.com/yws/api/personal/file/WEBa0f84172d01687cf1a238a60e6fcd318?method=download&shareKey=efbee97c8c3d7bc5f6478968cdaf8f3e \"config\")\n\n以后修改项目文件后，**git push**后就是推送到github上面了。\n\n\n------------\n\n内容参考来自codesheep[https://www.bilibili.com/video/av94251133](http://https://www.bilibili.com/video/av94251133 \"https://www.bilibili.com/video/av94251133\")"
  },
  {
    "id": 37,
    "title": "字典序最小问题（贪心）",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "贪心"
    ],
    "date": "2020-04-13",
    "abstract": "",
    "fileName": "字典序最小问题（贪心）.md",
    "filePath": "/old_blogs/字典序最小问题（贪心）.md",
    "mdContent": "\n\n**字典序**是指从前到后比较两个字符串大小的方法。首先比较第1个字符，如果不同则第1个字符较小的字符串更小，一直这样子比较下去。\n\n比如：\n\n`s1：ABCDE` 和 `s2：ABCCE` 两个字符串，s1的 D 比 s2的 C要更加大一点，所以s1 > s2。\n\n\n现在有这样一个问题，\n\n给定长度为N的字符串S，要构造一个长度为 N 的字符串 T。起初 ，T 是一个空串，随后反复进行下列任意操作，\n\n- 从 S 的头部删除一个字符，加到 T 的尾部。\n- 从 S 的尾部删除一个字符，加到 T 的尾部。\n\n目标是构造字典序最小的字符串 T。\n\n这类题型一般利用贪心来做，贪心就是就是遵循某种规则，不断贪心地选取当前的最优策略的算法。\n\n每做出的一步选择都是当前的最优策略，并不需要考虑整体，但难点就在于当前最优策略的选择，拿上面那道题继续分析，\n\n要创建字典序最小的字符串T，我们只需要保证字符串的前面尽量较小，所以**每次从字符串 S 的首尾取相对较小的加入到字符串 T 中**，这就是策略，但这个策略还可能遇到一个问题，如果当首尾的字符此时相等的话，该如何选择？**这时候就要比较下一个了，选择下一个字符里面相对较小的加入到字符串 T 中**。这两者结合就是我们的贪心策略。\n\n有点懵？\n\n不急，我们来看看图解。\n\n假定给定的字符串 S = “ACDBCB”，\n\n一开始，两指针指向字符串 S 的首尾，比较两者的大小，将小的一位加入到字符串 T 中，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB3456d3793d40c320734e1ed8a5f21870?method=download&shareKey=02b9e33205368bdc04735cace3be3592)\n\n![](https://note.youdao.com/yws/api/personal/file/WEBac8970a5de087e54f280c4a526c55e4b?method=download&shareKey=e83798b44b36054879de800e2e1aebbb)\n\n![](https://note.youdao.com/yws/api/personal/file/WEB51ddf14e2f9cc1246a1de464f72cde7b?method=download&shareKey=23bbeaccb17dbf86e0f321cb774de00d)\n\n此时两指针对应的字符相等，这时候要判断下一位的大小，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB1dc5c524e818afbf2fb7dee7b3d6144a?method=download&shareKey=9e06ae44b3b788c1d8373bf3868c5159)\n\nB < D，所以将右侧的先加入，\n\n![](https://note.youdao.com/yws/api/personal/file/WEB0cb4f8b41d3b817730c5180d659245d0?method=download&shareKey=d7ca2ee4470c4d9cf7a03883be814783)\n\n![](https://note.youdao.com/yws/api/personal/file/WEB679ae8133d4ba32acf96e0686f2979fc?method=download&shareKey=b2bd484581b93e0478165cb2ce3f106e)\n\n![](https://note.youdao.com/yws/api/personal/file/WEB59037fd937b928f8fc82471f6360fbaf?method=download&shareKey=92ef192f5918aa48393a61cef2d0fd54)\n\n\n\n\n应该够清晰了吧，那么我们可以写一下伪代码了，伪代码主要是总结以上思路，以便更好的转换成最终代码。\n\n```java\n# String S;\n# String T;\n# left, right\nwhile(left <= right) {\n\t如果左边较小，将左边加入T;\n    如果右变较小，将右边加入T;\n    if(相等) {\n        i = left + 1;\n        j = right - 1;\n        while(i <= j) {\n            如果左边较小，将左边加入T;\n    \t\t如果右变较小，将右边加入T;\n            if(相等)\n                i++；\n                j--;\n        }\n    }\n}\n```\n\n好，以上应该都比较好理解了，那可以直接转成我们的代码了。\n\n```java\nclass Solution {\n    public String bestCowLine(String S) {\n        String T = \"\";\n        int left = 0;\n        int right = S.length() - 1;\n        char[] temp = S.toCharArray();\n        //左右两指针，向中间移动\n        while(left <= right) {\n            //标记左边是否小过右边\n            boolean l = false;\n            //如果左右两边不一致，就跳出循环，一致就继续寻找\n            for(int i = 0; left + i <= right; i++) {\n                //如果左边小于右边，标记并跳出\n                if(temp[left + i] < temp[right - i]) {\n                    l = true;\n                    break;\n                }\n                //如果右边小于左边，标记并跳出\n                else if(temp[left + i] > temp[right - i]) {\n                    l = false;\n                    break;\n                }\n            }\n            //加入到字符串 T 中\n            if(left == true)\n                T += temp[left++];\n            else\n                T += temp[right--];\n        }\n        return T;\n    }\n}\n```"
  },
  {
    "id": 38,
    "title": "惭愧！直到今天才真正明白为什么int型的取值范围是-2^31~2^31-1",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "算法",
    "tags": [
      "位运算"
    ],
    "date": "2020-04-13",
    "abstract": "",
    "fileName": "惭愧！直到今天才真正明白为什么int型的取值范围是-2-31-2-31-1.md",
    "filePath": "/old_blogs/惭愧！直到今天才真正明白为什么int型的取值范围是-2-31-2-31-1.md",
    "mdContent": "\n## 前言\n\n虽然之前学过《计算机组成原理》，也理解了原码、补码、反码等东西，但终究还是理解不够深刻，\n\n最近在做位运算类型的题目的时候，脑子突然闪过到一个问题，\n\n**为什么 int 型数据类型的取值范围不对称呢？**\n\n**为什么最大值是 `2^31 - 1`呢？**\n\n**为什么最小值是 `-2^31`，而不是`-2^31 + 1`呢？**\n\n正如标题中所说，很惭愧，直到今天才真正弄明白，\n\n但亡羊补牢，终究未晚。\n\n\n\n## 正 负 数在计算机中的表示\n\n我们知道，计算机能够认识的只有二进制（也就是 0 和 1），而我们所认识的字符和数字都要转换成二进制才能让计算机识别并执行。\n\n这里以java的int型为例说明，\n\n我们首先要明白的是，\n\njava的 int 型是32位的，\n\n因为一个 int 值占 4 个字节 byte ，一个字节是 8 位 bit（即8个二进制位），所以 int型 占 32 位，\n\n**其中第32位，也就是最高位是符号位，正数为 0， 负数为 1**，\n\n剩下的31位是用来表示数字部分。\n\n### 正数\n\n正数在计算机中表示为 **原码**，\n\n比如：\n\n1 的原码是 ：`0000 0000 0000 0000 0000 0000 0000 0001`\n\n1 的补码是：`0000 0000 0000 0000 0000 0000 0000 0001`\n\n1 的反码是：`0000 0000 0000 0000 0000 0000 0000 0001`\n\n没错，**正数的 原码 、补码 、 反码 都相同**，\n\n那么最大是多少呢？\n\n当然是除了符号位，其他位置上都为 1 的时候，\n\n`0111 1111 1111 1111 1111 1111 1111 1111`\n\n这个数就是 **2147483647**，它是 32 位中所能表示的最大正数。\n\n### 负数\n\n负数在计算机中表示为 **补码**，\n\n比如：\n\n-1 的原码是：`1000 0000 0000 0000 0000 0000 0000 0001`\n\n-1 的反码是：`1111 1111 1111 1111 1111 1111 1111 1110`\n\n-1 的补码是：`1111 1111 1111 1111 1111 1111 1111 1111`\n\n很明显，**负数的 原码 、补码 、 反码 并不相同**，\n\n而且，\n\n**负数的原码** 是在 **正数的原码** 上 将**符号位** **取反**，\n\n**负数的反码** 是在 **负数的原码** 上 **除**符号位后 **取反**，\n\n**负数的补码** 是在 **负数的反码** 上 **加一**。\n\n**负数的补码** 也可以说是在 **负数的原码** 上 **取反加一**。\n\n所以我们再来看看 -2147483647 的表示，\n\n-2147483647 的原码是：`1111 1111 1111 1111 1111 1111 1111 1111`\n\n-2147483647 的反码是：`1000 0000 0000 0000 0000 0000 0000 0000`\n\n-2147483647 的补码是：`1000 0000 0000 0000 0000 0000 0000 0001`\n\n那它是最小值吗？\n\n不是，还有一个很奇怪的东西。\n\n\n\n## 0 在计算机中的表示\n\n在二进制中，0 有两种表示方法，\n\n+0 的原码：`0000 0000 0000 0000 0000 0000 0000 0000`\n\n-0 的原码：`1000 0000 0000 0000 0000 0000 0000 0000`\n\n因为 0 只需要一个，所以就把 -0 当成了最小的数 **-2147483648**\n\n可以这么理解，正因为 0 有两种表示方式，所以会多了一个负数出来，\n\n-2147483648 的补码就是：`1000 0000 0000 0000 0000 0000 0000 0000`，**它在 32位里面是没有原码的**。\n\n但需要注意的是，这个补码并不是真正的补码，\n\n真正的补码应该是 `1100 0000 0000 0000 0000 0000 0000 0000`，但在 java 中溢出了，\n\n所以，就是`1000 0000 0000 0000 0000 0000 0000 0000`\n\n\n经过上面，还可搞懂为什么8位的范围是[-128, 127]，是不是有点绕？\n\n嗯，我也觉得，但总算有点恍然大悟的样子。\n"
  },
  {
    "id": 39,
    "title": "操作系统的一些基本概念及其分类特征",
    "author": "WaiterXiaoYY",
    "avatar": "",
    "category": "笔记",
    "tags": [
      "OS"
    ],
    "date": "2020-03-15",
    "abstract": "",
    "fileName": "操作系统的一些基本概念及其分类特征.md",
    "filePath": "/old_blogs/操作系统的一些基本概念及其分类特征.md",
    "mdContent": "\n## 1.什么是操作系统\n\n​    操作系统是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。其主要作用是管理好这些设备，提高它们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单的接口，便于用户使用。\n\n\n## 2.什么是批处理、分时和实时系统？各有什么特征？\n\n### 批处理系统：\n\n为实现对作业的连续处理，需要先把一批作业以脱机方式输入到磁带上，并在系统中配上监督程序，在它的控制下，使这批作业能一个接着一个地连续处理。\n\n#### - 批处理系统的特点是：\n\n​    （1）脱机：是指用户脱机使用计算机，即用户提交作业之后直到获得结果之前几乎不再和计算机打交道。\n\n​    （2）多道：是指多道程序运行，即指多道程序设计的调度原则，从一批后背作业中选取多道作业调入内存并组织它们运行。\n\n​    （3）成批处理：是指操作员把用户提交的作业组织成一批，由操作系统负责每批作业间的自动调度。\n\n批处理系统自动化程度比较高，系统吞吐量达，资源利用率高，系统开销小，但各作业周转时间长，不提供用户和系统的交互手段，适合大的成熟的作业。\n\n\n### 分时系统：\n\n是指在一台主机上连接了多个配有显示器和键盘的终端由此组成的系统，该系统允许多个用户同时通过自己的终端，以交互方式使用计算机，共享主机中的资源。\n\n#### - 分时系统的特点是：\n\n（1）多路性：是指系统允许将多台终端同时连接到一台主机上，并按分时原则为每个用户服务。多路性允许多个用户共享一台计算机，显著的提高了资源利用率，降低了费用，从而促进了计算机更广泛的应用。\n\n（2）独立性：是指系统提高了这样的用机环境，即每个用户在各自的终端上进行操作，彼此之间互不干扰，给用户的感觉就像是他一人独占主机进行操作。\n\n（3）及时性：是指用户的请求能在很短的时间内获得响应。\n\n（4）交互性：是指用户可通过终端与系统进行广泛的人机对话。\n\n\n\n### 实时系统：\n\n是指系统能及时响应外部事件的请求，在规定时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。\n\n#### -  实时系统的特点是：\n\n（1）多路性：信息查询系统和分时系统中的多路性都表现为系统按分时原则为多个终端用户服务；实时控制系统的多路性是指系统周期性地对多路现场信息进行采集，以及对多个对象或多个执行机构进行控制。\n\n（2）独立性：是指对信息的采集和对对象的控制也都是彼此互不干扰的。\n\n（3）及时性：是指用户的请求能在很短的时间内获得响应，是以控制对象所要求的截止时间来确定的，一般为秒级到毫秒级。\n\n（4）交互性：是指用户可通过终端与系统进行的人机对话，它不像分时系统能够广泛的进行人机交互，实时系统的交互性仅限于用户发送的某些特定的命令。\n\n（5）可靠性：实时系统要求系统高度可靠，在实时系统中，往往都采取了多级容错措施来保护系统的安全性和数据的安全性。\n\n \n\n## 3.实现多道程序应解决哪些问题？\n\n（1）处理机争用问题。\n\n（2）内存分配和保护问题。\n\n（3）I/O设备分配问题。\n\n（4）文件的组织和管理问题。\n\n（5）作业管理问题。\n\n（6）用户与系统的接口问题。\n\n\n\n## 4.操作系统有哪些特征？最基本的特征是什么？\n\n​    （1）并发性。（2）共享性。（3）虚拟技术。（4）异步性。\n\n ##### - 最基本的特征是：\n\n并发性，共享性。\n\n\n### 5. 从交互性、及时性和可靠性几方面，比较分时系统和实时系统。\n\n​\t（1）交互性：分时系统能够向终端用户提供数据处理、资源共享等服务。而实时系统仅限于用户发送的某些特定的命令。\n\n​    （2）及时性：分时系统对实时性的要求是依据人所能接受的等待时间确定的，一般是1-3秒钟，而实时系统是以控制对象所要求的截止时间来确定的，一般为秒级到毫秒级。\n\n​    （3）可靠性：分时系统要求系统可靠，实时系统要求系统高度可靠。\n\n\n\n\n### 6.是什么原因使操作系统具有了异步性特征。\n\n​    在多道程序环境下，系统允许多个程序并发进行。在单处理机的环境下，由于系统只有一台处理机，因而每次只允许一个进程进行，其余进程只能等待。当正在执行的进程提出某种资源的要求时，正在执行的进程就必须等待，同时释放出处理机，直到再次获得处理机时，才能继续执行。\n\n \n\n "
  }
]